<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[de部落格^_^]]></title>
  <subtitle><![CDATA[Enjoy your choice, enjoy your life.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhonghuan.info/"/>
  <updated>2015-08-09T14:34:05.767Z</updated>
  <id>http://zhonghuan.info/</id>
  
  <author>
    <name><![CDATA[钟桓]]></name>
    <email><![CDATA[zhonghuanblog@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[NSDate和String之间转换的小技巧]]></title>
    <link href="http://zhonghuan.info/2015/08/09/NSDate%E5%92%8CString%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://zhonghuan.info/2015/08/09/NSDate和String之间转换的小技巧/</id>
    <published>2015-08-09T14:32:30.000Z</published>
    <updated>2015-08-09T14:33:38.000Z</updated>
    <content type="html"><![CDATA[<p>遇到处理日期的时候，也许我们有这样的需求，就是依据String生成NSDate，或者将NSDate转换成String。当然这里的String和NSDate都会具有某种格式。举个简单的例子，将字符串”2015-08-09”转换成日期，这个借助于NSFormatter就可以做到，但是可以借助extension来做一个简单的封装。例如看下面的代码：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">NSDate</span></span>{

    <span class="keyword">class</span> <span class="func"><span class="keyword">func</span></span> dateFromStringWithFormat(dateString: <span class="type">String</span>?, format: <span class="type">String</span>?) -&gt; <span class="type">NSDate</span>? {
        <span class="keyword">if</span> <span class="keyword">let</span> realDateString = dateString {
            <span class="keyword">let</span> dateFormatter = <span class="type">NSDateFormatter</span>()
            dateFormatter.dateFormat = format
            <span class="keyword">let</span> date = dateFormatter.dateFromString(realDateString)
            <span class="keyword">return</span> date
        }
        <span class="keyword">return</span> <span class="built_in">nil</span>
    }

    <span class="keyword">class</span> <span class="func"><span class="keyword">func</span></span> stringFromDateWithFormat(date: <span class="type">NSDate</span>?, format: <span class="type">String</span>?) -&gt; <span class="type">String</span>? {
        <span class="keyword">if</span> <span class="keyword">let</span> realDate = date {
            <span class="keyword">let</span> dateFormatter = <span class="type">NSDateFormatter</span>()
            dateFormatter.dateFormat = format
            <span class="keyword">let</span> str = dateFormatter.stringFromDate(realDate)
            <span class="keyword">return</span> str
        }
        <span class="keyword">return</span>  <span class="built_in">nil</span>

    }

}
</code></pre><p>调用的时候，只需要使用下面的方式：</p>
<pre><code><span class="keyword">let</span> date = NSDate.dateFromStringWithFormat(<span class="string">"2015-08-09"</span>, forma<span class="variable">t:</span> <span class="string">"yyyy-MM-dd"</span>)
<span class="keyword">let</span> str = NSDate.stringFromDateWithFormat(date, forma<span class="variable">t:</span> <span class="string">"yyyy-MM-dd"</span>)
</code></pre><p>希望能够有所帮助。</p>
<hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一快两块的，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Array存大量数据技巧]]></title>
    <link href="http://zhonghuan.info/2015/07/16/%E4%BD%BF%E7%94%A8Array%E5%AD%98%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8A%80%E5%B7%A7/"/>
    <id>http://zhonghuan.info/2015/07/16/使用Array存大量数据技巧/</id>
    <published>2015-07-16T03:01:43.000Z</published>
    <updated>2015-07-16T03:03:23.000Z</updated>
    <content type="html"><![CDATA[<p>Array的介绍上说 “Every array has a region of memory which stores the content of the array. If the array’s Element type is not a class or @objc protocol type, this storage is a contiguous block of memory; ”</p>
<p>从这句可以解读出，Array是存储在一块连续的内存空间中，但也注意到前提是Array存储的不是对象，但Array存储对象的时候，应该存储的是指向对象的地址，所以，暂且可以当做都是连续存储的。</p>
<p>这样，会产生一个疑问，如果，连续的存储空间被占满了怎么办？</p>
<p>Swift采取的措施就是，分配一个更大的内存空间，将现有空间数据拷贝到新的存储空间中去。打个比方说，如果我们声明一个数组，例如：<code>var array  = Array&lt;Int&gt;()</code>,它一开始分配一块能够存储<code>1000</code>个<code>Int</code>的连续内存，现在你添加了<code>1050</code>个 <code>Int</code>到array中，结果，在存储第<code>1001</code> 个 <code>Int</code>的时候，发生了这么一件事，系统给array重新分配了一个存储空间，可能是原先的几倍的大小，然后将原有的数据拷贝到新的空间中去，就这样，array能够存储更多的数据。</p>
<p>但是如果数组数据大的时候，多几次上述的分配新内存，拷贝原有数据这样的操作，会消耗额外的时间，所以，如果你知道数组最少会存储多少数据，可以预先分配一个大的存储空间，避免中间的环节造成的额外的时间消耗。</p>
<p>预先分配存储空间的方式就是调用<code>Array</code>的<code>reserveCapacity(minimumCapacity: Int)</code>方法，我们可以做一个测试，来检测，使用预先分配的方式，是否可以缩短运行时间，提升效率。例如，看下面程序。</p>
<pre><code><span class="keyword">import</span> <span class="type">Foundation</span>

<span class="class"><span class="keyword">class</span> <span class="title">ParkBenchTimer</span> </span>{

    <span class="keyword">let</span> startTime:<span class="type">CFAbsoluteTime</span>
    <span class="keyword">var</span> endTime:<span class="type">CFAbsoluteTime</span>?

    <span class="keyword">init</span>() {
        startTime = <span class="type">CFAbsoluteTimeGetCurrent</span>() <span class="comment">// 获取系统当前的绝对时间，是从2001年1月1日0时0分到现在的绝对时间</span>
    }

    <span class="func"><span class="keyword">func</span></span> stop() -&gt; <span class="type">CFAbsoluteTime</span> {
        endTime = <span class="type">CFAbsoluteTimeGetCurrent</span>()

        <span class="keyword">return</span> duration!
    }

    <span class="keyword">var</span> duration:<span class="type">CFAbsoluteTime</span>? {
        <span class="keyword">if</span> <span class="keyword">let</span> endTime = endTime {
            <span class="keyword">return</span> endTime - startTime  <span class="comment">// 中间经过的时间</span>
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="built_in">nil</span>
        }
    }
}

<span class="keyword">let</span> <span class="type">NUM</span> = <span class="number">5000000</span> <span class="comment">// 可以通过改变NUM的大小，观察不同情况下，效率如何。</span>

<span class="keyword">var</span> list1 = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()

<span class="keyword">let</span> time1 = <span class="type">ParkBenchTimer</span>()
<span class="comment">//let start = NSDate(); // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Start time  也可是使用NSDate来计算中间经过的时间</span>

<span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="type">NUM</span> ; i++ {
    list1.append(i)
}

<span class="comment">//let end = NSDate();   // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;   end time</span>
<span class="comment">//let timeInterval: Double = end.timeIntervalSinceDate(start); // &lt;&lt;&lt;&lt;&lt; Difference in seconds (double)</span>
<span class="comment">//print("\(timeInterval) seconds");</span>

<span class="built_in">print</span> (<span class="string">"未预先分配， 时间：<span class="subst">\(time1.stop()</span>)"</span>)

<span class="keyword">var</span> list2 = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()
list2.reserveCapacity(<span class="type">NUM</span>) <span class="comment">//预先说明分配的最小存储空间</span>

<span class="keyword">let</span> time2 = <span class="type">ParkBenchTimer</span>()

<span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="type">NUM</span> ; i++ {
    list2.append(i)
}

<span class="built_in">print</span>(<span class="string">"预先分配， 时间：<span class="subst">\(time2.stop()</span>)"</span>)
</code></pre><p>根据观察，总体情况，预先分配会节省时间。</p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[小贼音乐--swift开发笔记_step_3]]></title>
    <link href="http://zhonghuan.info/2015/05/30/%E5%B0%8F%E8%B4%BC%E9%9F%B3%E4%B9%90-swift%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-step-3/"/>
    <id>http://zhonghuan.info/2015/05/30/小贼音乐-swift开发笔记-step-3/</id>
    <published>2015-05-29T18:04:15.000Z</published>
    <updated>2015-05-29T18:18:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="小贼音乐—Swift开发笔记_Step_3">小贼音乐—Swift开发笔记 Step 3</h1>
<hr>
<p>小贼音乐的最终效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/zhEmotionMusicInfo.gif" alt=""></p>
<p>代码开源在我的github上，喜欢请点个赞。<a href="https://github.com/ZHONGHuanGit/ZHEmotionMusic" target="_blank" rel="external">https://github.com/ZHONGHuanGit/ZHEmotionMusic</a></p>
<hr>
<p>在step2中，我们完成了一个简易版本的，能够通过扫描人脸进行播放歌曲的音乐播放器。在前面我们也提到了，一登默认的权限，并没有获取表情的功能，幸运的是，本人申请得到了这个高级权限(一登的负责的哥们儿还是挺好说话的，哈哈，可以尝试申请弄个权限来玩玩，题外话，高级功能中，本人的颜值只有0.3，满分是1，o(╯□╰)o)。</p>
<p>所以，现在有表情识别的权限了，当然想把它做得更好一些了。不过暂时我只选取了四个表情进行识别，分别是：</p>
<ol>
<li>Happy </li>
<li>Sad</li>
<li>Calm</li>
<li>Angry</li>
</ol>
<p>其余表情，个人感觉放在音乐中，不是特别合适.然后，我们在storyboard中，添加一个view，放到当前viewController底部。是一个固定高度120的view，再添加几个表情，最终效果图如下:</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/image7.PNG" alt=""></p>
<p>注意，底部的表情，使用的是autolayout的等距离约束，如果不了解的话，可以看这篇<a href="http://devtian.me/2015/03/25/如何在Autolayout中设置等距约束/" target="_blank" rel="external">blog</a>,到我的github山，可以下载这些表情图片，顺便说一下，表情都是使用sketch简单的制作，颜值不是很高。</p>
<p>然后新建一个MoodUIView类，继承UIView，将最底下view对应的类改为MoodUIView，绑定MoodUIView到viewController中，并且增添一个swipeHandler方法，来处理上下滑动手势。</p>
<pre><code>    <span class="comment">/**
        上下滑动处理函数

    :param: sender 滑动手势
    */</span>
    func swipeHandler(sender : UISwipeGestureRecognizer){

        <span class="built_in">var</span> frameY <span class="subst">=</span> <span class="built_in">self</span><span class="built_in">.</span>view<span class="built_in">.</span>frame<span class="built_in">.</span>height

        <span class="keyword">if</span> sender<span class="built_in">.</span>direction <span class="subst">==</span> <span class="built_in">.</span>Up{
            <span class="keyword">let</span> h <span class="subst">=</span> frameY <span class="subst">-</span> <span class="built_in">self</span><span class="built_in">.</span>moodView<span class="built_in">.</span>center<span class="built_in">.</span>y

            <span class="keyword">if</span> h <span class="subst">&lt;</span> <span class="number">0</span> {

                UIView<span class="built_in">.</span>animateWithDuration(<span class="number">2</span>, delay: <span class="number">0</span>, usingSpringWithDamping: <span class="number">0.3</span>, initialSpringVelocity: <span class="number">20</span>, options: UIViewAnimationOptions<span class="built_in">.</span>CurveEaseInOut, animations: { () <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span>

                    <span class="built_in">self</span><span class="built_in">.</span>moodView<span class="built_in">.</span>center<span class="built_in">.</span>y <span class="subst">-=</span> <span class="number">120</span>

                    }, completion: { (ok) <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span>
                })

            }
        }

        <span class="keyword">if</span> sender<span class="built_in">.</span>direction <span class="subst">==</span> <span class="built_in">.</span>Down{
            <span class="keyword">let</span> h <span class="subst">=</span> frameY <span class="subst">-</span> <span class="built_in">self</span><span class="built_in">.</span>moodView<span class="built_in">.</span>center<span class="built_in">.</span>y

            <span class="keyword">if</span> h <span class="subst">&gt;</span> <span class="number">0</span> {

                UIView<span class="built_in">.</span>animateWithDuration( <span class="number">0.3</span> , delay: <span class="number">0</span>, options: UIViewAnimationOptions<span class="built_in">.</span>CurveEaseInOut, animations: { () <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span>

                    <span class="built_in">self</span><span class="built_in">.</span>moodView<span class="built_in">.</span>center<span class="built_in">.</span>y <span class="subst">+=</span> <span class="number">120</span>

                    }, completion: { (ok) <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span>
                })

            }

        }

    }
</code></pre><p>然后，在viewDidLoad中添加：</p>
<pre><code>         <span class="comment">//添加Swipgesture</span>
        <span class="keyword">var</span> up = <span class="type">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">"swipeHandler:"</span>)
        <span class="keyword">var</span> down = <span class="type">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">"swipeHandler:"</span>)

        up.direction = .<span class="type">Up</span>
        down.direction = .<span class="type">Down</span>

        <span class="keyword">self</span>.view.addGestureRecognizer(up)
        <span class="keyword">self</span>.view.addGestureRecognizer(down)
</code></pre><p>运行后，可以看到上下滑动的手势操作效果。</p>
<p>在main.storyboard中，给每个表情图标和对应的label，添加一个不带透明的button，用来响应点击事件。这里的点击事件，就是用户，手动选择更换频道。添加方法：</p>
<pre><code>     <span class="javadoc">/**
        用户主动点击表情，切换频道的处理函数

    :param: sender 标识点击的表情
    */</span>
    <span class="annotation">@IBAction</span> func moodViewTapped(sender : UIButton){

        <span class="comment">//通过UIImageView的tag进行标示，可以在storyboard对应的utility的attribute inspector中设置</span>
        <span class="keyword">switch</span> sender.tag{
        <span class="keyword">case</span> <span class="number">0</span>:
            emotion = Emotion.happy
        <span class="keyword">case</span> <span class="number">1</span>:
            emotion = Emotion.sad
        <span class="keyword">case</span> <span class="number">2</span>:
            emotion = Emotion.calm
        <span class="keyword">default</span>:
            emotion = Emotion.angry
        }

        updateMoodView()

          UIView.animateWithDuration( <span class="number">0.3</span> , delay: <span class="number">0.2</span>, options: UIViewAnimationOptions.CurveEaseInOut, animations: { () -&gt; Void in

        self.moodView.center.y += <span class="number">120</span>

        }, completion: { (ok) -&gt; Void in
    })


        http.onSearch(emotion.rawValue)

    }
</code></pre><p>接下来，需要增加一个pan gesture，初定的功能是，向左pan切换歌曲，向右暂停。</p>
<pre><code><span class="comment">// MARK: - Pan gesture</span>

     <span class="comment">/**
        control view 拖动手势处理函数

    :param: sender
    */</span>
    <span class="func"><span class="keyword">func</span></span> drag(sender : <span class="type">UIPanGestureRecognizer</span>){

        <span class="keyword">let</span> xDistance:<span class="type">CGFloat</span> = sender.translationInView(<span class="keyword">self</span>.view).x
        <span class="keyword">let</span> yDistance:<span class="type">CGFloat</span> = sender.translationInView(<span class="keyword">self</span>.view).y

        <span class="keyword">switch</span> sender.state{
        <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Began</span>:
            <span class="built_in">println</span>(<span class="string">"begin"</span>)
        <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Changed</span>:

            <span class="keyword">self</span>.controlView.center.x = originalPoint.x + xDistance
            <span class="keyword">var</span> nowX = <span class="keyword">self</span>.controlView.center.x

            <span class="comment">//展示下一首 label</span>
            <span class="keyword">if</span> nowX &lt;= originalPoint.x - <span class="number">120</span> {
                <span class="keyword">self</span>.nextLabel.hidden = <span class="built_in">false</span>
            }<span class="keyword">else</span>{
                <span class="keyword">self</span>.nextLabel.hidden = <span class="built_in">true</span>
            }

            <span class="comment">//展示暂停  label</span>
            <span class="keyword">if</span> nowX &gt;= originalPoint.x + <span class="number">120</span>{
                <span class="keyword">self</span>.pauseLabel.hidden = <span class="built_in">false</span>
            }<span class="keyword">else</span>{
                <span class="keyword">self</span>.pauseLabel.hidden = <span class="built_in">true</span>
            }

        <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Ended</span>:

            <span class="keyword">var</span> nowX = <span class="keyword">self</span>.controlView.center.x

            <span class="keyword">self</span>.nextLabel.hidden = <span class="built_in">true</span>

            <span class="comment">//需要切换歌曲</span>
            <span class="keyword">if</span> nowX &lt;= originalPoint.x - <span class="number">120</span>{
                <span class="keyword">self</span>.nextLabel.hidden = <span class="built_in">true</span>
                <span class="keyword">self</span>.playerDidFinishPlaying()
                <span class="type">UIView</span>.animateWithDuration( <span class="number">0.3</span> , delay: <span class="number">0</span>, options: <span class="type">UIViewAnimationOptions</span>.<span class="type">CurveEaseInOut</span>, animations: { () -&gt; <span class="type">Void</span> <span class="keyword">in</span>

                    <span class="keyword">self</span>.controlView.center.x = <span class="keyword">self</span>.originalPoint.x

                    }, completion: <span class="built_in">nil</span>)

            }
            <span class="comment">//需要暂停</span>
            <span class="keyword">else</span> <span class="keyword">if</span> nowX &gt;= originalPoint.x + <span class="number">120</span>{

                <span class="keyword">self</span>.circularProgressView.pause()

                <span class="type">UIView</span>.animateWithDuration( <span class="number">0.3</span> , delay: <span class="number">0</span>, options: <span class="type">UIViewAnimationOptions</span>.<span class="type">CurveEaseInOut</span>, animations: { () -&gt; <span class="type">Void</span> <span class="keyword">in</span>

                    <span class="keyword">self</span>.controlView.center.x = <span class="keyword">self</span>.view.frame.width

                    }, completion: <span class="built_in">nil</span>)


            }<span class="keyword">else</span>{

                <span class="keyword">self</span>.circularProgressView.play()

                <span class="type">UIView</span>.animateWithDuration( <span class="number">0.3</span> , delay: <span class="number">0</span>, options: <span class="type">UIViewAnimationOptions</span>.<span class="type">CurveEaseInOut</span>, animations: { () -&gt; <span class="type">Void</span> <span class="keyword">in</span>

                    <span class="keyword">self</span>.controlView.center.x = <span class="keyword">self</span>.originalPoint.x

                    }, completion: <span class="built_in">nil</span>)

            }



        <span class="keyword">default</span>:
            <span class="built_in">println</span>(<span class="string">"default"</span>)
        }

    }
</code></pre><p>还有部分操作，不过可以查看源码，获取详情。</p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
      <category term="小贼音乐" scheme="http://zhonghuan.info/categories/Swift/%E5%B0%8F%E8%B4%BC%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[小贼音乐--swift开发笔记_step_2]]></title>
    <link href="http://zhonghuan.info/2015/05/30/%E5%B0%8F%E8%B4%BC%E9%9F%B3%E4%B9%90-swift%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-step-2/"/>
    <id>http://zhonghuan.info/2015/05/30/小贼音乐-swift开发笔记-step-2/</id>
    <published>2015-05-29T18:04:12.000Z</published>
    <updated>2015-05-29T18:18:23.000Z</updated>
    <content type="html"><![CDATA[<p>小贼音乐的最终效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/zhEmotionMusicInfo.gif" alt=""></p>
<p>代码开源在我的github上，喜欢请点个赞。<a href="https://github.com/ZHONGHuanGit/ZHEmotionMusic" target="_blank" rel="external">https://github.com/ZHONGHuanGit/ZHEmotionMusic</a></p>
<hr>
<p>在step1中，我们可以识别人脸表情，在这一步中，我们加入音乐的功能。时不我待，开始吧。</p>
<p>首先了解我们希望得到的最终结果，如下图，是一个能够扫描心情，并且播放音乐：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/image6.PNG" alt=""></p>
<hr>
<h3 id="导入CircularProgressView">导入CircularProgressView</h3>
<p>什么是ProgressView，应该了解，那么前面加了个Circular，意思很明确了，就是在圆形的progress view了，不过它的实现并没有继承progress view，而是继承自view再实现。它虽然带着ProgressView的名字，却也扮演着播放器的角色。可以看<a href="https://cocoapods.org/pods/CircularProgressView" target="_blank" rel="external">这篇blog了解它</a>。由于原作者的版本，音乐播放并不支持网络上的音乐，所以，我更新了其实现方式，更改了内部的播放器，让它支持网络上的音乐文件。<strong>更新的CircularProgressView开源在<a href="https://github.com/ZHONGHuanGit/CircularProgressView" target="_blank" rel="external">github</a>。</strong> <strong><em>喜欢点个赞哈</em></strong> </p>
<p>按照github上面的步骤，我们将CircularProgressView.h和CircularProgressView.m导入我们的项目中，并且新建了一个group，起名CircularProgressView。方便代码审阅。并且把CircularProgressViewDemo中的“我的歌声里”这首歌添加进我们的项目。</p>
<p>导入了objective-c代码，由于我们在项目中需要使用它，所以需要在ZHEmotionMusic-Bridging-Header中登记一下，添加代码如下：</p>
<pre><code>    #<span class="keyword">import</span> <span class="string">"CircularProgressView.h"</span>
</code></pre><p>然后在Main.storyboard中，添加一个View(注意，放在原先图像后面)，在其对应的Identity Inspector中，更改class为CircularProgressView.h。在size inspector中，更改大小为256*256。<br>因为我们希望一会儿圆圈的line width是4.然后，往ViewController中，添加如下代码。</p>
<pre><code>    <span class="keyword">self</span><span class="variable">.circularProgressView</span><span class="variable">.backColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">236.0</span> / <span class="number">255.0</span>, green: <span class="number">236.0</span> / <span class="number">255.0</span>, blue: <span class="number">236.0</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)
            <span class="keyword">self</span><span class="variable">.circularProgressView</span><span class="variable">.progressColor</span> = <span class="built_in">UIColor</span>(red: <span class="number">0</span>, green: <span class="number">0</span>, blue: <span class="number">0</span>, alpha: <span class="number">1.0</span>)
            <span class="keyword">self</span><span class="variable">.circularProgressView</span><span class="variable">.lineWidth</span> = <span class="number">4</span>
            <span class="keyword">self</span><span class="variable">.circularProgressView</span><span class="variable">.audioURL</span> = <span class="built_in">NSBundle</span><span class="variable">.mainBundle</span>()<span class="variable">.URLForResource</span>(<span class="string">"我的歌声里"</span>, withExtension: <span class="string">"mp3"</span>)
             <span class="keyword">self</span><span class="variable">.circularProgressView</span><span class="variable">.play</span>()
</code></pre><p>然后尝试运行，啊哦，我们希望的圈圈和原来的视图中间的图像不是很搭，这下怎么办？原因是，师徒中间的imageview使用了autolayout进行了适配，所以，为了让它们时间永远保存某种关系，可以对后面添加的view进行autolayout，我选择的方式，就是让view的top，bottom，left，right始终和imageView保持距离3。增加完autolayout后，运行，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/image5.png" alt=""></p>
<p>中间的黑色线条，其在园中的百分比，就是歌曲进行的百分比。同时你可以听到音乐的播放。</p>
<hr>
<h3 id="水水的添加音乐">水水的添加音乐</h3>
<p>由于暂时没有找到合适的根据心情，提供音乐的API，所以，就先水水的拿一个冒牌的东东来暂时替代一下吧。一些内容来自<a href="http://www.swiftv.cn/course/hwxktqix" target="_blank" rel="external">【老镇出品】实战-豆瓣电台</a>,如果从没使用swift进行网络编程的话，可以去看一下这个视频教程，里面的内容相对来说更基础，在我们的实现中，对视频中讲解的代码做了一些改进，如果你看了视频的话，可以稍微注意下，希望有所帮助。</p>
<p>在step1中，我们暂且定义了两个表情，开心，不开心。所以需要两个源，一个是获取开心的音乐，一个获取不开心的音乐，之所以说水水的，看下面的代码：</p>
<pre><code><span class="comment"><span class="xmlDocTag">///</span> 快乐就听摇滚</span>
<span class="keyword">let</span> happySongsURL = <span class="string">"http://douban.fm/j/mine/playlist?channel=7"</span>

<span class="comment"><span class="xmlDocTag">///</span> 悲伤就听R&amp;B</span>
<span class="keyword">let</span> sadSongsURL = <span class="string">"http://douban.fm/j/mine/playlist?channel=14"</span>
</code></pre><p>从代码中，可以体会出，我将豆瓣的摇滚当做快乐的音乐源，将R&amp;B当做悲伤的音乐源。不好意思，暂时没有合适的，就先这样了，大家见谅一下吧。</p>
<p>下一步，新建一个HttpController.swift文件，然后添加如下代码：</p>
<pre><code><span class="keyword">import</span> UIKit

<span class="javadoc">/**
*  协议负责处理网络连接后的数据处理
*/</span>
protocol HttpProtocol{
    <span class="javadoc">/**
    负责处理网络连接后的数据处理

    :param: results 需要处理的数据
    */</span>
    func didReceiveResults(results : NSDictionary)

}

<span class="javadoc">/**
*  负责网络连接
*/</span>
class HttpController: NSObject {

    var delegate : HttpProtocol?

    <span class="javadoc">/**
        给定url，访问网络资源

    :param: url 资源URL地址
    */</span>
    func onSearch(url : String) {

        UIApplication.sharedApplication().networkActivityIndicatorVisible = <span class="keyword">true</span>

        let nsUrl = NSURL(string: url)
        let request:NSURLRequest = NSURLRequest(URL : nsUrl!)
        let config = NSURLSessionConfiguration.defaultSessionConfiguration()
        let session = NSURLSession(configuration: config)
        let task = session.dataTaskWithRequest(request){
            (data,response,error) -&gt; Void in
            <span class="keyword">if</span> error == nil {

                var jsonResult : NSDictionary  = NSJSONSerialization.JSONObjectWithData(data,options:NSJSONReadingOptions.MutableContainers, error : nil) as! NSDictionary


                self.delegate?.didReceiveResults(jsonResult)

            }<span class="keyword">else</span>{
                println(error)
            }


        }

        task.resume()

    }


}
</code></pre><p>HttpController的作用是负责Http的连接，通过IOS的NSURLSession，获取我们需要的内容。</p>
<p>何时调用HttpController呢？ 答案就是，扫描表情之后，所以需要修改ViewController。首先，在ViewController中，添加一个属性， </p>
<pre><code><span class="comment">/// 用来获取网络数据</span>
<span class="keyword">var</span> http : HttpController = HttpController()
</code></pre><p>http是HttpController的一个实例，用来获取网络的数据。修改SuperID方法，如下：</p>
<pre><code> /**
    <span class="type">Description</span>
            用户在一登 <span class="type">SDK</span> 完成人脸属性检测事件后，<span class="type">SDK</span> 将执行协议中的方法，就是本方法，开发者可本方法中进行根据需要相应事件处理
    :param: sender       <span class="type">SuperID</span>实例
    :param: featureInfo  检测的人脸信息
    :param: error        error == <span class="keyword">nil</span> 则不发生错误； 否则发生错误。
    */
    func superID(sender: <span class="type">SuperID</span>!, userDidFinishGetFaceFeatureWithFeatureInfo featureInfo: [<span class="type">NSObject</span> : <span class="type">AnyObject</span>]!, error: <span class="type">NSError</span>!) {
        <span class="keyword">if</span>(error == <span class="keyword">nil</span>){
            println(<span class="string">"操作成功!"</span>)

            println(featureInfo)
//            <span class="keyword">var</span> info = featureInfo!

            //因为featureInfo和其内部的数据，都是optional类型，需要 unwrap
            <span class="keyword">if</span> <span class="keyword">let</span> info = featureInfo {
                <span class="keyword">var</span> smileResult = info[<span class="string">"smiling"</span>]!
                <span class="keyword">var</span> <span class="literal">result</span> = smileResult[<span class="string">"result"</span>] <span class="keyword">as</span>! <span class="type">Int</span>
                <span class="keyword">var</span> score = smileResult[<span class="string">"score"</span>] <span class="keyword">as</span>! <span class="type">Double</span>
                println(score)
                <span class="keyword">if</span> <span class="literal">result</span> == <span class="number">1</span> {
                    imageView.image = <span class="type">UIImage</span>(named: <span class="string">"happy"</span>)
                    label1.text = <span class="string">"诶哟！"</span>
                    label2.text = <span class="string">"今天心情不错哦！"</span>
                    //获取happy歌曲的数据
                    http.onSearch(happySongsURL)

                }<span class="keyword">else</span>{
                    imageView.image = <span class="type">UIImage</span>(named: <span class="string">"sad"</span>)
                    label1.text = <span class="string">"唉！一言以蔽之"</span>
                    label2.text = <span class="string">"心好涩"</span>
                    //获取sad歌曲的数据
                    http.onSearch(sadSongsURL)
                }
            }

        }
        <span class="keyword">else</span>{
            println(<span class="string">"操作失败!"</span>)

            println(<span class="string">"\(error.code)   \(error.description)"</span>)
        }
    }
</code></pre><p>从前面可以看到，HttpController有一个delegate，属于HttpProtocol类型，专门负责处理从网络上获取的得来的数据。所以，我们让ViewController视线HttpProtocol协议，然后在其内部实现didReceiveResults方法，如下：</p>
<pre><code>     <span class="javadoc">/**
        负责处理从网络上获取的数据

    :param: results 获取得到的数据
    */</span>
    func didReceiveResults(results : NSDictionary){
        println(<span class="string">"数据成功接收"</span>)
        println(results)
    }
</code></pre><p>不要忘了在viewDidLoad中，设置http的delegate，添加如下代码：</p>
<pre><code><span class="comment">//http的处理交给当前实现HttpProtocol的ViewController来处理</span>
        http.<span class="keyword">delegate</span> = <span class="keyword">self</span>
</code></pre><p>运行，控制台会输出，一些从网络上获取得到的歌曲信息。现在来看看怎么处理这些信息。前提是，了解这些信息的格式，这些信息都是json数据格式，在浏览器中，访问 <a href="http://douban.fm/j/mine/playlist?channel=7" target="_blank" rel="external">http://douban.fm/j/mine/playlist?channel=7</a> 。 显示一大堆数据，它们都是json格式，复制这些数据，然后访问 <a href="http://jsoneditoronline.org" target="_blank" rel="external">http://jsoneditoronline.org</a> 。json editor online 能够将乱乱的json格式数据，排列成有序的，易于阅读的格式。看一下获取的json数据参考格式：</p>
<pre><code>    {
        "<span class="attribute">r</span>": <span class="value"><span class="number">0</span></span>,
        "<span class="attribute">is_show_quick_start</span>": <span class="value"><span class="number">0</span></span>,
        "<span class="attribute">song</span>": <span class="value">[
            {
                "<span class="attribute">album</span>": <span class="value"><span class="string">"/subject/7153475/"</span></span>,
                "<span class="attribute">picture</span>": <span class="value"><span class="string">"http://img3.douban.com/lpic/s7022222.jpg"</span></span>,
                "<span class="attribute">ssid</span>": <span class="value"><span class="string">"cd19"</span></span>,
                "<span class="attribute">artist</span>": <span class="value"><span class="string">"Herman's Hermits"</span></span>,
                "<span class="attribute">url</span>": <span class="value"><span class="string">"http://mr3.douban.com/201406201304/a687b5d793bb3233e243f05a3e502b20/view/song/small/p2087018.mp3"</span></span>,
                "<span class="attribute">company</span>": <span class="value"><span class="string">"Warner"</span></span>,
                "<span class="attribute">title</span>": <span class="value"><span class="string">"Smile Please"</span></span>,
                "<span class="attribute">rating_avg</span>": <span class="value"><span class="number">0</span></span>,
                "<span class="attribute">length</span>": <span class="value"><span class="number">165</span></span>,
                "<span class="attribute">subtype</span>": <span class="value"><span class="string">""</span></span>,
                "<span class="attribute">public_time</span>": <span class="value"><span class="string">"2004"</span></span>,
                "<span class="attribute">songlists_count</span>": <span class="value"><span class="number">0</span></span>,
                "<span class="attribute">sid</span>": <span class="value"><span class="string">"2087018"</span></span>,
                "<span class="attribute">aid</span>": <span class="value"><span class="string">"7153475"</span></span>,
                "<span class="attribute">sha256</span>": <span class="value"><span class="string">"5f6ba79e1463c1b54d0be17d090d4ee09d55121a91905ddd2217b0ba458ca7a2"</span></span>,
                "<span class="attribute">kbps</span>": <span class="value"><span class="string">"64"</span></span>,
                "<span class="attribute">albumtitle</span>": <span class="value"><span class="string">"The Best of"</span></span>,
                "<span class="attribute">like</span>": <span class="value"><span class="string">"0"</span>
            </span>},
            {
                "<span class="attribute">album</span>": <span class="value"><span class="string">"/subject/1947603/"</span></span>,
                "<span class="attribute">picture</span>": <span class="value"><span class="string">"http://img3.douban.com/lpic/s4458282.jpg"</span></span>,
                "<span class="attribute">ssid</span>": <span class="value"><span class="string">"b80e"</span></span>,
                "<span class="attribute">artist</span>": <span class="value"><span class="string">"Pompeii"</span></span>,
                "<span class="attribute">url</span>": <span class="value"><span class="string">"http://mr3.douban.com/201406201304/f8ea9c7ba0793030c8c486152d51527e/view/song/small/p2087210.mp3"</span></span>,
                "<span class="attribute">company</span>": <span class="value"><span class="string">"Warner"</span></span>,
                "<span class="attribute">title</span>": <span class="value"><span class="string">"Ten Hundred Lights"</span></span>,
                "<span class="attribute">rating_avg</span>": <span class="value"><span class="number">3.81894</span></span>,
                "<span class="attribute">length</span>": <span class="value"><span class="number">255</span></span>,
                "<span class="attribute">subtype</span>": <span class="value"><span class="string">""</span></span>,
                "<span class="attribute">public_time</span>": <span class="value"><span class="string">"2006"</span></span>,
                "<span class="attribute">songlists_count</span>": <span class="value"><span class="number">0</span></span>,
                "<span class="attribute">sid</span>": <span class="value"><span class="string">"2087210"</span></span>,
                "<span class="attribute">aid</span>": <span class="value"><span class="string">"1947603"</span></span>,
                "<span class="attribute">sha256</span>": <span class="value"><span class="string">"761fb793fd0571663c469a10bf9fc3bf0e2e3b329ecc5dddad8a2d28fd7ac0c7"</span></span>,
                "<span class="attribute">kbps</span>": <span class="value"><span class="string">"64"</span></span>,
                "<span class="attribute">albumtitle</span>": <span class="value"><span class="string">"Assembly"</span></span>,
                "<span class="attribute">like</span>": <span class="value"><span class="string">"0"</span>
            </span>}
        ]
    </span>} 
</code></pre><p>了解了格式，就能够依据格式，提取出我们需要的信息。在ViewController中，添加：</p>
<pre><code><span class="comment">/// 歌曲列表</span>
    <span class="keyword">var</span> songs = NSArray()
</code></pre><p>songs用来，保存歌曲。</p>
<p>更新didReceiveResults方法，</p>
<pre><code><span class="comment">// MARK: - HttpProtocol Method</span>
    <span class="comment">/**
        负责处理从网络上获取的数据

    :param: results 获取得到的数据
    */</span>
    <span class="func"><span class="keyword">func</span></span> didReceiveResults(results : <span class="type">NSDictionary</span>){
        <span class="built_in">println</span>(<span class="string">"数据成功接收"</span>)
<span class="comment">//        println(results)</span>
        <span class="keyword">self</span>.songs = results[<span class="string">"song"</span>] <span class="keyword">as</span>! <span class="type">NSArray</span>

        <span class="keyword">let</span> song0 = <span class="keyword">self</span>.songs[<span class="number">0</span>] <span class="keyword">as</span>! <span class="type">NSDictionary</span>

        <span class="keyword">let</span> songURL = song0[<span class="string">"url"</span>] <span class="keyword">as</span>! <span class="type">String</span>
        <span class="built_in">println</span>(<span class="string">"song URL: <span class="subst">\(songURL)</span>"</span>)

        <span class="comment">//更新界面UI的操作，放在主线程，提高反应速度</span>
        dispatch_async(dispatch_get_main_queue(), {
            () -&gt;<span class="type">Void</span> <span class="keyword">in</span>
            <span class="keyword">self</span>.circularProgressView.stop()
            <span class="keyword">self</span>.circularProgressView.audioURL = <span class="type">NSURL</span>(string: songURL)
            <span class="keyword">self</span>.circularProgressView.play()

            <span class="keyword">let</span> imageUrl = song0[<span class="string">"picture"</span>] <span class="keyword">as</span>! <span class="type">String</span>
            <span class="keyword">self</span>.onSetImage(imageUrl)
            <span class="type">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class="built_in">false</span>

        })

    }
</code></pre><p>onSetImage方法的代码如下：</p>
<pre><code><span class="javadoc">/**
        处理图片，调用ImageLoader单例进行图片缓存。

    :param: url
    */</span>
    func onSetImage(url : String){

        ImageLoader.sharedLoader.imageForUrl(url, completionHandler:{(image: UIImage?, url: String) in
            self.imageView.image = image
        })

    }
</code></pre><p>ImageLoader实现图片缓存，采用单例模式，下面看其实现代码：</p>
<pre><code><span class="comment">//</span>
<span class="comment">//  ImageLoader.swift</span>
<span class="comment">//  ZHEmotionMusic</span>
<span class="comment">//</span>
<span class="comment">//  Created by 钟桓 on 15/5/26.</span>
<span class="comment">//  Copyright (c) 2015年 ZH. All rights reserved.</span>
<span class="comment">//</span>


<span class="keyword">import</span> UIKit

class ImageLoader {

    <span class="built_in">var</span> <span class="keyword">cache</span> <span class="subst">=</span> NSCache()

    class <span class="built_in">var</span> sharedLoader : ImageLoader {
        struct Static {
            static <span class="keyword">let</span> instance : ImageLoader <span class="subst">=</span> ImageLoader()
        }
        <span class="keyword">return</span> Static<span class="built_in">.</span>instance
    }

    func imageForUrl(urlString: <span class="built_in">String</span>, completionHandler:(image: UIImage<span class="subst">?</span>, url: <span class="built_in">String</span>) <span class="subst">-&gt; </span>()) {


        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>), {()<span class="keyword">in</span>
            <span class="built_in">var</span> <span class="built_in">data</span>: NSData<span class="subst">?</span> <span class="subst">=</span> <span class="built_in">self</span><span class="built_in">.</span><span class="keyword">cache</span><span class="built_in">.</span>objectForKey(urlString) as<span class="subst">?</span> NSData

            <span class="keyword">if</span> <span class="keyword">let</span> goodData <span class="subst">=</span> <span class="built_in">data</span> {
                <span class="keyword">let</span> image <span class="subst">=</span> UIImage(<span class="built_in">data</span>: goodData)
                dispatch_async(dispatch_get_main_queue(), {() <span class="keyword">in</span>
                    completionHandler(image: image, url: urlString)
                })
                <span class="keyword">return</span>
            }

            <span class="built_in">var</span> downloadTask: NSURLSessionDataTask <span class="subst">=</span> NSURLSession<span class="built_in">.</span>sharedSession()<span class="built_in">.</span>dataTaskWithURL(NSURL(<span class="built_in">string</span>: urlString)<span class="subst">!</span>, completionHandler: {(<span class="built_in">data</span>: NSData<span class="subst">!</span>, response: NSURLResponse<span class="subst">!</span>, error: NSError<span class="subst">!</span>) <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span>
                <span class="keyword">if</span> (error <span class="subst">!=</span> nil) {
                    completionHandler(image: nil, url: urlString)
                    <span class="keyword">return</span>
                }

                <span class="keyword">if</span> <span class="built_in">data</span> <span class="subst">!=</span> nil {
                    <span class="keyword">let</span> image <span class="subst">=</span> UIImage(<span class="built_in">data</span>: <span class="built_in">data</span>)
                    <span class="built_in">self</span><span class="built_in">.</span><span class="keyword">cache</span><span class="built_in">.</span>setObject(<span class="built_in">data</span>, forKey: urlString)
                    dispatch_async(dispatch_get_main_queue(), {() <span class="keyword">in</span>
                        completionHandler(image: image, url: urlString)
                    })
                    <span class="keyword">return</span>
                }

            })
            downloadTask<span class="built_in">.</span>resume()
        })

    }
}
</code></pre><p>现在运行程序，每次扫描人脸后，都会有新的歌曲进行播放。但你会发现，每当一首歌曲播放完毕，程序停滞，没有行动。因为我们没有对歌曲播放完后改采取的行动进行编写。在ViewController中添加下面三个方法：</p>
<pre><code><span class="comment">// MARK: - CircularProgressViewDelegate Method</span>

<span class="comment">//    - (void)updateProgressViewWithPlayer:(AVAudioPlayer *)player;</span>
<span class="comment">//    - (void)updatePlayOrPauseButton;</span>
<span class="comment">//    - (void)playerDidFinishPlaying;</span>

    <span class="javadoc">/**
        歌曲暂停时调用
    */</span>
    func updatePlayOrPauseButton() {

    }

    <span class="javadoc">/**
        可以使用该方法，通过player的信息，对view进行更新。

    :param: player 播放器
    */</span>
    func updateProgressViewWithPlayer(player: MPMoviePlayerController!) {

    }

    <span class="javadoc">/**
        每当播放结束时调用
    */</span>
    func playerDidFinishPlaying() {

    }
</code></pre><p>聪明的你，注意到了MARK标志，它等价于objective-c的 #pragma。</p>
<p>对第三个方法，也就是playerDidFinishPlaying()进行编程实现。首先，在viewController中添加变量。</p>
<pre><code> <span class="comment">/// 记录当前播放歌曲在songs内的位置。</span>
    <span class="keyword">var</span> id = <span class="number">0</span>;
</code></pre><p>在didReceiveResults中，添加一行。</p>
<pre><code><span class="attribute">         self.id </span>=<span class="string"> 0;</span>
</code></pre><p>给playerDidFinishPlaying添加处理逻辑。</p>
<pre><code>     <span class="comment">/**
        每当播放结束时调用
    */</span>
    <span class="func"><span class="keyword">func</span></span> playerDidFinishPlaying() {

        <span class="keyword">self</span>.id+=<span class="number">1</span>;
        <span class="built_in">println</span>(<span class="keyword">self</span>.id)

        <span class="comment">//放在主线程，提高反应速度</span>
        dispatch_async(dispatch_get_main_queue(), {
            () -&gt;<span class="type">Void</span> <span class="keyword">in</span>
            <span class="type">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class="built_in">true</span>
            <span class="keyword">let</span> song = <span class="keyword">self</span>.songs[<span class="keyword">self</span>.id] <span class="keyword">as</span>! <span class="type">NSDictionary</span>
            <span class="keyword">let</span> songURL = song[<span class="string">"url"</span>] <span class="keyword">as</span>! <span class="type">String</span>
            <span class="keyword">self</span>.circularProgressView.stop()
            <span class="keyword">self</span>.circularProgressView.audioURL = <span class="type">NSURL</span>(string: songURL)
            <span class="keyword">self</span>.circularProgressView.play()
            <span class="keyword">let</span> imageUrl = song[<span class="string">"picture"</span>] <span class="keyword">as</span>! <span class="type">String</span>
            <span class="keyword">self</span>.onSetImage(imageUrl)
            <span class="type">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class="built_in">false</span>

        })

    }
</code></pre><p>到这里，扫描面部后，能够放歌，并且当歌曲结束后，会自动切换歌曲。</p>
<p>但现在我们不知道，播放的歌曲是歌名和演唱者，所以，现在来添加这部分的操作代码。在viewController中添加：</p>
<pre><code>    <span class="comment">/**
     负责更新歌曲

    :param: song 需要更新的歌曲信息
    */</span>

     func updateSong(song : NSDictionary){
            //<span class="operator"><span class="keyword">update</span> audio player
            let songURL =  song[<span class="string">"url"</span>] <span class="keyword">as</span>! <span class="keyword">String</span>
            self.circularProgressView.<span class="keyword">stop</span>()
            self.circularProgressView.audioURL = NSURL(<span class="keyword">string</span>: songURL)
            self.circularProgressView.play()

            //<span class="keyword">update</span> image <span class="keyword">view</span>
            let imageUrl = song[<span class="string">"picture"</span>] <span class="keyword">as</span>! <span class="keyword">String</span>
            self.onSetImage(imageUrl)

            //<span class="keyword">update</span> song title <span class="comment">--&gt; label1</span>
            label1.<span class="built_in">text</span> = song[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="keyword">String</span>

            //<span class="keyword">update</span> artist  <span class="comment">--&gt; label2</span>
            label2.<span class="built_in">text</span> = song[<span class="string">"artist"</span>] <span class="keyword">as</span>? <span class="keyword">String</span>
            label2.font = label2.font.fontWithSize(<span class="number">13</span>)


            UIApplication.sharedApplication().networkActivityIndicatorVisible = <span class="literal">false</span>
        }</span>
</code></pre><p>将更新歌曲的操作封装在这个函数中，所以，修改didReceiveResults方法。</p>
<pre><code>     <span class="comment">/**
        负责处理从网络上获取的数据

    :param: results 获取得到的数据
    */</span>
    <span class="func"><span class="keyword">func</span></span> didReceiveResults(results : <span class="type">NSDictionary</span>){
        <span class="built_in">println</span>(<span class="string">"数据成功接收"</span>)
<span class="comment">//        println(results)</span>
        <span class="keyword">self</span>.songs = results[<span class="string">"song"</span>] <span class="keyword">as</span>! <span class="type">NSArray</span>

        <span class="keyword">let</span> song = <span class="keyword">self</span>.songs[<span class="number">0</span>] <span class="keyword">as</span>! <span class="type">NSDictionary</span>


        <span class="keyword">self</span>.id = <span class="number">0</span>;

        <span class="comment">//更新界面UI的操作，放在主线程，提高反应速度</span>
        dispatch_async(dispatch_get_main_queue(), {
            () -&gt;<span class="type">Void</span> <span class="keyword">in</span>

            <span class="keyword">self</span>.updateSong(song)

        })

    }
</code></pre><p>同时不要忘记修改其它地方，将切换歌曲或者播放歌曲，都放在updateSong中，修改playerDidFinishPlaying。</p>
<pre><code>     <span class="comment">/**
        每当播放结束时调用
    */</span>
    <span class="func"><span class="keyword">func</span></span> playerDidFinishPlaying() {

        <span class="keyword">self</span>.id+=<span class="number">1</span>;
        <span class="built_in">println</span>(<span class="keyword">self</span>.id)

        <span class="comment">//放在主线程，提高反应速度</span>
        dispatch_async(dispatch_get_main_queue(), {
            () -&gt;<span class="type">Void</span> <span class="keyword">in</span>
            <span class="type">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class="built_in">true</span>
            <span class="keyword">let</span> song = <span class="keyword">self</span>.songs[<span class="keyword">self</span>.id] <span class="keyword">as</span>! <span class="type">NSDictionary</span>
            <span class="comment">//update song</span>
            <span class="keyword">self</span>.updateSong(song)
        })

    }
</code></pre><p>到现在，似乎完成的很不错了,但是有一个bug，可能你早有迷惑，我们扫描心情只是一次，提取的歌曲数量也是有限，如果歌曲列表songs中的歌曲都播放完毕了，怎么办? 如果不做处理，程序会crash。所以，需要在每次歌曲播放结束后，进行判断。</p>
<p>在ViewController中，添加一个枚举类型。</p>
<pre><code><span class="javadoc">/**
    枚举类型，记录心情

- happy: 快乐的心情
- sad:   悲伤的心情
*/</span>
<span class="keyword">enum</span> Emotion{
    <span class="keyword">case</span> happy
    <span class="keyword">case</span> sad
}
</code></pre><p>在Viewcontroller类中，添加属性：</p>
<pre><code> <span class="comment">/// 当前的心情</span>
 <span class="keyword">var</span> emotion : Emotion = Emotion.happy
</code></pre><p>更新歌曲播放结束后的处理方法playerDidFinishPlaying。</p>
<pre><code>     <span class="comment">/**
        每当播放结束时调用
    */</span>
    <span class="func"><span class="keyword">func</span></span> playerDidFinishPlaying() {

        <span class="keyword">self</span>.id+=<span class="number">1</span>;
<span class="comment">//        println(self.id)</span>

        <span class="comment">//如果最后一首歌曲播放完毕，需要再次访问网络，获取资源</span>
        <span class="keyword">if</span> <span class="keyword">self</span>.id == songs.<span class="built_in">count</span> {
            <span class="keyword">switch</span> emotion{
            <span class="keyword">case</span> .happy :
                http.onSearch(happySongsURL)
            <span class="keyword">case</span> .sad :
                http.onSearch(sadSongsURL)
            }
<span class="comment">//            println("songs is over")</span>
            <span class="keyword">self</span>.id=<span class="number">0</span>
        }

        <span class="comment">//放在主线程，提高反应速度</span>
        dispatch_async(dispatch_get_main_queue(), {
            () -&gt;<span class="type">Void</span> <span class="keyword">in</span>
            <span class="type">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class="built_in">true</span>
            <span class="keyword">let</span> song = <span class="keyword">self</span>.songs[<span class="keyword">self</span>.id] <span class="keyword">as</span>! <span class="type">NSDictionary</span>
            <span class="comment">//update song</span>
            <span class="keyword">self</span>.updateSong(song)
        })

    }
</code></pre><hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一快两块的，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
      <category term="小贼音乐" scheme="http://zhonghuan.info/categories/Swift/%E5%B0%8F%E8%B4%BC%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[小贼音乐--swift开发笔记_step_1]]></title>
    <link href="http://zhonghuan.info/2015/05/30/%E5%B0%8F%E8%B4%BC%E9%9F%B3%E4%B9%90-swift%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-step-1/"/>
    <id>http://zhonghuan.info/2015/05/30/小贼音乐-swift开发笔记-step-1/</id>
    <published>2015-05-29T18:04:05.000Z</published>
    <updated>2015-05-29T18:18:06.000Z</updated>
    <content type="html"><![CDATA[<p>小贼音乐的最终效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/zhEmotionMusicInfo.gif" alt=""></p>
<p>代码开源在我的github上，喜欢请点个赞。<a href="https://github.com/ZHONGHuanGit/ZHEmotionMusic" target="_blank" rel="external">https://github.com/ZHONGHuanGit/ZHEmotionMusic</a></p>
<hr>
<p>本篇博文希望达到的效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/ZHEmotionMusic_Step1.gif" alt=""></p>
<hr>
<h3 id="开头先说说别的">开头先说说别的</h3>
<p>先说说，为什么要开发这个吧。因为在前段时间，看到了一个很有趣的APP—-emo。是emotion的简写。没有下载的朋友，可以尝试下载一下。emo的特点就是，使用表情识别，推断当前用户的心情，进而给用户推送音乐。用了几次，觉得推送的音乐挺不错的。</p>
<hr>
<h3 id="创建swift项目">创建swift项目</h3>
<p>创建一个swift项目，这个就不详述了，项目名称可以自定义，不过下面的过程，假定项目名称为ZHEmotionMusic。在开始项目前，可以给Xcode添加一个插件，<a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter-Xcode</a>，功能为给方法添加注释，从现在起多写写注释，不仅仅是方便他人的阅读，也是方便自己以后的回顾。</p>
<hr>
<h3 id="接入一登SDK">接入一登SDK</h3>
<p>首先了解一登，开发的APP有一个过程，是人脸识别。而<a href="http://superid.me" target="_blank" rel="external">一登</a>,看官网主要上的描述，主要侧重点在刷脸登陆，但其SDK依旧提供人脸表情识别的功能。（但有一个坑，大家后面也会发现，一登如果要识别人脸表情，需要高级功能，要申请高级功能还得和一登工作人员商量。没办法，一开始没仔细看，不过其实大致的接口是类似。再说一下，国内的face++的识别效果，应该会比一登好，但是一登会比较适合这个音乐app，毕竟emo也是用一登）</p>
<p>因为不能直接获得人脸的表情状态，但毕竟是为了学习，可以变通一下，一登的基本权限，可以获得人脸的微笑程度，现在我们把众多的表情，分成两个。1）开心  2）不开心。（就当随意练手吧，不要在意这些）</p>
<p>现在我们集成SDK，分为几个步骤。</p>
<ol>
<li><p>在<a href="http://superid.me" target="_blank" rel="external">官网首页</a>点击【注册】完成一登开发者注册。</p>
</li>
<li><p>在一登开发者中心，创建一个新应用。应用名称可以直接填项目名称，应用类型为影音图像；下载地址和Apple ID可以忽略。注意bundle得和XCode中项目的Bundle Identifier一致。如下图：</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/image1.png" alt=""></p>
<p>创建好应用后，注意应用中基本信息中含有APP ID 和 APP Secret，在开发过程中会使用。</p>
<ol>
<li><p>到一登SDK的<a href="https://github.com/SuperID/SuperID_iOSSDK" target="_blank" rel="external">Github</a>上，下载SDK，可以clone，也可以直接下载zip文件。</p>
</li>
<li><p>在一登 GitHub 下载一登 iOS SDK。将 SDK 包中的文件添加至本地工程，其中包括：SuperIDSDKSettings.bundle、 libSuperIDSDK.a、SIDFaceFeatureViewController.h、SuperID.h,SuperIDDelegate.h 共5个文件。为了更好的管理文档，注意记得把这五个文档归为一个Group中。</p>
</li>
</ol>
<p><img src="http://superid.me/document/iOS_images/iOSDemo_file.png" alt=""></p>
<ol>
<li>在工程引入静态库之后”需要在编译时添加 -ObjC 和 -lstdc++ 编译选项。方法：xcodeproj-&gt;Build Settings-&gt;Linking-&gt;Other Linker Flags,在 Other Linker Flags 选项中，双击该选项，点击弹出框左下角的 + 按钮，分别添加 “-ObjC” 字符和 “-lstdc++” 字符（如下图）。</li>
</ol>
<p><img src="http://superid.me/document/iOS_images/iOSDemo_flag.png" alt=""></p>
<ol>
<li>添加依赖库,</li>
</ol>
<p>如果你的应用无法正常通过编译，请添加SDK所需的依赖库。主要为：</p>
<ul>
<li><p>CoreTelephony.framework</p>
</li>
<li><p>CoreMedia.framework</p>
</li>
<li><p>AVFoundation.framework</p>
</li>
<li><p>libc++.dylib</p>
</li>
</ul>
<p>添加路径为：工程-&gt;Build Phases-&gt;Link Binary With Libraries-&gt;Add-&gt;选择上述的依赖库。</p>
<hr>
<h3 id="SDK初始化">SDK初始化</h3>
<p>注意，我们的项目使用的是Swift语言，但是一登SDK是用objective-c编写的。你可能会焦急，这个怎么办？ 不用担心，Apple公司允许开发人员，在Swift中调用objective-c，需要进行桥接。怎么做呢？看下面的步骤。</p>
<p>按command+n 创建一个新文件，选择IOS—&gt;Source—&gt;Cocoa Touch Class,随意输入类名，例如OC<br>Object,注意选择语言为objective-c。当你在Swift项目中创建一个object-c文件时候，XCode会自动提示你，创建  项目名称-Bridging-Header.h 文件（这里是 ZHEmotionMusic-Bridging-Header.h），这个文件起桥接作用，你可以在上面引入你需要调用的objective-c头文件，方式和普通的objective-c引入头文件类似，例如，在项目中会使用到 SuperID.h 。所以在里面添加：</p>
<pre><code>    #<span class="keyword">import</span> <span class="string">"SuperID.h"</span>
</code></pre><p>声明完后，就可以在项目中使用一登SDK了，不过注意的是，在项目中，我们是使用Swift代码进行编写，即使调用objective-c的类，也是使用Swift方式调用，XCode会帮你转换，这个不用我们担心。</p>
<h4 id="填写一登APPID和APPSecret">填写一登APPID和APPSecret</h4>
<p>在SDK文档中有介绍，调用的借口为</p>
<pre><code><span class="pp">- <span class="params">(void)</span>registerAppWithAppID:<span class="params">(<span class="variable">NSString</span> *)</span>appID withAppSecret:<span class="params">(<span class="variable">NSString</span> *)</span>appSecret;</span>
</code></pre><p>具体的代码为：</p>
<pre><code>    - (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions {

        [[SuperID sharedInstance]registerAppWithAppID:<span class="string">@"应用的AppID"</span> withAppSecret:<span class="string">@"应用的AppSecret"</span>];

        <span class="keyword">return</span> <span class="literal">YES</span>;
    }
</code></pre><p>在我们的项目中，使用Swift编写代码如下：</p>
<pre><code>    <span class="func"><span class="keyword">func</span></span> application(application: <span class="type">UIApplication</span>, didFinishLaunchingWithOptions launchOptions: [<span class="type">NSObject</span>: <span class="type">AnyObject</span>]?) -&gt; <span class="type">Bool</span> {
            <span class="comment">// Override point for customization after application launch.</span>


            <span class="comment">//在代码中向一登 SDK 注册你的 AppID 和 AppSecret</span>
            <span class="type">SuperID</span>.sharedInstance().registerAppWithAppID(<span class="string">"LDYEYQoR6lnpA2mehpZVzvzK"</span>, withAppSecret: <span class="string">"sETEcYSE1g5OYnmLwSybGheY"</span>)

            <span class="comment">//设置SDK语言模式为简体中文</span>
            <span class="type">SuperID</span>.setLanguageMode(<span class="type">SIDLanguageMode</span>.<span class="type">SimplifiedChineseMode</span>)

            <span class="comment">//设置SDK调试模式，应用发布时，注意需要关闭</span>
            <span class="type">SuperID</span>.setDebugMode(<span class="built_in">true</span>);

            <span class="keyword">return</span> <span class="built_in">true</span>
        }
</code></pre><p>至此，一登SDK接入完毕，下面看如何调用其人脸识别的功能。</p>
<hr>
<h3 id="调用一登SDK获得人脸属性。">调用一登SDK获得人脸属性。</h3>
<p>在您调用 SIDEmotionViewController(具有人脸识别的View Controller) 的当前 View Controller 中，您需要设置当前 View Controller 作为 SDK 的协议委托对象，并在当前 VC 中声明继承一登 SDK 的Protocol（SuperIDDelegate）并声明 SDK 单例对象，具体代码如下所示。</p>
<pre><code>    <span class="comment">//先让当前ViewController 实现 SuperIDDelegate 协议</span>
    <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> , <span class="title">SuperIDDelegate</span> </span>
</code></pre><p>然后重载viewWillAppear方法。</p>
<pre><code>     <span class="javadoc">/**
        Description
            View将出现时，所做的操作，这里添加了SDK的委托声明
        :param: animated
        */</span>
        <span class="keyword">override</span> func viewWillAppear(animated: Bool) {
            <span class="keyword">super</span>.viewWillAppear(animated)

            superIdSdk = SuperID.sharedInstance() <span class="comment">// 获取SDK单例</span>
            superIdSdk?.delegate = self <span class="comment">//设置委托对象</span>
        }
</code></pre><p>然后，在storyboard中，首先选中当前的ViewController，然后在Utilities中的Attributes Inspector中，调整size为iphone4-inch(个人喜好，不喜欢方形的)，然后，添加一个button，放在当前View Controller 中间，然后选中button，按control键，连接button至ViewController中，选择Connection为Action，命名为getFaceFeature。现在的目的是，测试一登的SDK,我们希望，点击button，能够调用用于完成人脸属性检测的ViewController，代码如下：</p>
<pre><code>    <span class="preprocessor">@IBAction</span> fun getFaceFeature(sender: <span class="type">AnyObject</span>) {
            <span class="comment">//getAuthorityOfCamera()</span>

            <span class="keyword">var</span> error : <span class="type">NSError</span>? = <span class="built_in">nil</span>;

            <span class="keyword">var</span> <span class="type">SIDEmotionViewController</span>  = superIdSdk!.obtainFaceFeatureViewControllerWithError(&amp;error) <span class="keyword">as</span>? <span class="type">UIViewController</span>;

            <span class="keyword">if</span> <span class="keyword">let</span> <span class="type">SEV</span> = <span class="type">SIDEmotionViewController</span>{
                <span class="comment">//采用present的方式弹出人脸情绪的功能：</span>
                <span class="keyword">self</span>.presentViewController(<span class="type">SIDEmotionViewController</span>!, animated: <span class="built_in">true</span>, completion: <span class="built_in">nil</span>)

            }
            <span class="keyword">else</span>{
                <span class="built_in">println</span>(<span class="string">"<span class="subst">\(error?.code)</span>     <span class="subst">\(error?.description)</span>"</span>)
            }

        }
</code></pre><p>按Command+B，若无错误，则说明上面的步骤正确。可能会有一些警告信息，可以忽略。</p>
<p>可以进行测试，注意，因为表情识别会用到，摄像头，可是IOS simulator不支持，所以，需要使用真机进行测试，这需要苹果开发者账号，如果没有，可以选在在淘宝上搜 “Xcode 真机测试”，可以允许你在mac上对一台iphone进行真机测试，具体怎么做，可以淘宝搜，店主会详细告诉你。</p>
<p>如果，你一切顺利，当点击按钮，会提示你，没有权限，下面我们需要写一段代码，让用户每次点击按钮，如果用户没有获得摄像头的权限，可以选择赋予摄像头权限，代码的逻辑很简单，就是先检查当前的权限的状态，然后根据状态进行判断。代码如下：</p>
<pre><code> <span class="javadoc">/**
    Description 
            调用该方法，获取调用相机权限
    */</span>
    func getAuthorityOfCamera(){
        <span class="keyword">var</span> status:AVAuthorizationStatus =  AVCaptureDevice.authorizationStatusForMediaType(AVMediaTypeVideo)


        <span class="keyword">if</span>(status == AVAuthorizationStatus.Authorized) { <span class="comment">// authorized</span>
            <span class="keyword">return</span>;
        }
        <span class="keyword">else</span> {

            AVCaptureDevice.requestAccessForMediaType(AVMediaTypeVideo, completionHandler: {
                (Bool granted) -&gt; Void in

                <span class="comment">//如果用户赋予了权限</span>
                <span class="keyword">if</span>(granted){

                }
                <span class="comment">//如果没有赋予权限</span>
                <span class="keyword">else</span>{

                }
            })
        }
    }
</code></pre><p>然后，注意将getFaceFeature中的一个注释去掉。</p>
<pre><code> <span class="function">getAuthorityOfCamera</span>()  <span class="comment">// 去掉注释。</span>
</code></pre><p>然后编译运行试试，会出现一个新的界面，界面使用了前置摄像头，你只需将脸对着前置摄像头，从而进行识别。</p>
<p>你会奇怪，识别完后，似乎什么事情都没有发生，这是因为，你并没有设定，识别完后做什么。其实。当一登用户在一登 SDK 完成人脸属性检测事件后，SDK 将执行协议中的相应方法，开发者可在对应的方法中进行根据需要相应事件处理。方法是superID，我们需要实现它。代码如下：</p>
<pre><code>     <span class="javadoc">/**
        Description
                用户在一登 SDK 完成人脸属性检测事件后，SDK 将执行协议中的方法，就是本方法，开发者可本方法中进行根据需要相应事件处理
        :param: sender       SuperID实例
        :param: featureInfo  检测的人脸信息
        :param: error        error == nil 则不发生错误； 否则发生错误。
        */</span>
        func superID(sender: SuperID!, userDidFinishGetFaceFeatureWithFeatureInfo featureInfo: [NSObject : AnyObject]!, error: NSError!) {
            <span class="keyword">if</span>(error == nil){
                println(<span class="string">"操作成功!"</span>)

                println(featureInfo)

            }
            <span class="keyword">else</span>{
                println(<span class="string">"操作失败!"</span>)

                println(<span class="string">"\(error.code)   \(error.description)"</span>)
            }
        }
</code></pre><p>当你再次运行，你会在All out中，发现，输出了一些内容。例如：</p>
<pre><code>    操作成功!
    [eyeglasses: {
        <span class="literal">result</span> = <span class="number">1</span>;
        score = <span class="string">"0.992422"</span>;
    }, male: {
        <span class="literal">result</span> = <span class="number">1</span>;
        score = <span class="string">"0.999256"</span>;
    }, sunglasses: {
        <span class="literal">result</span> = <span class="number">0</span>;
        score = <span class="string">"0.393262"</span>;
    }, smiling: {
        <span class="literal">result</span> = <span class="number">0</span>;
        score = <span class="string">"0.001676"</span>;
    }, age: <span class="number">25</span>.<span class="number">96</span>, resource_id: <span class="number">55620</span>c94de77d8ae668e1fc4, mustache: {
        <span class="literal">result</span> = <span class="number">1</span>;
        score = <span class="string">"0.518885"</span>;
    }]
</code></pre><p>好了，一登SDK暂且OK。下面让我们美化一下。</p>
<hr>
<h3 id="简单美化下">简单美化下</h3>
<pre><code>    顺便提一句，app_icon ，是用Sketch来设计制作的，请大家体谅一下，不是Sketch不好用，而是本人捉急的艺术功底。
</code></pre><p>先看 app_icon.png,这个拖至Images.xcassets的AppIcon中。</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/app_icon.png" alt=""></p>
<p>再添加几个图片，</p>
<p>basic.png</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/basic.png" alt=""></p>
<p>happy.png</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/happy.png" alt=""></p>
<p>sad.png</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/sad.png" alt=""></p>
<p>这些是后面步骤会使用到的图片。现在AppIcon已经有图片了，所以当你再次运行时，iphone手机上的图标就有了。现在我们改改图标下面显示的App名字。也很简单，就是打开Supporting Files—&gt;Info.plist文件，找到，Bundle name，修改为—&gt;小贼音乐。如图所示：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/image2.png" alt=""></p>
<p>打开Main.storyboard，删除原来的button，现在选择一个image View放到上面，设置大小为250*250，设置图片为basic， 再添加两个label，最后，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/image3.png" alt=""></p>
<p>上面的image view 和两个label都使用了auto layout布局，这个大家可以去了解一下，然后选择合适的方式将它们展示出来就可以了。</p>
<p>注意需要设定中间ImageView的layer.cornerRadius，不少人喜欢在代码中实现，但本人懒，不太喜欢用代码。但是，有无法直接在ImageView的属性中进行设定，推荐大家一种方式，使用User Defined Runtime Attributes，详情可看<a href="http://spin.atomicobject.com/2014/05/30/xcode-runtime-attributes/" target="_blank" rel="external">这里</a>。最终，如下图：</p>
<p><img src="https://raw.githubusercontent.com/ZHONGHuanGit/ZHEmotionMusic/master/开发笔记/images/image4.png" alt=""></p>
<p>按control，将image view和两个label都绑定到View Controller中。</p>
<pre><code>  <span class="comment">///ImageView实例</span>
    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!

    <span class="comment">///第一个Label标签</span>
    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label1: <span class="type">UILabel</span>!

    <span class="comment">/// 第二个Label标签</span>
    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label2: <span class="type">UILabel</span>!
</code></pre><p>在Main.storyboard中，给当前的view Controller 添加一个Long Press Gesture Recognizer，因为设定是长按屏幕，进行扫描人脸。如果不了解 Gesture recognizer，可以去了解一下，简单的说，就是手势识别，这个Long Press Gesture Recognizer是专门用来识别长按屏幕这个手势操作的，是苹果官方提供的手势识别，当然你也可以自己写自己的手势，不过我们暂时使用这个手势就足够了。</p>
<p>按control将手势连接至ViewController，选择Action，命名位longPressAction，大致内容和上面的getFaceFeature一样。</p>
<pre><code>     <span class="comment">/**
        Description
            处理用户长按屏幕的行动

        :param: sender
        */</span>
        <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span></span> longPressAction(sender: <span class="type">AnyObject</span>) {
            getAuthorityOfCamera()

            <span class="keyword">var</span> error : <span class="type">NSError</span>? = <span class="built_in">nil</span>;

            <span class="keyword">var</span> <span class="type">SIDEmotionViewController</span>  = superIdSdk!.obtainFaceFeatureViewControllerWithError(&amp;error) <span class="keyword">as</span>? <span class="type">UIViewController</span>;

            <span class="keyword">if</span> <span class="keyword">let</span> <span class="type">SEV</span> = <span class="type">SIDEmotionViewController</span>{
                <span class="comment">//采用present的方式弹出人脸情绪的功能：</span>
                <span class="keyword">self</span>.presentViewController(<span class="type">SIDEmotionViewController</span>!, animated: <span class="built_in">true</span>, completion: <span class="built_in">nil</span>)

            }
            <span class="keyword">else</span>{
                <span class="built_in">println</span>(<span class="string">"<span class="subst">\(error?.code)</span>     <span class="subst">\(error?.description)</span>"</span>)
            }

        }
</code></pre><p>但我们更新一下，实现的协议方法superID，</p>
<pre><code> /**
    <span class="type">Description</span>
            用户在一登 <span class="type">SDK</span> 完成人脸属性检测事件后，<span class="type">SDK</span> 将执行协议中的方法，就是本方法，开发者可本方法中进行根据需要相应事件处理
    :param: sender       <span class="type">SuperID</span>实例
    :param: featureInfo  检测的人脸信息
    :param: error        error == <span class="keyword">nil</span> 则不发生错误； 否则发生错误。
    */
    func superID(sender: <span class="type">SuperID</span>!, userDidFinishGetFaceFeatureWithFeatureInfo featureInfo: [<span class="type">NSObject</span> : <span class="type">AnyObject</span>]!, error: <span class="type">NSError</span>!) {
        <span class="keyword">if</span>(error == <span class="keyword">nil</span>){
            println(<span class="string">"操作成功!"</span>)

            println(featureInfo)
//            <span class="keyword">var</span> info = featureInfo!

            //因为featureInfo和其内部的数据，都是optional类型，需要 unwrap
            <span class="keyword">if</span> <span class="keyword">let</span> info = featureInfo {
                <span class="keyword">var</span> smileResult = info[<span class="string">"smiling"</span>]!
                <span class="keyword">var</span> <span class="literal">result</span> = smileResult[<span class="string">"result"</span>] <span class="keyword">as</span>! <span class="type">Int</span>
                <span class="keyword">var</span> score = smileResult[<span class="string">"score"</span>] <span class="keyword">as</span>! <span class="type">Double</span>
                println(score)
                <span class="keyword">if</span> <span class="literal">result</span> == <span class="number">1</span> {
                    imageView.image = <span class="type">UIImage</span>(named: <span class="string">"happy"</span>)
                    label1.text = <span class="string">"诶哟！"</span>
                    label2.text = <span class="string">"今天心情不错哦！"</span>
                }<span class="keyword">else</span>{
                    imageView.image = <span class="type">UIImage</span>(named: <span class="string">"sad"</span>)
                    label1.text = <span class="string">"唉！一言以蔽之"</span>
                    label2.text = <span class="string">"心好涩"</span>
                }
            }

        }
        <span class="keyword">else</span>{
            println(<span class="string">"操作失败!"</span>)

            println(<span class="string">"\(error.code)   \(error.description)"</span>)
        }
    }
</code></pre><p>最后一个步骤，让我们修改一下Launch image，查看  项目—&gt; General —&gt; App Icons and Launch Images —&gt; Launch screen file。 默认的Launch image是LaunchScreen.xib，这个在项目创建时自动生成的，在这里，我们选择Main.storyboard作为Launch image。 </p>
<p>可以尝试运行，测试一下结果如何。第一步，暂时到此结束。</p>
<hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一快两块的，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
      <category term="小贼音乐" scheme="http://zhonghuan.info/categories/Swift/%E5%B0%8F%E8%B4%BC%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIImage添加Gesture Recognizer]]></title>
    <link href="http://zhonghuan.info/2015/04/16/UIImage%E6%B7%BB%E5%8A%A0Gesture-Recognizer/"/>
    <id>http://zhonghuan.info/2015/04/16/UIImage添加Gesture-Recognizer/</id>
    <published>2015-04-16T02:00:03.000Z</published>
    <updated>2015-04-16T02:01:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="UIImage添加Gesture_Recognizer">UIImage添加Gesture Recognizer</h1>
<hr>
<p>默认的，UIImage不响应任何touch，例如tab。但是你可以设定它允许响应，有两种方式。</p>
<ol>
<li>通过Attribute Inspector</li>
<li>通过code</li>
</ol>
<hr>
<h4 id="Attribute_Inspector">Attribute Inspector</h4>
<p>在Main.storyboard中，选中imageView，然后打开相应的Attribute Inspector，在Interaction中选中User Interaction Enabled。</p>
<p><img src="http://zhonghuan.qiniudn.com/UIImageEnableUITapGestureRecognizer.png" alt=""></p>
<hr>
<h4 id="Code">Code</h4>
<p>在代码中，加入：</p>
<pre><code>    <span class="keyword">self</span>.imageView.userInteractionEnabled = <span class="keyword">true</span>
</code></pre><hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift学习笔记NSCache]]></title>
    <link href="http://zhonghuan.info/2015/04/15/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0NSCache/"/>
    <id>http://zhonghuan.info/2015/04/15/Swift学习笔记NSCache/</id>
    <published>2015-04-15T05:47:38.000Z</published>
    <updated>2015-08-05T04:24:41.000Z</updated>
    <content type="html"><![CDATA[<h5 id="开头闲聊">开头闲聊</h5>
<p>从名字上可以感觉出来，Cache，缓存。我们都知道，有时候一些计算量比较大的结果，我们可以缓存起来，下次使用时，可以直接使用，不用重复计算。</p>
<p>简单的例子来说吧。例如我们有一些图片需要使用，这些图片资源是从网络上获取来的。我们直观上的感觉就是不用每次使用图片都从网络上去获取，可以将得到的图片缓存起来，需要使用的时候，我们可以直接拿来用。</p>
<p>如果没有NSCache，你会怎么做，我的第一反应是 ———&gt; <strong>Dictionary，字典</strong>。</p>
<hr>
<h3 id="字典的实现">字典的实现</h3>
<p>字典，有 <strong> key—value 键-值对</strong>，所以通过url(String)—image这样的组合，我们可以实现一个简单的缓存。例如：(Xcode6，Swift1.2)</p>
<pre><code>var <span class="variable">imageCache =</span> Dictionary &lt; String , UIImage &gt;()

<span class="keyword">let</span> <span class="variable">url =</span> <span class="string">"图片的URL"</span>

<span class="keyword">let</span> <span class="variable">image =</span> imageCache[url]

<span class="keyword">if</span> <span class="variable">image =</span>= nil { 

    // 如果imageCache中没有该url对应的图片，则访问url，获取图片，放在imageCache中

    <span class="keyword">let</span> <span class="variable">request =</span> NSURLRequest(URL : NSURL(string : url!)!)

        <span class="keyword">let</span> <span class="variable">session =</span> NSURLSession.sharedSession()

        <span class="keyword">let</span> <span class="variable">task =</span> session.dataTaskWithRequest(request){
            (data,response,error) -&gt; Void <span class="keyword">in</span>
            <span class="keyword">if</span>(<span class="variable">error =</span>= nil){
                <span class="keyword">let</span> <span class="variable">image =</span> UIImage(data: data)

                //放入imageCache中
                self.imageCache[url!] = image

                    //可以使用图片

            }
        }

        task.resume()

}<span class="keyword">else</span>{
    // 如果imageCache中已经有了图片，则可以直接使用。

} 
</code></pre><hr>
<h3 id="使用NSCache">使用NSCache</h3>
<p>上面的实现，似乎已经可以满足要求了，可是，有一个问题，如果图片资源过多，程序运行时占据太多存储资源。我们希望，如果图片长时间不用的话，可以释放它，等需要用时，在从网络中获取。在时间和空间中，取一个权衡。</p>
<p>那么好了，NSCache可以帮我们做到这一点。它就像一个容器一样，内部存储的也是key-value 对，它类似Dictionary，但不同的是，当空间比较紧张的时候，NSCache可以释放一部分资源。正因为需要释放资源，NSCache存储的对象需要实现 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSDiscardableContent_Protocol/index.html#//apple_ref/occ/intf/NSDiscardableContent" target="_blank" rel="external">NSDiscardableContent</a> 协议。</p>
<p>可以参照ios developer library <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/index.html#//apple_ref/occ/instp/NSCache/evictsObjectsWithDiscardedContent" target="_blank" rel="external">NSCache</a>，来看看它的使用方式。</p>
<p>下面看一个，取代上面图片缓存的例子：（环境 Xcode 7， Swift 2）</p>
<pre><code>    <span class="reserved">import</span> UIKit

<span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> {</span>

    <span class="reserved">var</span> cache = NSCache()

    static <span class="reserved">let</span> shareInstance : ImageLoader = ImageLoader()

    func imageForUrl<span class="function"><span class="params">(urlString: String, completionHandler:(image: UIImage?, url: String) -&gt; Void)</span> {

        <span class="title">dispatch_async</span><span class="params">(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>), {
            () -&gt; Void <span class="keyword">in</span>

            <span class="reserved">let</span> cachedata: NSData? = self.cache.objectForKey(urlString) as? NSData

            <span class="keyword">if</span> <span class="reserved">let</span> goodData = cachedata {
                <span class="reserved">let</span> image = UIImage(data: goodData)
                dispatch_async(dispatch_get_main_queue(), {() <span class="keyword">in</span>
                    completionHandler(image: image, url: urlString)
                })
                <span class="keyword">return</span>
            }

            <span class="reserved">let</span> session  = NSURLSession.sharedSession()
            <span class="reserved">let</span> url = NSURL(string: urlString)
            <span class="reserved">let</span> downloadTask = session.dataTaskWithURL(url!, completionHandler: {
                (data : NSData?, response : NSURLResponse?, error : NSError?) -&gt; Void <span class="keyword">in</span>

                <span class="keyword">if</span> (error != nil) {
                    completionHandler(image: nil, url: urlString)
                    <span class="keyword">return</span>
                }

                <span class="keyword">if</span> data != nil {
                    <span class="reserved">let</span> image = UIImage(data: data!)
                    self.cache.setObject(data!, forKey: urlString)
                    dispatch_async(dispatch_get_main_queue(), {() <span class="keyword">in</span>
                        completionHandler(image: image, url: urlString)
                    })
                    <span class="keyword">return</span>
                }

            })

            downloadTask.resume()
        })</span>

    }
}</span>
</code></pre><hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/index.html#//apple_ref/occ/instp/NSCache/evictsObjectsWithDiscardedContent" target="_blank" rel="external">NSCache in IOS Developer Library</a></p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift网络编程]]></title>
    <link href="http://zhonghuan.info/2015/04/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhonghuan.info/2015/04/10/网络编程/</id>
    <published>2015-04-10T06:37:56.000Z</published>
    <updated>2015-04-11T02:25:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="开头扫描大概">开头扫描大概</h2>
<p>在ios中，有一个名称位URL loading system，它是一系列通过URL访问获取内容的类和协议的统称。它的核心是  <strong>NSURL</strong>  类。</p>
<p>Foundation 提供了丰富的一系列的类允许你  1 加载某个URL下的内容，2 上传数据到服务器，3 操作cookie， 4 控制响应的缓存   5 其它的例如证书存储，认证等。</p>
<p>URL loading system支持下面的一系列协议。</p>
<ol>
<li>File Transfer Protocol (ftp://)</li>
<li>Hypertext Transfer Protocol (http://)</li>
<li>Hypertext Transfer Protocol with encryption (https://)</li>
<li>Local file URLs (file:///)</li>
<li>Data URLs (data://)</li>
</ol>
<p>同时，osx和ios还提供了一些api允许在其它应用中打开URL，例如Safari，但本篇不会涉及。(可自行上网搜罗)</p>
<p>URL loading system 大致可以分为5部分，可以看下图：</p>
<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt=""></p>
<p>我们最常用的可能就是根据URL来获取数据。在ios和osx中，有几种方式，可以根据不同的target进行选择。</p>
<ol>
<li>在ios7或者之后的版本，osx v10.9或者之后的版本，更倾向于使用NSURLSession</li>
<li>对于想要支持老版本的osx，可以使用NSURLDownload</li>
<li>对于想支持老版本的ios或者osx，可以使用 NSURLConnection</li>
</ol>
<p>本文主要介绍支持新版本的NSURLSession (依据ios  版本的百分比，ios7和8占据多数)</p>
<p>若要使用NSURLConnection，可以查看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLConnection.html#//apple_ref/doc/uid/20001836-BAJEAIEE" target="_blank" rel="external">Using NSURLConnection</a></p>
<p>若要使用NSURLDownload，可以查看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLDownload.html#//apple_ref/doc/uid/20001839-BAJEAIEE" target="_blank" rel="external">Using NSURLDownload</a></p>
<h2 id="获取数据">获取数据</h2>
<ol>
<li><p>对于简单的访问，使用NSURLSession的api，根据NSURL对象，可以直接获取NSData对象或者是下载文件</p>
</li>
<li><p>对于较为复杂的访问，例如还需要上传数据，提供了NSURLRequest对象或者它的子类NSMutableURLRequest，</p>
</li>
</ol>
<h2 id="NSURLSession">NSURLSession</h2>
<p>NSURLSession 提供了通过HTTP下载内容的API，并且提供丰富的委托方法，来支持认证，和当app退居背后的时候，依旧能够进行下载。</p>
<p>顾名思义，NSURLSession是一次<strong>会话</strong>，在进行会话时候，我们需要设置几点</p>
<ol>
<li>session的类型(通过 configuration 对象来确定)</li>
<li>task的类型(是上传呢，还是下载呢？)</li>
</ol>
<h4 id="1_资源定位_使用NSURL">1 资源定位  使用NSURL</h4>
<pre><code>     <span class="comment">//网址</span>
     <span class="keyword">let</span> url = NSURL(<span class="keyword">string</span>:<span class="string">"http://......."</span>)
</code></pre><h4 id="2_会话配置">2 会话配置</h4>
<p> 有几种方式：</p>
<p> a 磁盘缓存<br> b 内存缓存<br> c 系统后台缓存</p>
<p> 默认方式是磁盘缓存</p>
<pre><code>     <span class="comment">//默认的会话配置</span>
     <span class="keyword">let</span> config = NSURLSessionConfiguration.defaultSessionConfiguration()

     <span class="comment">//还能设置会话超时时间，默认是1分钟，可以自己设定。</span>
     config.timeoutIntervalForRequest = <span class="number">10</span> <span class="comment">// 设置为10秒</span>

     <span class="comment">//建立会话</span>
     <span class="keyword">let</span> session = NSURLSession(configuration : config)
</code></pre><h4 id="3_操作方法（任务）">3 操作方法（任务）</h4>
<p> 上传，下载或者同时皆有</p>
<pre><code>     <span class="comment">//建立会话的任务</span>
     <span class="keyword">let</span> task = session.dataTaskWithURL(url!,completionHandler:{(data,
         <span class="number">_</span>,error) -&gt; <span class="type">Void</span> <span class="keyword">in</span>

         <span class="comment">//如果连接没有错误，则处理数据</span>
         <span class="keyword">if</span> error == <span class="built_in">nil</span> {
              <span class="keyword">let</span> temp = <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data,options:<span class="type">NSJSONReadingOptions</span>.<span class="type">AllowFragment</span>, error : <span class="built_in">nil</span>) <span class="keyword">as</span>? <span class="type">NSDictionary</span> {

                  <span class="comment">//可以对dictionary 直接进行 map</span>
                  <span class="keyword">let</span> weather = (json.valueForKey(<span class="string">"result"</span>) <span class="keyword">as</span>? <span class="type">NSDictionary</span>).<span class="built_in">map</span>{

                      <span class="type">Weather</span>(city: $<span class="number">0</span>[<span class="string">"citynm"</span>] <span class="keyword">as</span>? <span class="type">String</span> , 
                              weather : $<span class="number">0</span>[<span class="string">"weather"</span>] <span class="keyword">as</span>? <span class="type">String</span>,
                              temp : $<span class="number">0</span>[<span class="string">"temp"</span>] <span class="keyword">as</span>? <span class="type">String</span>)

                  }


                  <span class="comment">// 由于session执行task的线程和更新界面的主线程不是同一个线程，所以，如果要更新界面UI，那么需要切换到主线程，提升速度。速度差异明显，自己尝试便知</span>

                  dispatch_async(dispatch_get_main_queue(),{
                      () -&gt; void <span class="keyword">in</span> 
                          <span class="keyword">self</span>.weatherDatas = weather
                  })



                  <span class="comment">// 更新界面和</span>


              }


         }

     })

     <span class="comment">//执行任务</span>
     task.resume()
</code></pre><h4 id="4_任务状态">4 任务状态</h4>
<p> 继续，暂停，取消</p>
<h3 id="在Swift_playground的简单http访问">在Swift playground的简单http访问</h3>
<pre><code>        <span class="keyword">import</span> Foundation

        <span class="keyword">import</span> XCPlayground

        func httpGet(request: NSURLRequest<span class="subst">!</span>, callback: (<span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">?</span>) <span class="subst">-&gt; </span><span class="literal">Void</span>) {
            <span class="built_in">var</span> session <span class="subst">=</span> NSURLSession<span class="built_in">.</span>sharedSession()  <span class="comment">//共享的会话，使用默认的configuration</span>
            <span class="built_in">var</span> task <span class="subst">=</span> session<span class="built_in">.</span>dataTaskWithRequest(request){
                (<span class="built_in">data</span>, response, error) <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span>
                <span class="keyword">if</span> error <span class="subst">!=</span> nil {
                    callback(<span class="string">""</span>, error<span class="built_in">.</span>localizedDescription)
                } <span class="keyword">else</span> {
                    <span class="built_in">var</span> result <span class="subst">=</span> NSString(<span class="built_in">data</span>: <span class="built_in">data</span>, encoding:
                        NSASCIIStringEncoding)<span class="subst">!</span>
                    callback(result as <span class="built_in">String</span>, nil)
                }
            }
            task<span class="built_in">.</span>resume() 
        }

        <span class="built_in">var</span> request <span class="subst">=</span> NSMutableURLRequest(URL: NSURL(<span class="built_in">string</span>: <span class="string">"http://www.baidu.com"</span>)<span class="subst">!</span>)

        httpGet(request){
                (<span class="built_in">data</span>, error) <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span>
                <span class="keyword">if</span> error <span class="subst">!=</span> nil {
                    println(error)
                } <span class="keyword">else</span> {
                    println(<span class="built_in">data</span>)
                }
        }

        XCPSetExecutionShouldContinueIndefinitely(continueIndefinitely: <span class="literal">true</span>)
</code></pre><hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i" target="_blank" rel="external">URL Loading System Programming Guide</a></p>
</li>
<li><p><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/index.html" target="_blank" rel="external">NSURLSession</a></p>
</li>
<li><p><a href="http://www.swiftv.cn/course/i815wjme" target="_blank" rel="external">小波说iOS8 第二季 Swift网络编程</a></p>
</li>
</ol>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[osx XAMPP 403 error及在mac下的XAMPP下配置VirtualHosts]]></title>
    <link href="http://zhonghuan.info/2015/03/10/osx-XAMPP-403-error%E5%8F%8A%E5%9C%A8mac%E4%B8%8B%E7%9A%84XAMPP%E4%B8%8B%E9%85%8D%E7%BD%AEVirtualHosts/"/>
    <id>http://zhonghuan.info/2015/03/10/osx-XAMPP-403-error及在mac下的XAMPP下配置VirtualHosts/</id>
    <published>2015-03-10T07:28:47.000Z</published>
    <updated>2015-03-10T09:03:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="error_403">error 403</h3>
<p>你发现，安装完XAMPP，默认的localhost对应的地址是在/Applications/XAMPP/xamppfiles/htdocs下，可以将应用部署在这儿。(当然，也可以不用，文章后面会介绍VirtualHosts，就是解决这个问题的。)</p>
<p>然后，通过XAMPP的manager-osx启动apache服务器后，访问你的应用，可能会提示出403 error。原因，主要是—权限-的问题。apache默认是没有用户的，但是，在mac下，你需要在XAMPP的配置文件里设置user。步骤如下：</p>
<ol>
<li>打开/Applications/XAMPP/xamppfiles/etc/httpd.conf</li>
<li><p>找到如下代码出：</p>
<pre><code> # User/<span class="keyword">Group</span>: The name (<span class="keyword">or</span> #number) <span class="keyword">of</span> the user/<span class="keyword">group</span> <span class="keyword">to</span> run httpd <span class="keyword">as</span>.
 # It <span class="keyword">is</span> usually good practice <span class="keyword">to</span> <span class="keyword">create</span> a dedicated user <span class="keyword">and</span> <span class="keyword">group</span> <span class="keyword">for</span>
 # running httpd, <span class="keyword">as</span> <span class="keyword">with</span> most system services.
 #
 User daemon
 <span class="keyword">Group</span> daemon
</code></pre><p>更改User和Group后面的内容，具体可以在mac下，系统偏好设置—&gt;用户与群组， 先解锁，然后触摸板双击或者鼠标右键当前用户，选择 高级选项。然后里面的账号名称对应User，群组对应group。</p>
</li>
<li><p>在终端中运行下面的命令。</p>
<pre><code> sudo chown -R 你当前的用户名字 <span class="regexp">/Applications/</span>XAMPP<span class="regexp">/xamppfiles/</span>htdocs
</code></pre></li>
</ol>
<p>然后，再重启Apache服务器,ok 问题解决。</p>
<h3 id="在mac下的XAMPP下配置VirtualHosts">在mac下的XAMPP下配置VirtualHosts</h3>
<p>什么是virtualHosts，virtualHosts允许apache将hostname和目录对应起来。怎么说呢，就像上面的localhost，对应的是/Applications/XAMPP/xamppfiles/htdocs目录，有时候我们需要mysite.local（名字自己随便取）对应 /Users/yourusername/mysite(应用所在的目录)。</p>
<p>过程如下：</p>
<h5 id="允许VirtualHosts">允许VirtualHosts</h5>
<p>打开/Applications/XAMPP/xamppfiles/etc/httpd.conf，找到下面的部分：</p>
<pre><code>        # Virtual hosts
        #<span class="keyword">Include</span> <span class="regexp">/Applications/</span>XAMPP<span class="regexp">/etc/</span>extra<span class="regexp">/httpd-vhosts.conf</span>
</code></pre><p>然后去掉#：</p>
<pre><code>        # Virtual hosts
        <span class="keyword">Include</span> <span class="regexp">/Applications/</span>XAMPP<span class="regexp">/etc/</span>extra<span class="regexp">/httpd-vhosts.conf</span>
</code></pre><h5 id="创建VirtualHosts">创建VirtualHosts</h5>
<p>创建VirtualHosts，在/Applications/XAMPP/xamppfiles/etc/extra/httpd-vhosts.conf尾部，添加</p>
<pre><code>        <span class="comment"># My custom host</span>
        <span class="tag">&lt;VirtualHost *:80&gt;</span>
            <span class="keyword"><span class="common">ServerName</span></span> mysite.local
            <span class="keyword"><span class="common">DocumentRoot</span></span> <span class="string">"/Users/yourusername/path/to/your/site"</span>
            <span class="tag">&lt;Directory "/Users/yourusername/path/to/your/site"&gt;</span>
                <span class="keyword"><span class="common">Options</span></span> Indexes FollowSymLinks Includes ExecCGI
                <span class="keyword">AllowOverride</span> <span class="literal">All</span>
                <span class="keyword">Require</span> <span class="literal">all</span> granted
            <span class="tag">&lt;/Directory&gt;</span>
            <span class="keyword">ErrorLog</span> <span class="string">"logs/mysite.local-error_log"</span>
        <span class="tag">&lt;/VirtualHost&gt;</span>
</code></pre><p>记住，mysite.local是自定义的host name。</p>
<h6 id="编辑hosts文件">编辑hosts文件</h6>
<p>完成上面的步骤，你只是在Apache内完成配置，当你在浏览器内访问mysite.local时候，浏览器并不知道这一切，你需要在hosts文件内，将mysite.local和127.0.0.1绑定映射。</p>
<p>打开终端，输入：</p>
<pre><code>    <span class="built_in">sudo</span> nano /etc/hosts
</code></pre><p>输入：</p>
<pre><code>    <span class="comment"># XAMPP VirtualHost mappings</span>
    <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> mysite.<span class="built_in">local</span>
</code></pre><p>使用control+o保存，使用control+x关闭。</p>
<h5 id="重启Apache服务器">重启Apache服务器</h5>
<h3 id="结束语">结束语</h3>
<p>希望能够帮助在osx下使用XAMPP的朋友。</p>
<h3 id="引用：">引用：</h3>
<ol>
<li><p><a href="http://jonathannicol.com/blog/2012/03/11/configuring-virtualhosts-in-xampp-on-mac/" target="_blank" rel="external">Configuring VirtualHosts in XAMPP on Mac</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/18365500/xampp-mac-virtual-host-showing-403" target="_blank" rel="external">XAMPP (Mac) Virtual host showing 403 (stackoverflow)</a></p>
</li>
</ol>
]]></content>
    
    
      <category term="osX" scheme="http://zhonghuan.info/tags/osX/"/>
    
      <category term="XAMPP" scheme="http://zhonghuan.info/tags/XAMPP/"/>
    
      <category term="问题笔记" scheme="http://zhonghuan.info/categories/%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下“一键回桌面”应用开发笔记]]></title>
    <link href="http://zhonghuan.info/2015/03/03/Mac%E4%B8%8B%E2%80%9C%E4%B8%80%E9%94%AE%E5%9B%9E%E6%A1%8C%E9%9D%A2%E2%80%9D%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhonghuan.info/2015/03/03/Mac下“一键回桌面”应用开发笔记/</id>
    <published>2015-03-03T13:48:32.000Z</published>
    <updated>2015-04-11T02:24:46.000Z</updated>
    <content type="html"><![CDATA[<p>偶然看到别人的写得一篇<a href="http://jiajixin.cn/2015/02/21/mac-application-show-desktop/" target="_blank" rel="external">Mac下显示桌面应用开发</a>,觉得挺有趣的，并且，一键回桌面，对我来说，也是挺常用的，所以，就试着自己开发了一个，不过原来的作者使用的是objective c开发的。这里使用的是Swift语言来进行开发，也是加深自己对于Swift的运用吧。</p>
<h3 id="功能">功能</h3>
<ol>
<li>状态栏点击图标，即显示桌面，所有显示窗口最小化。</li>
<li>开机默认自启动，用户可以选择是否开机自启动。</li>
</ol>
<p>原来的作者开发的是纯状态栏应用，初衷也挺好的，但是，有一个瑕疵是，用户不能手动退出应用了。所以，我把它放在dock了(其实这也是瑕疵！)，这样的好处，不用的时候，用户可以手动退出。</p>
<h3 id="状态栏">状态栏</h3>
<p>要在状态栏中显示icon，并且添加点击它的action，代码如下：</p>
<pre><code><span class="keyword">let</span> <span class="variable">statusItem =</span> NSStatusBar.systemStatusBar().statusItemWithLength(-<span class="number">1</span>)

//icon showed <span class="keyword">in</span> system status bar
<span class="keyword">let</span> <span class="variable">icon =</span> NSImage(named: <span class="string">"desktop"</span>)
icon?.setTemplate(<span class="constant">true</span>)
statusItem.<span class="variable">image =</span> icon

// define the action when the icon was clicked!
statusItem.<span class="variable">action =</span> Selector(<span class="string">"goBackDesktop:"</span>)
</code></pre><h3 id="显示桌面">显示桌面</h3>
<p>如何实现显示桌面呢？<br>其实显示桌面是有快捷键的，CMD+ALT+H+M，按下CMD+ALT+H就会隐藏当前窗口除外的窗口，CMD+M会隐藏当前窗口，所以同时按下CMD+ALT+H+M就会达到显示桌面的效果。</p>
<p>所以现在需要做的就是模拟按键，代码如下：</p>
<pre><code>    //simulate option+command+h+m 

    var <span class="variable">src =</span> CGEventSourceCreate(CGEventSourceStateID(kCGEventSourceStateHIDSystemState)).takeRetainedValue()

    <span class="keyword">let</span> <span class="variable">cmdDown =</span> CGEventCreateKeyboardEvent(src, <span class="number">0</span>x37, <span class="constant">true</span>).takeRetainedValue()
    <span class="keyword">let</span> <span class="variable">cmdUp =</span> CGEventCreateKeyboardEvent(src, <span class="number">0</span>x37, <span class="constant">false</span>).takeRetainedValue()
    CGEventSetFlags(cmdDown, CGEventFlags(kCGEventFlagMaskCommand))
    CGEventSetFlags(cmdUp, CGEventFlags(kCGEventFlagMaskCommand))


    <span class="keyword">let</span> <span class="variable">loc =</span> CGEventTapLocation(kCGHIDEventTap)

    CGEventPost(loc, cmdDown)

    CGEventPost(loc, cmdUp)
</code></pre><p>其中0x37，对应的是Command按键。</p>
<h3 id="开机启动">开机启动</h3>
<p>Swift开机启动，我是看了这个<a href="http://stackoverflow.com/questions/26475008/swift-getting-a-mac-app-to-launch-on-startup" target="_blank" rel="external">stackoverflow的提问</a>,了解的。</p>
<h3 id="效果展示">效果展示</h3>
<p><img src="http://zhonghuan.qiniudn.com/showDesktop.gif" alt=""></p>
<h3 id="应用下载">应用下载</h3>
<p><a href="http://zhonghuan.info/ZHShowDesktop.app.zip" target="_blank" rel="external">http://zhonghuan.info/ZHShowDesktop.app.zip</a></p>
<p>下载完后，直接拷贝到应用程序中即可</p>
<h3 id="代码">代码</h3>
<p>代码都放在我的github上了，喜欢的朋友请点个赞，觉得有必要改进的朋友，可以fork之后，再合并给我。</p>
<p>地址： <a href="https://github.com/ZHONGHuanGit/ZHShowDesktop" target="_blank" rel="external">https://github.com/ZHONGHuanGit/ZHShowDesktop</a></p>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="osX" scheme="http://zhonghuan.info/tags/osX/"/>
    
      <category term="mac" scheme="http://zhonghuan.info/tags/mac/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析编译原理-上下文无关文法]]></title>
    <link href="http://zhonghuan.info/2014/11/23/%E6%B5%85%E6%9E%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    <id>http://zhonghuan.info/2014/11/23/浅析编译原理-上下文无关文法/</id>
    <published>2014-11-23T15:47:09.000Z</published>
    <updated>2015-04-11T02:26:47.000Z</updated>
    <content type="html"><![CDATA[<p>查找wiki，是这样说文法，文法即文章的书写法规，一般用来指以文字、词语、短句、句子[1]编排而成的完整语句和文章的合理性组织。语言的结构方式。包括词的构成和变化﹐词组和句子的组织。</p>
<pre><code>例如：
最简单的语句组合一：主词及动词：
“我”“哭了”
（主语）+（动词）
“天气”“改变了”
</code></pre><p>其实说白了，在程序语言中，就是语言的构造规则。例如中文的构造规则是：&lt;主语&gt;&lt;谓语&gt;&lt;宾语&gt;&lt;补语&gt;&lt;状语&gt;。英文的构造规则是：S十V主谓结构 S十V十F主系表结构 S十V十O主谓宾结构 S十V十O1十O2主谓双宾结构 S十V十O十C主谓宾补结构说明：S＝主语；V＝谓语；P＝表语；O＝宾语；O1＝间接宾语；O2＝直接宾语；C＝宾语补足语。我们可以看出汉语和英语有不同的编排，不同的规则，这就是文法的不同。 </p>
<hr>
<h3 id="上下文无关的文法">上下文无关的文法</h3>
<p>上下文无关的文法，是文法中一种，它是这样定义的：</p>
<p>一个上下文无关文法G包括四个组成部分：</p>
<ul>
<li>一组终结符号</li>
<li>一组非终结符</li>
<li>一个开始符号</li>
<li>一组产生式。</li>
</ul>
<p>所谓终结符号：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乃是组成语言的基本符号，即在程序语言中以前屡次提到的单词符号，如基本字，标识符，常数，算符和界符等</p>
<p>所谓非终结符号（也称语法变量）:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来代表语法范畴。如“算术表达式”、“布尔表达式”、“过程”等。一个非终结符代表一个一定的语法概念。因此非终结符是一个类（或集合）记号，而不是个体记号。</p>
<p>开始符号:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一个特殊的非终结符号，它代表所定义的语言中我们最感兴趣的语法范畴，这个语法范畴通常称为“句子”。但在程序语言中我们最终感兴趣的是“程序”这个语法范畴，而其他的语法范畴都只不过是构造“程序”的一块块砖石。</p>
<p>产生式（也称为产生规则或简称规则）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是定义语法范畴的一种书写规则。一个产生式的形式是  A→ α ,其中箭头左边的A是一个终结符，称为产生式的左部符号；箭头右边的α是终结符号或与非终结符号组成的一符号串，称为产生式的右部。</p>
<p>看完上面的概念，似乎仍旧不太理解，让我们来看下面的例子，从例子中理解。</p>
<hr>
<h3 id="从例子中理解">从例子中理解</h3>
<p>分析句子：The grey wolf will eat  the  goat .</p>
<p>这个句子的结构如下图:</p>
<p><img src="http://zhonghuan.qiniudn.com/CompilerTheory/上下文无关文法/上下文无关文法1.jpeg" alt=""></p>
<p>可以从上面的图中清晰地看出句子的成分。</p>
<p>上面树中的每一个<strong>叶子节点中的单词</strong>，对应的就是上下文无关文法中的<strong>终结符号</strong>。</p>
<p>而句子的<strong>开始符号</strong>就是<strong>根节点&lt;句子&gt;</strong></p>
<p>而句子的产生式，如下图：</p>
<p><img src="http://zhonghuan.qiniudn.com/CompilerTheory/上下文无关文法/上下文无关文法2.jpeg" alt=""></p>
<p>那么什么是<strong>非终结符号</strong>呢？它对应着上面树中的<strong>非叶子节点</strong>，是滴，你木有看错，飞叶子节点，包括<strong>根节点句子</strong>。</p>
<p><img src="http://zhonghuan.qiniudn.com/CompilerTheory/上下文无关文法/上下文无关文法3.jpeg" alt=""></p>
<p>看到这里，估计你对于上下文无关文法有了一个大致的了解。</p>
<p>前面我们提到过可以用一张图表示一个句型的推导，这种表示称为语法分析树，或简称语法树。</p>
<p>语法树的根结由开始符号所标记。随着推导的展开，当某个非终结符被它的某个候选式所替换时，这个非终结符的相应结就产生了下一代新结。每个新结和其父亲结间都有一条连线。在一棵语法树生长过程中的任何时刻，所有那些没有后代的端末结自左至右排列起来就是一个句型。</p>
<hr>
<h3 id="补充">补充</h3>
<p>首先引入几个概念：</p>
<p>设Σ是一个有穷字母表，它的每个元素称为一个符号。 Σ上的一个符号串是指由Σ中的符号所构成的有穷序列。不包含符号的序列称为空字符，记为ε。用Σ*表示Σ上的所有符号串的全体，空字也包括在其中。</p>
<pre><code>如：若Σ=<span class="list">{a,b}</span>则Σ*=<span class="list">{,a,b,aa,ab,bb,aaa,…}</span>。Σ表示不含人何元素的空集<span class="list">{}</span>。这里要注意ε、<span class="list">{}</span>和<span class="list">{ε}</span>的区别
</code></pre><p>Σ*的子集U和V中的（连接）积定义为:</p>
<pre><code><span class="attribute">UV</span>=<span class="string">{αβ∣α∈U &amp; β∈V }</span>
</code></pre><p>即集合UV中的符号串是由U和V的符号串连接而成的。注意，一般UV≠VU，但（UV)W=U(VW).<br>V自身的n次（连接）积记为：</p>
<pre><code><span class="attribute">Vn </span>=<span class="string"> V V…V   (n个V)</span>
</code></pre><p>规定 V0 = {}.<br>   令： V*  = V0 ∪ V1 ∪ V2 ∪ …<br>   称 V*是V的闭包。<br>记V+ = VV*, 称 V+是V的正则包。</p>
<p>闭包V*中的每个符号都是由V中的符号串经有限次连接而成的。</p>
<p>假定G是一个文法，S是它的开始符号。如果S→*α(表示从S出发，经0步或若干步可推出α），则称α是一个句型。仅含终结符号的句型是一个句子。文法G所产生的句子的全体是一个语言，将它记为L(G).</p>
<pre><code><span class="attribute"> L(G)</span>=<span class="string">{|S →* α &amp; α ∈ VT }</span>
</code></pre><p>例如：终结符号串（i*i+i)是文法</p>
<pre><code><span class="keyword">E</span>→<span class="keyword">E</span>+<span class="keyword">E</span>|<span class="keyword">E</span>\*<span class="keyword">E</span>|(<span class="keyword">E</span>)|ｉ　　　  (<span class="number">2.1</span>)
</code></pre><p>的一个句子。是因为有</p>
<pre><code><span class="keyword">E</span> → (<span class="keyword">E</span>) → (<span class="keyword">E</span>+<span class="keyword">E</span>) → (<span class="keyword">E</span>*<span class="keyword">E</span>+<span class="keyword">E</span>) → (i*<span class="keyword">E</span>+<span class="keyword">E</span>)
→ (i*i+<span class="keyword">E</span>) → (i*i+i)从开始符号<span class="keyword">E</span>至
 （i*i+i)的一个推导。而<span class="keyword">E</span>,(<span class="keyword">E</span>),(<span class="keyword">E</span>*<span class="keyword">E</span>+<span class="keyword">E</span>)等是文法的句型。
</code></pre><p>考虑一个文法G1:</p>
<pre><code>  S→bA
  <span class="literal">A</span>→aA|<span class="literal">a</span> 它定义了一个什么语言呢？
</code></pre><p>从开始符S出发，我们可以推出如下句子：<br>   S → bA → ba<br>   S → bA → baA → baa<br>   S → bA → baA → …  → baa…a<br>可以写为：L(G1)={ba^n|n≥1}</p>
<hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h3 id="参考资料：">参考资料：</h3>
<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E6%96%87%E6%B3%95" target="_blank" rel="external">wiki 文法</a></li>
<li><a href="http://book.douban.com/subject/3296317/" target="_blank" rel="external">编译原理</a></li>
<li><a href="">编译原理学习周入门教程—（3）文法和语言</a></li>
</ul>
]]></content>
    
    
      <category term="编译原理" scheme="http://zhonghuan.info/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译" scheme="http://zhonghuan.info/categories/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flashlight--spotlight的好帮手]]></title>
    <link href="http://zhonghuan.info/2014/11/22/flashlight-spotlight%E7%9A%84%E5%A5%BD%E5%B8%AE%E6%89%8B/"/>
    <id>http://zhonghuan.info/2014/11/22/flashlight-spotlight的好帮手/</id>
    <published>2014-11-21T16:29:30.000Z</published>
    <updated>2014-11-21T16:32:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Flashlight简介：">Flashlight简介：</h3>
<p>OS X Yosemite 上全新的 Spotlight 越发强大，大有吞并 LaunchBar 6 与 Alfread 之势，但碍于官方 API 的种种限制，很多 Web 内容、文件和应用程序不能直接在其搜索框调用。为此一款基于 Python 编写的 Spotlight 插件应运而生。这个便是Flashlight啦。</p>
<p>那么它的作用是什么？如果你用过Alfred的话，那么对于Flashlight的定义就是给Spotlight写workflow的插件。</p>
<p>Spotlight的作用，用过的人都知道了，就不详述了，那么flashlight给Spotlight带来了什么呢？为什么大家说，有了flashlight的话，未来Spotlight会替代Alfred（当然，这句话有待观察，毕竟Flashlight现在还不太稳定）</p>
<hr>
<h3 id="功能">功能</h3>
<p>主要能够实现的功能。下面列出我觉得几个不错的扩展功能。</p>
<ul>
<li>天气搜索，通过 Flashlight 提供的 API 接口，Spotlight 搜索框内会显示动态天气动画与未来三天的天气预测，用法：weather + 地址</li>
</ul>
<p><img src="http://zhonghuan.qiniudn.com/osX/flashlight/weather.gif" alt=""></p>
<ul>
<li>有道词典翻译，通过 Flashlight 提供的 API 接口，Spotlight 搜索框内需要翻译的内容。用法yd + （内容）</li>
</ul>
<p><img src="http://zhonghuan.qiniudn.com/osX/flashlight/youdao1.gif" alt=""></p>
<ul>
<li>WolframAlpha搜索，WolframAlpha是一个自动问答网站，非常智慧。用法 walpha + 问题<br><img src="http://zhonghuan.qiniudn.com/osX/flashlight/walpha.gif" alt=""></li>
</ul>
<ul>
<li>知乎日报的功能。 用法 zhihu + (daily || hot || 20140822(该日期热点新闻)）<br><img src="http://zhonghuan.qiniudn.com/osX/flashlight/zhihu1.gif" alt=""></li>
</ul>
<hr>
<p>Flashlight，就是提供给开发者一个平台，给Spotlight增加用户需要的一些额外的功能。</p>
<p><img src="http://zhonghuan.qiniudn.com/osX/flashlight/flashlight.png" alt=""></p>
<hr>
<h3 id="开发">开发</h3>
<p>如果你想要给Spotlight增加一些额外的功能，可以看这里<a href="https://github.com/nate-parrott/Flashlight" target="_blank" rel="external">https://github.com/nate-parrott/Flashlight</a></p>
<p>上面的功能介绍中，第四个知乎日报，是由本人闲得时候贡献的，具体可以看这里<a href="https://github.com/ZHONGHuanGit/ZhihuDaily" target="_blank" rel="external">https://github.com/ZHONGHuanGit/ZhihuDaily</a> 要是觉得不错，请点个star</p>
]]></content>
    
    
      <category term="osX" scheme="http://zhonghuan.info/tags/osX/"/>
    
      <category term="工具类，软件类介绍" scheme="http://zhonghuan.info/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E8%BD%AF%E4%BB%B6%E7%B1%BB%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[电子商务发展对企业和消费者行为带来了哪些变化]]></title>
    <link href="http://zhonghuan.info/2014/10/16/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E5%8F%91%E5%B1%95%E5%AF%B9%E4%BC%81%E4%B8%9A%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E8%A1%8C%E4%B8%BA%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96/"/>
    <id>http://zhonghuan.info/2014/10/16/电子商务发展对企业和消费者行为带来了哪些变化/</id>
    <published>2014-10-15T16:46:48.000Z</published>
    <updated>2014-10-15T17:02:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="序">序</h2>
<p>经济学家认为,目前人类正在进行第三次商业革命:信息革命（第一次农业革命，第二次工业革命），电子商务是这次革命浪潮的最重要的表现形式.传统商贸必然在这次革命浪潮中,实现改造,脱胎换骨。那么，互联网和电子商务的出现带来了哪些深刻的变化呢？</p>
<p><img src="http://www.nxqcc.com/Uploads/goods/20140104/20140104183949_4205.jpg" alt=""></p>
<h2 id="直销得到发展">直销得到发展</h2>
<p>在线零售就是一种通过网络来实现的直销。直销和店铺是传统销售的两种形式。其实传统经济中直销早已存在，但过去由于信息不发达，物流条件受到限制，商品一般都是通过层层批发的供应链方式最终到达消费者手上，直销做起来比较困难。互联网打破了时间和空间的界限，打破了传统信息不对称的局面，买卖双方很容易通过互联网建立业务关系。因此直销得到极大地发展，直销的比例不断地增长。</p>
<hr>
<h2 id="多元电子商务模式得到发展">多元电子商务模式得到发展</h2>
<p>多元电子商务模式得到了充足发展。下面让我们来了解一下不同的模式。</p>
<h3 id="B2C：">B2C：</h3>
<p>是Business-to-Customer的缩写，而其中文简称为“商对客”。“商对客”是电子商务的一种模式，也就是通常说的商业零售，直接面向消费者销售产品和服务。B2C的典型代表就是亚马逊，这是一家美国的在线零售网站，在国内，当然也有不少代表网站，如天猫，京东等。（值得一提的是，拥有天猫的阿里巴巴和京东今年都在美国上市，都获得了巨额的融资，其中阿里巴巴一跃成为近两千亿市值的互联网公司。）但是，双方实现的形式略有不同，京东属于自主经营卖产品，而阿里巴巴则是为企业服务做平台。</p>
<h3 id="C2C：">C2C：</h3>
<p>C2C的意思就是个人与个人之间的电子商务。比如一个消费者有一台旧电脑，通过网络进行交易，把它出售给另外一个消费者，此种交易类型就称为C2C电子商务。在美国，有EBay；而在中国，有淘宝网，拍拍网。</p>
<h3 id="B2B：">B2B：</h3>
<p>B2B是指进行电子商务交易的供需双方都是商家（或企业、公司），她（他）们使用了Internet的技术或各种商务网络平台，完成商务交易的过程。典型代表是阿里巴巴。</p>
<h3 id="O2O：">O2O：</h3>
<p>O2O即Online To Offline（线上到线下），是指将线下的商务机会与互联网结合，让互联网成为线下交易的前台。说起O2O，不得不提前几年的火热的千团大战，指的是众多的团购网站突起，纷纷打起了价格战，当然时至今日，存在下来的团购网站数量大大减少。以糯米，美团，大众点评等，主打的是美食与电影，生活产品等等。当然还有家用电器为主的苏宁，国美也加入了O2O的行列，依靠自身众多的线下实体店，做起了线上网站。当然还有主打旅游出行的携程，艺龙等，主打和旅游出行有关的酒店住宿，机票预订等。近些时间，O2O依旧是火热的话题，经过不断探索，有很多新的方式出来。比如饿了么，淘点点主打外卖线上订购，送货上门，我觉得这也属于O2O模式的变种。还有改进社交模式而出现的约你，约你主打线上订购，线下约会，解决原本的社交没有分清约会，谁来请客的问题。O2O的潜力仍然未被完全发掘，如今被认为是下一个千亿企业的诞生之处。</p>
<hr>
<h2 id="对于企业的变化">对于企业的变化</h2>
<p>电子商务的发展，无疑带动了企业的成长。从各种互联网企业的崛起之外，传统企业也不得不跟进时势，求生存发展。众多线下零售巨头，不仅是美国的沃尔玛，中国的华润万家，万达等，建立起线上的电子商务网站。不仅是零售行业，对于连锁酒店，星级酒店也是如此，连锁酒店如七天，如家等，都有自己的线上网站。同样，对于火车票订购，同样建立其自己的网站，开售火车票，如今，从前的每逢节假日需要排队数小时才能买到票的场景已经不再，大多数人都会通过网络订票，线下取票。电子商务的发展促进了企业的发展的同时，也方便了客户的购买。</p>
<hr>
<h2 id="对于消费者行为的变化">对于消费者行为的变化</h2>
<h4 id="价格更透明：">价格更透明：</h4>
<p>有了众多的电子商务网站，如今的商品价格，在网上一查便可以马上了解个大概，因为相对来说，网络上的价格会更透明，更真实。同样，因为网络购物，商家一般都打价格战，所以网上的价格会更低廉。所以，线下购物，可以参考线上的价格。最终，导致更多地商品价格透明，线下的商家也更少像从前那样漫天要价。</p>
<h4 id="购物方式的巨大改变：">购物方式的巨大改变：</h4>
<p>曾经的在在线下实体商家购物的方式，如今更多的人（特别是年轻人），会选择在网络上购买商品，原因是综合的，网络上的价格低廉，购物平台可以看到众多已购者对于商品的评价，从而对该商品质量有一个大致的认识。这笔线下购物，会更有参考性一些。当然，线下实体购物依旧有其强大的优势，所以仍然是购物的主流，特别是对于生鲜产品一块</p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ol>
<li><p>张润彤，（2009.3）电子商务概论</p>
</li>
<li><p>（2014.7）互联网和电子商务给传统商贸带来哪些深刻变化？ </p>
</li>
</ol>
<p>From <a href="http://blog.sina.com.cn/s/profile_1796241195.html" target="_blank" rel="external">http://blog.sina.com.cn/s/profile_1796241195.html</a></p>
]]></content>
    
    
      <category term="电子商务" scheme="http://zhonghuan.info/tags/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/"/>
    
      <category term="记or谈" scheme="http://zhonghuan.info/categories/%E8%AE%B0or%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pip介绍与使用]]></title>
    <link href="http://zhonghuan.info/2014/10/01/pip%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhonghuan.info/2014/10/01/pip介绍与使用/</id>
    <published>2014-10-01T01:26:54.000Z</published>
    <updated>2015-04-11T02:24:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>pip 是一个安装和管理 Python 包的工具，python安装包的工具有easy_install, setuptools, pip，distribute。使用这些工具都能下载并安装django。，而pip是easy_install的替代品。在CPython解释器，pypy解释器，可以很好地工作</p>
<hr>
<h2 id="安装pip">安装pip</h2>
<p>安装和升级之前，先下载 <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="external">get-pip.py</a></p>
<p>然后使用下面的命令：</p>
<pre><code><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span>
</code></pre><p>不过注意一下，linux或osX下，需要权限，使用下面的命令，输入密码后即可。</p>
<pre><code>sudo <span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span> 
</code></pre><p>windows下需要管理员权限启动终端。</p>
<p>如果你还没有安装了<a href="http://baike.baidu.com/view/4944440.htm" target="_blank" rel="external">setuptools</a>，get-pip.py 会帮你安装。</p>
<p>如果你已经安装了setuptools，运行下面的命令进行升级。</p>
<pre><code>pip <span class="operator"><span class="keyword">install</span> -U setuptools</span>
</code></pre><p>windows下，注意将pip路劲加到系统的path中，原因就不解释了吧。</p>
<hr>
<h2 id="升级pip">升级pip</h2>
<p>Linux or OS X系统，运行下面的命令:</p>
<pre><code>pip <span class="operator"><span class="keyword">install</span> -U pip</span>
</code></pre><p>windows系统运行下面的命令：</p>
<pre><code><span class="keyword">python</span> -<span class="keyword">m</span> pip install -U pip
</code></pre><hr>
<h2 id="安装包">安装包</h2>
<p>使用下面的命令来安装包</p>
<pre><code>pip <span class="operator"><span class="keyword">install</span> SomePackage            # latest <span class="keyword">version</span>
pip <span class="keyword">install</span> SomePackage==<span class="number">1.0</span><span class="number">.4</span>     # specific <span class="keyword">version</span>
pip <span class="keyword">install</span> <span class="string">'SomePackage&gt;=1.0.4'</span>     # minimum <span class="keyword">version</span></span>
</code></pre><p>要看更多地例子，可以看这里<a href="https://pip.pypa.io/en/latest/reference/pip_install.html#pip-install" target="_blank" rel="external">pip install</a></p>
<p>例如我要安装Django，用下面的一条命令即可，方便快捷。</p>
<pre><code><span class="attribute">pip install Django=</span>=<span class="string">1.7</span>
</code></pre><hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://pip.pypa.io/en/latest/installing.html" target="_blank" rel="external">pip</a></li>
</ul>
]]></content>
    
    
      <category term="python安装管理工具" scheme="http://zhonghuan.info/tags/python%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="pip" scheme="http://zhonghuan.info/tags/pip/"/>
    
      <category term="工具类，软件类介绍" scheme="http://zhonghuan.info/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E8%BD%AF%E4%BB%B6%E7%B1%BB%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[清华大学软件2014机试]]></title>
    <link href="http://zhonghuan.info/2014/09/24/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B62014%E6%9C%BA%E8%AF%95/"/>
    <id>http://zhonghuan.info/2014/09/24/清华大学软件2014机试/</id>
    <published>2014-09-24T11:33:15.000Z</published>
    <updated>2015-04-11T02:25:57.000Z</updated>
    <content type="html"><![CDATA[<p>今天刚刚机试完，乘者还没忘记，把自己知道的记下来，也算是泽被后来人吧~~~</p>
<p>这次的机试题，相对来说，会更简单一点，总共3题，时间是3小时。</p>
<h3 id="1_超级幸运数">1 超级幸运数</h3>
<p>题目大致描述：</p>
<p>一个数字，若是只含有1和4，这个数字就是幸运数，例如，14，114。但是514这样的就不是了，因为含有其它数字。  若这个幸运数字中，1和4的数量相同，那么就是超级幸运数，例如14，1144，41等等。</p>
<p>题目要求，输入一个n，n的范围是[1,1e9]，输出[1,n]的最大超级幸运数。无解的话，输出-1.</p>
<p>解题思路：</p>
<p>这个题目，当n<14，那么显然是无解的，其余情况，最起码还有14，其实就是当>=14的时候，找一个最大的就好了，那么最大有什么规律，假设输入的n有x位，当位数是奇数的时候，输出(x-1)/2个4，和(x-1)/2个1，就好了。如果位数是偶数的话，那么，要考虑一下一些情况了，因为输出是不能大于n的，并且4和1的个数相等。还有，注意这样的数据1000，它的输出应该是41。</14，那么显然是无解的，其余情况，最起码还有14，其实就是当></p>
<p>一些测试数据：</p>
<p>in： 20  out：14</p>
<p>in： 10  out： -1</p>
<p>in：1000  out： 41</p>
<h3 id="2_移动小球">2 移动小球</h3>
<p>有一些小球，1，2，。。。，n；<br>有两种操作，分别是</p>
<ul>
<li>1 x y ,把x移动至y的左边</li>
<li>2 x y ,把x移动至y的右边</li>
</ul>
<p>问得是，m次操作后，小球的顺序是什么..</p>
<p>其实就是这样的，原本1，2，3，4，5.（如果n=5的话）。经过1 1 4操作后，变成2 3 1 4 5</p>
<p>n数据范围[1,1000]</p>
<p>m 数据范围[1,200000]</p>
<p>解题思路：</p>
<p>双向链表就能够解决这个问题。再用一个数组存储这些个节点的位置。</p>
<p>测试数据：</p>
<p>in ：  </p>
<p>5， 2  （输入是 n m）</p>
<p>1 1 4   （表示操作，1，x， y）</p>
<p>2 4 2</p>
<p>out：  2 4 3 1 5；</p>
<h3 id="3_整理书架">3 整理书架</h3>
<p>书店管理员要把书架上的书整理一下，其实就是一排书，让书的排序是按照书的高低，每本书有一个重量，重量越大，移动书时越费力，越累，让我们求的是，总的移动书本的最小重量是多少。</p>
<p>给出的数据是：</p>
<p>5（书的数量）</p>
<p>1 2 5 3 3 （表示书的高度）</p>
<p>1 1 3 1 1 （标示书的重量）</p>
<p>输出是2，</p>
<p>为什么是2，因为这里只需要把第4，第5本书移动到第三本书的前面，就能够保证书的有序，移动的重量和是2。</p>
<p>解题思路：</p>
<p>移动的重量和最小，其实就是求，不移动重量和的最大是多少。那么怎么求不移动的最大重量和呢？其实就是记录下每本书的位置，高度，重量，然后按照高度排序，排序完后，按照节点的位置，来求一个最大子序列，不过这个最大子序列，大不在长度上，而是重量和上，这样求出来的最大子序列重量和，就是不移动的最大重量和，总的重量减去它，就是我们要的答案</p>
<hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析快速排序]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhonghuan.info/2014/09/16/浅析快速排序/</id>
    <published>2014-09-16T08:08:44.000Z</published>
    <updated>2015-04-11T02:26:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本思想与特性">基本思想与特性</h2>
<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<ol>
<li><p>先从数列中取出一个数作为基准数。</p>
</li>
<li><p>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
</li>
<li><p>再对左右区间重复第二步，直到各区间只有一个数。</p>
</li>
</ol>
<p>快速排序算法的基本特性:</p>
<ol>
<li><p>时间复杂度：O（n*lgn）</p>
</li>
<li><p>最坏：O（n^2）</p>
</li>
<li><p>空间复杂度：O（n*lgn）</p>
</li>
<li><p>不稳定。</p>
</li>
</ol>
<p>快速排序是一种排序算法，对包含n个数的输入数组，平均时间为O（nlgn），最坏情况是O（n^2）。<br>通常是用于排序的最佳选择。因为，基于比较的排序，最快也只能达到O（nlgn）。</p>
<hr>
<h2 id="步骤与代码实现">步骤与代码实现</h2>
<p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：</p>
<p>先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。</p>
<p>以一个数组作为示例，取区间第一个数为基准数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">72</td>
<td style="text-align:center">6</td>
<td style="text-align:center">57</td>
<td style="text-align:center">88</td>
<td style="text-align:center">60</td>
<td style="text-align:center">42</td>
<td style="text-align:center">83</td>
<td style="text-align:center">73</td>
<td style="text-align:center">48</td>
<td style="text-align:center">85</td>
</tr>
</tbody>
</table>
<p>初始时，i = 0;  j = 9;   X = a[i] = 72</p>
<p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p>
<p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j—;</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">6</td>
<td style="text-align:center">57</td>
<td style="text-align:center">88</td>
<td style="text-align:center">60</td>
<td style="text-align:center">42</td>
<td style="text-align:center">83</td>
<td style="text-align:center">73</td>
<td style="text-align:center">48</td>
<td style="text-align:center">85</td>
</tr>
</tbody>
</table>
<p> i = 3;   j = 7;   X=72</p>
<p>再重复上面的步骤，先从后向前找，再从前向后找。</p>
<p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p>
<p>从i开始向后找，当i=5时，由于i==j退出。</p>
<p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p>
<p>数组变为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">6</td>
<td style="text-align:center">57</td>
<td style="text-align:center">42</td>
<td style="text-align:center">60</td>
<td style="text-align:center">72</td>
<td style="text-align:center">83</td>
<td style="text-align:center">73</td>
<td style="text-align:center">88</td>
<td style="text-align:center">85</td>
</tr>
</tbody>
</table>
<p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。</p>
<p>对挖坑填数进行总结</p>
<ol>
<li><p>i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p>
</li>
<li><p>j—由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p>
</li>
<li><p>i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p>
</li>
<li><p>再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p>
</li>
</ol>
<p>照着这个总结很容易实现挖坑填数的代码：</p>
<pre><code><span class="keyword">void</span> quick_sort1(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)
{
    <span class="keyword">if</span> (l &lt; r)
    {
        <span class="keyword">int</span> i = AdjustArray(s, l, r);<span class="comment">//先成挖坑填数法调整s[]</span>
        quick_sort1(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span>
        quick_sort1(s, i + <span class="number">1</span>, r);
    }
}

<span class="comment">//快速排序</span>
<span class="keyword">void</span> quick_sort(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)
{
    <span class="keyword">if</span> (l &lt; r)
    {
        <span class="comment">//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1</span>
        <span class="keyword">int</span> i = l, j = r, x = s[l];
        <span class="keyword">while</span> (i &lt; j)
        {
            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[j] &gt;= x) <span class="comment">// 从右向左找第一个小于x的数</span>
                j--;  
            <span class="keyword">if</span>(i &lt; j) 
                s[i++] = s[j];

            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt; x) <span class="comment">// 从左向右找第一个大于等于x的数</span>
                i++;  
            <span class="keyword">if</span>(i &lt; j) 
                s[j--] = s[i];
        }
        s[i] = x;
        quick_sort(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span>
        quick_sort(s, i + <span class="number">1</span>, r);
    }
}
</code></pre><hr>
<h2 id="算法分析">算法分析</h2>
<p>快速排序的时间主要耗费在划分操作上，对长度为k的区间进行划分，共需k-1次关键字的比较。</p>
<h3 id="（1）最坏时间复杂度">（1）最坏时间复杂度</h3>
<p>最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。<br>    　<br>因此，快速排序必须做n-1次划分，第i次划分开始时区间长度为n-i+1，所需的比较次数为n-i(1≤i≤n-1)，故总的比较次数达到最大值：</p>
<pre><code><span class="attribute">           Cmax </span>=<span class="string"> n(n-1)/2=O(n2)
　</span>
</code></pre><p>如果按上面给出的划分算法，每次取当前无序区的第1个记录为基准，那么当文件的记录已按递增序(或递减序)排列时，每次划分所取的基准就是当前无序区中关键字最小(或最大)的记录，则快速排序所需的比较次数反而最多。</p>
<h3 id="（2）_最好时间复杂度">（2）    最好时间复杂度</h3>
<p> 　<br>在最好情况下，每次划分所取的基准都是当前无序区的”中值”记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。总的关键字比较次数 ：O(nlgn)</p>
<p>注意：
    　</p>
<pre><code>    用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为<span class="keyword">O</span>(lgn)，而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数<span class="keyword">C</span>(n)=<span class="keyword">O</span>(nlgn)。
    因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为<span class="number">0</span>(n2)，最好时间复杂度为<span class="keyword">O</span>(nlgn)。
</code></pre><h3 id="（3）基准关键字的选取">（3）基准关键字的选取</h3>
<p>在当前无序区中选取划分的基准关键字是决定算法性能的关键。</p>
<ul>
<li>“三者取中”的规则<br>  　“三者取中”规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准，在划分开始前将该基准记录和该区伺的第1个记录进行交换，此后的划分过程与上面所给的Partition算法完全相同。
 　</li>
<li>取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准<br>  　选取基准最好的方法是用一个随机函数产生一个取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准，这相当于强迫R[low..high]中的记录是随机分布的。用此方法所得到的快速排序一般称为随机的快速排序。具体算法【参见教材】</li>
</ul>
<p>注意：
　    </p>
<pre><code>随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件，一般不可能导致最坏情况的发生。算法的随机化不仅仅适用于快速排序，也适用于其它需要数据随机分布的算法。
</code></pre><h3 id="（4）平均时间复杂度">（4）平均时间复杂度</h3>
<p>尽管快速排序的最坏时间为O(n2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。它的平均时间复杂度为O(nlgn)。</p>
<h3 id="（5）空间复杂度">（5）空间复杂度</h3>
<p>快速排序在系统内部需要一个栈来实现递归。若每次划分较为均匀，则其递归树的高度为O(lgn)，故递归后需栈空间为O(lgn)。最坏情况下，递归树的高度为O(n)，所需的栈空间为O(n)。</p>
<h3 id="（6）稳定性">（6）稳定性</h3>
<p>快速排序是非稳定的.</p>
<hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ul>
<li><p><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.4.htm" target="_blank" rel="external">快速排序—算法分析</a></p>
</li>
<li><p><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external">白话经典算法系列之六 快速排序 快速搞定</a></p>
</li>
<li><p><a href="http://blog.csdn.net/v_july_v/article/details/6116297" target="_blank" rel="external">快速排序算法</a></p>
</li>
</ul>
]]></content>
    
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析连续子向量,子数组和(一维，二维)问题]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%90%91%E9%87%8F(%E5%AD%90%E6%95%B0%E7%BB%84)%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>http://zhonghuan.info/2014/09/16/浅析连续子向量(子数组)和问题/</id>
    <published>2014-09-16T08:06:47.000Z</published>
    <updated>2015-04-11T02:26:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="最大连续子向量和">最大连续子向量和</h2>
<h4 id="问题描述：">问题描述：</h4>
<pre><code>输入是具有n个浮点数的向量x，输出这个向量的任何连续子向量中的最大和。
</code></pre><p>简单分析：子向量可以是一个空向量，空向量的和为0；如果向量的所有元素都是负数，最大子向量和就是0；</p>
<p>1 简单分析后，对于这个问题，我们立马能向想到的就是暴力算法，对所有0&lt;=i&lt;=j&lt;n的整数对进行迭代。对每个整数对(i,j)，程序都要计算x[i…j]的总和，并判断其是否大于当前的最大总和。</p>
<pre><code>解法<span class="number">1</span>：简单粗暴型
<span class="keyword">int</span> res=<span class="number">0</span>; <span class="comment">//答案</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ; i&lt;n;i++)
    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)
    {
        <span class="keyword">sum</span>=<span class="number">0</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++) 
            <span class="keyword">sum</span>+=x[k]
        res=max(res,<span class="keyword">sum</span>)    
    }
</code></pre><p>2 怎么看，上面的算法都是简单粗暴型，O(n^3)的时间复杂度实在不敢恭维，数据量一大，时间上实在不能容忍。那么有没有稍微优雅一点的？我们发现后面的部分有重复计算的，那么我们如何节省它~~一种就是从i开始往前加的时候，每次都记录下来。直接看代码：</p>
<pre><code>解法<span class="number">2</span>：
<span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//答案</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
{
    <span class="keyword">int</span> <span class="keyword">sum</span>=<span class="number">0</span>;  
    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)
    {
        <span class="keyword">sum</span>+=x[j];  <span class="comment">// sum 就是 x[i]至x[j]的和 </span>
        res=max(res,<span class="keyword">sum</span>);  
    }
}
</code></pre><p>3 上面的代码，虽然比简单粗暴型有一些改进，算法的时间复杂度降为O(n^2),还有一种O(n^2)的算法，令sum(i)表示x[0…i]的总和，然后，x[i] = sum(i) - sum(i-1);</p>
<pre><code>解法<span class="number">3</span>：
<span class="built_in">sum</span>[-<span class="number">1</span>]=<span class="number">0</span>
<span class="keyword">for</span> i=[<span class="number">0</span>,n)
    <span class="built_in">sum</span>[i]=<span class="built_in">sum</span>[i-<span class="number">1</span>]+x[i]
res=<span class="number">0</span> <span class="comment"> //储存答案</span>
<span class="keyword">for</span> i=[<span class="number">0</span>,n)
    <span class="keyword">for</span> j=[i,n)
        tem=<span class="built_in">sum</span>[j]-<span class="built_in">sum</span>[i-<span class="number">1</span>] 
        res=<span class="built_in">max</span>(res,tem)
</code></pre><p>4 O(n^2)的效率，我们还是觉得不行，可不可以优化一下，好了，我们可以采用分治的思想。要解决规模为n的问题，可递归地解决两个规模近似为n/2的子问题，然后对两个结果进行合并以得到整个问题的答案。将x划分为两个近似相等的子向量ab，在a和b中分别找出总和最大的子向量ma和mb，然后找到跨越a和b边界的最大子向量mc，返回三个总和中的最大者。通过观察发现mc在a中的部分是a中包含右边界的最大子向量，mc在b中的部分是b中包含左边界的最大子向量。伪代码如下：</p>
<pre><code>解法<span class="number">4</span>：
float maxsum(<span class="keyword">l</span>,<span class="keyword">u</span>)
    <span class="keyword">if</span>(<span class="keyword">l</span>&gt;<span class="keyword">u</span>)  <span class="keyword">return</span> <span class="number">0</span>  /* zero elements */
    <span class="keyword">if</span>(<span class="keyword">l</span>==<span class="keyword">u</span>)  <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>,<span class="keyword">x</span>[<span class="number">1</span>])  /* one element */
    <span class="keyword">m</span>=(<span class="keyword">l</span>+<span class="keyword">u</span>)/<span class="number">2</span>
    lmax=sum=<span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">i</span>=<span class="keyword">m</span>;<span class="keyword">i</span>&gt;=<span class="keyword">l</span>;<span class="keyword">i</span>--)  /* <span class="keyword">find</span> <span class="built_in">max</span> crossing <span class="keyword">to</span> <span class="keyword">left</span> */
        sum+=<span class="keyword">x</span>[<span class="keyword">i</span>]
        lmax=<span class="built_in">max</span>(lmax,sum)
    rmax=sum=<span class="number">0</span>
    <span class="keyword">for</span> <span class="keyword">i</span>=(<span class="keyword">m</span>,<span class="keyword">u</span>]  /* <span class="keyword">find</span> <span class="built_in">max</span> crossing <span class="keyword">to</span> <span class="keyword">right</span> */
        sum+=<span class="keyword">x</span>[<span class="keyword">i</span>]
        rmax=<span class="built_in">max</span>(rmax,sum)
    <span class="keyword">return</span>  <span class="built_in">max</span>(lmax+rmax,maxsum(<span class="keyword">l</span>,<span class="keyword">m</span>),maxsum(<span class="keyword">m</span>+<span class="number">1</span>,<span class="keyword">u</span>))
</code></pre><p>5 是否可以再优化一下?好了，其实可以。使用扫描算法：我们采用从x[0]开始扫描，一起到最右端x[n-1]，并记下所遇到的最大子向量总和（初始值设为0）。假设我们已解决了x[0,i-1]的问题，如何将其扩展到x[0…i]呢？前i个元素中，最大总和子数组要么在前i-1个元素中（用maxsofar存储），要么其结束位置为i（用maxendinghere存储）。</p>
<pre><code><span class="variable">maxsofar=</span><span class="number">0</span>
<span class="variable">maxendinghere=</span><span class="number">0</span>
for <span class="variable">i=</span>[<span class="number">0</span>,n)
    <span class="variable">maxendinghere=</span>max(maxendinghere+x[i],<span class="number">0</span>) <span class="comment">/* 计算前maxendinghere是结束位置为i-1的最大子向量的和 */</span>
    <span class="variable">maxsofar=</span>max(maxsofar,maxendinghere)
</code></pre><hr>
<p>几个重要的算法设计技术：</p>
<ul>
<li><p>保存状态，避免重复计算：</p>
</li>
<li><p>将信息预处理至数据结构：
　　</p>
</li>
<li>分治算法：</li>
</ul>
<hr>
<h2 id="子向量和接近于0">子向量和接近于0</h2>
<p>假设我们想要查找的是总和最接近0的子向量，而不是具有最大总和的子向量，该如何设计算法？</p>
<p>可初始化累加数组cum，使得cum[i]=x[0]+…+x[i]。如果cum[l-1]=cum[u]，那么子向量x[l…u]之和就为0.因此可以通过定位cum中最接近的两个元素来找出和最接近0的子向量。这可以通过排序数组，在O(nlogn)时间内完成。</p>
<hr>
<h2 id="收费站问题">收费站问题</h2>
<p>问题描述：</p>
<pre><code>收费公路由n个收费站之间的n-<span class="number">1</span>段公路组成，每一段都和行驶费用挂钩，仅使用费用数组按照<span class="keyword">O</span>(n)的时间，或者使用具有<span class="keyword">O</span>(n^<span class="number">2</span>)个项的表按照<span class="keyword">O</span>(<span class="number">1</span>)的时间描述任意两站之间的费用是无意义的，请设计一个结构，它需要<span class="keyword">O</span>(n)的空间，但它允许<span class="keyword">O</span>(<span class="number">1</span>)的时间复杂度求解。
</code></pre><p>驶过两个收费站，就是一段公路，汽车在行驶时，只能连续行驶，不会从这段公路跳到后面的公路。所以就符合连续子向量的求和问题。</p>
<p>可初始化累加数组cum，使得cum[i]=x[0]+…+x[i]，</p>
<p>对于收费站i和j，cum[j] - cum[i-1]就表示在i和j内行驶的路段费用，并且只占用 cum[n]的线性空间。</p>
<hr>
<h2 id="区间赋值问题">区间赋值问题</h2>
<p>对数组array[0…n-1]初始化为全0后，执行n次运算：for i = [l,u] {x[i] += v;}，其中l,u,v是每次运算的参数，0&lt;=l&lt;=u&lt;=n-1。直接用这个伪码需要O(n2)的时间，请给出更快的算法。</p>
<p>初始化y[0,…,n-1]为全0，对每个操作令y[l]+=v和y[u+1]-=v。则结束时x[i]=sigma{k=0 to i}(y[k])。正确性：只需证明每一次执行完操作之后该性质保持不变即可。注意这里的y[i]表示的意义</p>
<hr>
<h2 id="二维连续子数组和">二维连续子数组和</h2>
<p>二维数组连续的二维子数组的和怎么求，肯定是一个矩形，我们要遍历吗？？？<br>遍历的话估计复杂度扛不住吧。。如何遍历也是一个问题。</p>
<p><img src="http://img.blog.csdn.net/20130722170955390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这个时候我们可以把每一行看成是一个元素，这样就变成了一个纵向的一维数组了。</p>
<p><img src="http://img.blog.csdn.net/20130722171123781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这样对一维数组的遍历是和刚才一样的。而对于每一行我们遍历也是和一维是一样的。编码试一试</p>
<pre><code>　<span class="comment">//求二维数组的连续子数组之和的最大值</span>
　　<span class="keyword">int</span> MaxSum(<span class="keyword">int</span> (*<span class="built_in">array</span>)[N])
　　{
　　    <span class="keyword">int</span> i,j;
　　    <span class="keyword">int</span> MaxSum=-INFINITY;<span class="comment">//初始化</span>
　　    <span class="keyword">int</span> imin,imax,jmin,jmax;
　　    <span class="keyword">for</span>(imin=<span class="number">1</span>;imin&lt;=N;imin++)
　　{
　　        <span class="keyword">for</span>(imax=imin;imax&lt;=N;imax++)<span class="comment">//当成是遍历纵向的一维</span>
　　{
　　            <span class="keyword">for</span>(jmin=<span class="number">1</span>;jmin&lt;=M;jmin++)
　　{
　　                <span class="keyword">for</span>(jmax=jmin;jmax&lt;=M;jmax++)<span class="comment">//当成是遍历横向的一维</span>
　　                        MaxSum=MaxNum(MaxSum,PartSum(imin,jmin,imax,jmax));
　　            }
　　}
　　}            
　　    <span class="keyword">return</span> MaxSum;
　　}
　　
</code></pre><p>时间复杂度(N^2<em>M^2</em>O(PartSum))，如何求部分和PartSum呢？如果这个还是要遍历求的话，复杂度真是不敢看了。。<br>    求一维的时候我们求Sum[i-j]很好求，可是求二维的时候就变成了四个坐标了，不敢遍历求和了。我们可以先求部分和，把他当作已知的，这个时候遍历求的时候复杂度就是O(1)。<br>    如何求？我们定义一个部分和数组PartSum，其中PartSum[i][[j]代表了下标(0，0)，(0，j)，(i，0)，(i，j)包围的区间的和。</p>
<p><img src="http://img.blog.csdn.net/20130722171320921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>而此时下标(imin，jmin)，(imin，jmax)，(imax，jmin)，(imax，jmax)包围的区间和就等于</p>
<pre><code>PartSum[<span class="link_label">imax</span>][<span class="link_reference">[jmax</span>]-PartSum[<span class="link_label">imin-1</span>][<span class="link_reference">[jmax</span>]-PartSum[<span class="link_label">imax</span>][<span class="link_reference">[jmin-1</span>]+PartSum[<span class="link_label">imin-1</span>][<span class="link_reference">[jmin-1</span>]。
</code></pre><p><img src="http://img.blog.csdn.net/20130722171448515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这就是我们要求的PartSum(imin,jmin,imax,jmax)，接下来就是求PartSum数组了。如何求呢？<br>对于每一个PartSum[i][[j]都不是孤立的，都是和其他的有关系的。我们要找出这个关系式</p>
<p><img src="http://img.blog.csdn.net/20130722171535921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<pre><code>PartSum[<span class="link_label">i</span>][<span class="link_reference">[j</span>]=PartSum[<span class="link_label">i-1</span>][<span class="link_reference">[j</span>]+PartSum[<span class="link_label">i</span>][<span class="link_reference">[j-1</span>]-PartSum[<span class="link_label">i-1</span>][<span class="link_reference">[j-1</span>]+array[<span class="link_label">i</span>][<span class="link_reference">j</span>]。
</code></pre><p>这样求可以求出全部的PartSum[i][[j]，可是我们不要忽略了一点，PartSum[0][[0]=？对于边界值我们要处理好，而且下标要从1开始。对于PartSum[i][[0]和PartSum[0][[j]都要初始化0，而且array[i][j]的下标也是要-1，因为数组的下标是从0开始的。这是一个办法，不过我们也可以单独求PartSum[i][[0]和PartSum[0][[j]的值，连续相加即可，然后再求其他的也是可以的，空间复杂度也是一样。可是在4重遍历的时候对于PartSum[i][[0]和PartSum[0][[j]我们还是要另外处理，这就比较麻烦了。我们还是用预处理的方法来编码吧。。</p>
<pre><code>    int PartSum<span class="matrix">[N+<span class="number">1</span>]</span><span class="matrix">[M+<span class="number">1</span>]</span>;
　　    int <span class="built_in">i</span>,<span class="built_in">j</span>;
　　    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;=N;<span class="built_in">i</span>++)
　　        PartSum<span class="matrix">[i]</span><span class="matrix">[<span class="number">0</span>]</span>=<span class="number">0</span>;
　　    <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;=M;<span class="built_in">j</span>++)
　　        PartSum<span class="matrix">[<span class="number">0</span>]</span><span class="matrix">[j]</span>=<span class="number">0</span>;
　　    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=N;<span class="built_in">i</span>++)
　　        <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=M;<span class="built_in">j</span>++)
　　        PartSum<span class="matrix">[i]</span><span class="matrix">[j]</span>=PartSum<span class="matrix">[i-<span class="number">1</span>]</span><span class="matrix">[j]</span>+PartSum<span class="matrix">[i]</span><span class="matrix">[j-<span class="number">1</span>]</span>-PartSum<span class="matrix">[i-<span class="number">1</span>]</span><span class="matrix">[j-<span class="number">1</span>]</span>+array<span class="matrix">[i-<span class="number">1</span>]</span><span class="matrix">[j-<span class="number">1</span>]</span>;
</code></pre><p>OK，求得部分和之后我们就开始完善我们的编码了。记住一点，下标(imin,jmin)，(imin,jmax),(imax,jmin),(imax,jmax)包围的区间和等于<br>        PartSum[imax][[jmax]-PartSum[imin-1][[jmax]-PartSum[imax][[jmin-1]+PartSum[imin-1][[jmin-1]。<br>编码开始：</p>
<pre><code><span class="comment">//求二维数组的连续子数组之和的最大值</span>
<span class="keyword">int</span> MaxSum(<span class="keyword">int</span> (*<span class="built_in">array</span>)[N])
{
    <span class="keyword">int</span> PartSum[N+<span class="number">1</span>][M+<span class="number">1</span>];
    <span class="keyword">int</span> i,j;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N;i++)
        PartSum[i][<span class="number">0</span>]=<span class="number">0</span>;
    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=M;j++)
        PartSum[<span class="number">0</span>][j]=<span class="number">0</span>;
    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)
        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=M;j++)
            PartSum[i][j]=PartSum[i-<span class="number">1</span>][j]+PartSum[i][j-<span class="number">1</span>]-PartSum[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="built_in">array</span>[i-<span class="number">1</span>][j-<span class="number">1</span>];
    <span class="keyword">int</span> MaxSum=-INFINITY;<span class="comment">//初始化</span>
    <span class="keyword">int</span> imin,imax,jmin,jmax;
    <span class="keyword">for</span>(imin=<span class="number">1</span>;imin&lt;=N;imin++)
        <span class="keyword">for</span>(imax=imin;imax&lt;=N;imax++)
            <span class="keyword">for</span>(jmin=<span class="number">1</span>;jmin&lt;=M;jmin++)
                <span class="keyword">for</span>(jmax=jmin;jmax&lt;=M;jmax++)
                        MaxSum=MaxNum(MaxSum,PartSum[imax][jmax]-PartSum[imin-<span class="number">1</span>][jmax]-PartSum[imax][jmin-<span class="number">1</span>]+PartSum[imin-<span class="number">1</span>][jmin-<span class="number">1</span>]);

    <span class="keyword">return</span> MaxSum;
}
</code></pre><p>时间复杂度是O(N^2*M^2)，有点坑啊。想一想一维的时候我们用DP来做，这个也可以吗？可以的。我们把每一列看成一个元素。这样对于遍历的行区间，我们就可以当成一维来做。</p>
<p><img src="http://img.blog.csdn.net/20130722171750125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>对于imin和imax之间的每一列，就相当于一维的一个元素。</p>
<p>假设这个一维数组是BC，则BC[j]=array[imin][j]+….+array[imax][j]，问题就变成了求BC数组的连续子数组之和的最大值了。而根据刚才求的部分和，我们可以知道对于imin行和imax行之间的区间第j列的值是</p>
<p>BC(PartSum,imin,imax,j)=PartSum[imax][j]-PartSum[imin-1][j]-PartSum[imax][j-1]+PartSum[imin-1][j-1].（此时BC是一个函数）<br>OK，编码开始</p>
<pre><code><span class="comment">//求二维数组的连续子数组之和的最大值</span>
<span class="keyword">int</span> MaxSum(<span class="keyword">int</span> (*array)[N])
{
    <span class="keyword">int</span> PartSum[N+<span class="number">1</span>][M+<span class="number">1</span>];
    <span class="keyword">int</span> i,j;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N;i++)
        PartSum[i][<span class="number">0</span>]=<span class="number">0</span>;
    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=M;j++)
        PartSum[<span class="number">0</span>][j]=<span class="number">0</span>;
    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)
        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=M;j++)
            PartSum[i][j]=PartSum[i-<span class="number">1</span>][j]+PartSum[i][j-<span class="number">1</span>]-PartSum[i-<span class="number">1</span>][j-<span class="number">1</span>]+array[i-<span class="number">1</span>][j-<span class="number">1</span>];
    <span class="keyword">int</span> MaxSum=-INFINITY;
    <span class="keyword">int</span> Start,All;
    <span class="keyword">int</span> imin,imax;
    <span class="keyword">for</span>(imin=<span class="number">1</span>;imin&lt;=N;imin++)
    {
        <span class="keyword">for</span>(imax=imin;imax&lt;=N;imax++)
        {
            Start=BC(PartSum,imin,imax,M);
            All=BC(PartSum,imin,imax,M);
            <span class="keyword">for</span>(j=M-<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)
            {
                <span class="keyword">if</span>(Start&gt;<span class="number">0</span>)
                    Start+=BC(PartSum,imin,imax,j);
                <span class="keyword">else</span>
                    Start=BC(PartSum,imin,imax,j);
                <span class="keyword">if</span>(Start&gt;All)
                    All=Start;
            }
            <span class="keyword">if</span>(All&gt;MaxSum)
                MaxSum=All;
        }
    }
    <span class="keyword">return</span> MaxSum;
}

<span class="keyword">int</span> BC(<span class="keyword">int</span> (*PartSum)[N+<span class="number">1</span>],<span class="keyword">int</span> imin,<span class="keyword">int</span> imax,<span class="keyword">int</span> j) <span class="comment">//imin--imax第j列的和</span>
{
    <span class="keyword">int</span> <span class="keyword">value</span>;
    <span class="keyword">value</span>=PartSum[imax][j]-PartSum[imin-<span class="number">1</span>][j]-PartSum[imax][j-<span class="number">1</span>]+PartSum[imin-<span class="number">1</span>][j-<span class="number">1</span>];
    <span class="keyword">return</span> <span class="keyword">value</span>;
}
</code></pre><p>时间辅助度降到O(N<em>M</em>min(M,N)),差不多O(N^3)吧。</p>
<hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ul>
<li><p>Programming pearls <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/zhoudaxia/article/details/5649991" target="_blank" rel="external">最大子序列问题</a></p>
</li>
<li><p><a href="http://blog.csdn.net/liangbopirates/article/details/9411335" target="_blank" rel="external">求数组的连续子数组之和的最大值（一维二维）</a></p>
</li>
</ul>
]]></content>
    
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析单调队列]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>http://zhonghuan.info/2014/09/16/浅析单调队列/</id>
    <published>2014-09-16T08:04:36.000Z</published>
    <updated>2015-04-11T02:26:36.000Z</updated>
    <content type="html"><![CDATA[<p>大家应该了解什么是队列，那么在队列前面加上“单调”，意思也是显而易见的，就是这个队列是从前往后单调递增或者单调递减的。</p>
<p>如：{a1,a2,a3,a4……an}满足a1&lt;=a2&lt;=a3……&lt;=an,a序列便是单调递增序列。同理递减队列也是存在的。</p>
<pre><code>单调队列的出现可以简化问题，队首元素便是最大（小）值，这样，选取最大（小）值的复杂度便为o（1），由于队列的性质，每个元素入队一次，出队一次，维护队列的复杂度均摊下来便是o（1）。
</code></pre><p>如何维护单调队列呢，以单调递增序列为例：</p>
<ol>
<li><p>如果队列的长度一定，先判断队首元素是否在规定范围内，如果超范围则增长队首。</p>
</li>
<li><p>每次加入元素时和队尾比较，如果当前元素小于队尾且队列非空，则减小尾指针，队尾元素依次出队，直到满足队列的调性为止。</p>
</li>
</ol>
<p>例如：</p>
<pre><code><span class="input"><span class="prompt">队列是一个单调递增的队列：
1 ，5 ， 7 ， 9。    现在要插入一个 6；
因为 9 &gt;</span> <span class="number">6</span> ,所以  <span class="number">9</span>  出队列</span>
<span class="input"><span class="prompt">---&gt;</span> <span class="number">1</span> ， <span class="number">5</span>， <span class="number">7</span>。   </span>
<span class="input"><span class="prompt">因为要 7 &gt;</span> <span class="number">6</span> ,所以 <span class="number">7</span> 出队列</span>
<span class="input"><span class="prompt">---&gt;</span> <span class="number">1</span>, <span class="number">5</span> . </span>
<span class="input"><span class="prompt">6放在队列尾部,最终队列变为：
---&gt;</span> <span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>.</span>
</code></pre><p>说完了单调队列的性质，那么我们该如何运用呢？</p>
<hr>
<h2 id="简单的单调队列的应用：">简单的单调队列的应用：</h2>
<hr>
<h3 id="1-果子合并问题">1.果子合并问题</h3>
<p>【问题描述】<br> 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 </p>
<p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 </p>
<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 </p>
<p>例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。 </p>
<p>【输入文件】 </p>
<p> 输入文件fruit.in包括两行，第一行是一个整数n(1&lt;＝n&lt;=10000)，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai(1&lt;＝ai&lt;=20000)是第i种果子的数目。 </p>
<p>【输出文件】 </p>
<p> 输出文件fruit.out包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于231。 </p>
<p>【样例输入】 </p>
<pre><code>3 
1 2 9 
</code></pre><p>【样例输出】 </p>
<pre><code>15 
</code></pre><p>【数据规模】 </p>
<pre><code><span class="xml">对于30％的数据，保证有n<span class="tag">&lt;<span class="title">=1000：</span> 
对于<span class="attribute">50</span>％的数据，保证有<span class="attribute">n</span>&lt;=<span class="value">5000；</span> 
对于全部的数据，保证有<span class="attribute">n</span>&lt;=<span class="value">10000。</span></span></span>
</code></pre><p>这个题目非常的经典，发放也很多，可以采用快排或者堆，其思想都是选取当前最小的两个堆进行合并。复杂度均为O(nlogn)，如果用有序队列维护，时间复杂度为O（n）。</p>
<p>每次选取进行合并的两堆，不是最先给定的堆，就是合并最初堆若干次后得到的新堆，所以需要维护两个单调递增队列，一个队列存最初给定的堆的值（1），一个存合并后得到的新值（2）。</p>
<p>每次选择时有三种状态：</p>
<ol>
<li><p>选取队一的队首两个</p>
</li>
<li><p>选取队2的的队首两个</p>
</li>
<li><p>选取二者队首各一个</p>
</li>
</ol>
<p>只需对每个队列的指针做相应的更改。</p>
<p>特别注意初始化。</p>
<p>这道题很好的运用了题目中决策的单调性，对初始对经行排序，保证了其单调性。而对于新产生的堆来说，一旦有新元素加入其中，则新元素一定大于原有元素。（很显然，由于队列1的单调性）。</p>
<p>也就是说，队列的单调性是自然而然的。是不需要维护的。要善于观察分析，才能发现。</p>
<hr>
<h3 id="Window">Window</h3>
<h4 id="_poj2823_"><a href="http://poj.org/problem?id=2823" target="_blank" rel="external"> poj2823 </a></h4>
<p>Description</p>
<p>An array of size n ≤ 106 is given to you. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves rightwards by one position. Following is an example: </p>
<p>The array is [1 3 -1 -3 5 3 6 7], and k is 3.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Window position</th>
<th style="text-align:center">Minimum value</th>
<th style="text-align:center">Maximum value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[1  3  -1] -3  5  3  6  7</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">1 [3  -1  -3] 5  3  6  7</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">1  3 [-1  -3  5] 3  6  7</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1 [-3  5  3] 6  7</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1  -3 [5  3  6] 7</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1  -3  5 [3  6  7]</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>Your task is to determine the maximum and minimum values in the sliding window at each position. </p>
<p>Input</p>
<p>The input consists of two lines. The first line contains two integers n and k which are the lengths of the array and the sliding window. There are n integers in the second line. </p>
<p>Output</p>
<p>There are two lines in the output. The first line gives the minimum values in the window at each position, from left to right, respectively. The second line gives the maximum values.<br>Sample Input</p>
<pre><code>8 3
1 3 -1 -3 5 3 6 7
</code></pre><p>Sample Output</p>
<pre><code>-<span class="ruby"><span class="number">1</span> -<span class="number">3</span> -<span class="number">3</span> -<span class="number">3</span> <span class="number">3</span> <span class="number">3</span>
</span>3 3 5 5 6 7
</code></pre><p>题目大意：给出一组数，一个固定大小的窗体在这个数组上滑动，要求出每次滑动该窗体内的最大值和最小值。</p>
<p>这就是典型的单调队列，单调队列的作用就在此。单调队列的队首为区间内的最值，可是整个队列不用保持单调。</p>
<p>用两个队列分别处理最大值和最小值，在此说明一下最大值；</p>
<p>往队列中加入值num时，从队尾開始扫，直到遇到一个小于num的d值，将num插入d的后一位。之后的元素所有无效化（无论后面的元素即可）。查找最大值的时候，从队首開始找，假设该元素没在此时的区间的话，查找下一个，直到找到满足条件的第一个元素，这个元素便是最值。</p>
<p>求最小值和最大值大同小异，仅仅须要将加入值num的条件改一下就可以。</p>
<hr>
<h3 id="广告印刷">广告印刷</h3>
<p>【问题描述】</p>
<p>　　最近，afy决定给TOJ印刷广告，广告牌是刷在城市的建筑物上的，城市里有紧靠着的N个建筑。afy决定在上面找一块尽可能大的矩形放置广告牌。我们假设每个建筑物都有一个高度，从左到右给出每个建筑物的高度H1,H2…HN，且0&lt;Hi&lt;=1,000,000,000，并且我们假设每个建筑物的宽度均为1。要求输出广告牌的最大面积。</p>
<p>【输入文件】</p>
<p>第一行是一个数n (n&lt;= 400,000 ）</p>
<p>第二行是n个数，分别表示每个建筑物高度H1,H2…HN，且0&lt;Hi&lt;=1,000,000,000。</p>
<p>【输出文件】</p>
<p>输出文件 ad.out 中一共有一行，表示广告牌的最大面积。</p>
<p>【输入样例】</p>
<pre><code>6

5 8 4 4 8 4
</code></pre><p>【输出样例】</p>
<pre><code>24
</code></pre><p>【分析】</p>
<p>最终的广告牌一定等于某个建筑物的高度×其能达到的最大长度</p>
<p>现在，建筑物的高度已知，现在只需要知道每个高度能达到的最大长度是多少。由于n是400000，我们只能用O（n）或O（nlogn）的算法。可以使用rmq，在后边的论文中会讲到。</p>
<p>现在讲时间复杂度为o（n）的单调队列的方法。</p>
<p>继续上边的思路，对于每个建筑物，只需要找到其能够扩展到的最大宽度即可。也就是这个建筑物的左右两边的比它低或等于它的建筑物个数。</p>
<p>如何用单调队列呢？</p>
<p>我们从1~n一次进队，维护一个单调递减序列。每次加入元素后维护其单调性，当然这样做必然会使一些元素出队，出队的元素一定要比当前加入的元素小，也就是说当前元素就是出队的元素能在右侧达到的最远的建筑物！</p>
<p>注意，要让h[n+1]=0并且让该元素入队一次（会使当前队列中的所有元素出队），保证每个元素都有其“右极限”的值。</p>
<p>要求“左极限”同理，只需从n~0循环即可，注意0</p>
<p>这道题是对单调队列的变形使用。由于问题的结果具有单调性，很好的利用出队元素的特性.</p>
<hr>
<h2 id="单调队列在动态规划中的应用">单调队列在动态规划中的应用</h2>
<p> 做动态规划时常常会见到形如这样的转移方程：</p>
<p>　　f[x] = max or min{g(k) | b[x] &lt;= k &lt; x} + w[x]</p>
<p>　　(其中b[x]随x单调不降，即b<a href="http://www.cnblogs.com/neverforget/archive/2011/10/13/ll.html" target="_blank" rel="external">1</a>&lt;=b<a href="http://blog.csdn.net/job_yi/article/details/10103509" target="_blank" rel="external">2</a>&lt;=b[3]&lt;=…&lt;=b[n])</p>
<p>　　(g[k]表示一个和k或f[k]有关的函数，w[x]表示一个和x有关的函数)</p>
<p>　　这个方程怎样求解呢？我们注意到这样一个性质：如果存在两个数j, k，使得j &lt;= k，而且g(k) &lt;= g(j)，则决策j是毫无用处的。因为根据b[x]单调的特性，如果j可以作为合法决策，那么k一定可以作为合法决策，又因为k比j要优，（注意：在这个经典模型中，“优”是绝对的，是与当前正在计算的状态无关的），所以说，如果把待决策表中的决策按照k排序的话，则g(k)必然是不降的。</p>
<p>　　这样，就引导我们使用一个单调队列来维护决策表。对于每一个状态f(x)来说，计算过程分为以下几步：</p>
<ol>
<li><p>队首元素出队，直到队首元素在给定的范围中。</p>
</li>
<li><p>此时，队首元素就是状态f(x)的最优决策，</p>
</li>
<li><p>计算g(x)，并将其插入到单调队列的尾部，同时维持队列的单调性（不断地出队，直到队列单调为止）。</p>
</li>
</ol>
<p>　　重复上述步骤直到所有的函数值均被计算出来。不难看出这样的算法均摊时间复杂度是O(1)的。因此求解f(x)的时间复杂度从O(n^2)降到了O(n)。</p>
<p>单调队列指一个队列中的所有的数符合单调性（单调增或单调减），在信息学竞赛的一些题目上应用，会减少时间复杂度</p>
<p>单调队列的每个元素一般会存储两个值：</p>
<p>1.在原数列中的位置（下标）</p>
<p>2.该元素在动态规划中的状态值（价值）</p>
<p>单调队列同时保证这两个值单调。</p>
<hr>
<p> 烽火传递</p>
<p>描述 Description  </p>
<p>烽火台又称烽燧，是重要的防御设施，一般建在险要处或交通要道上。一旦有敌情发生，白天燃烧柴草，通过浓烟表达信息：夜晚燃烧干柴，以火光传递军情。在某两座城市之间有n个烽火台，每个烽火台发出信号都有一定的代价。为了使情报准确的传递，在m个烽火台中至少要有一个发出信号。现输入n、m和每个烽火台发出的信号的代价，请计算总共最少需要话费多少代价，才能使敌军来袭之时，情报能在这两座城市之间准确的传递！！！</p>
<p>输入格式 Input Format</p>
<pre><code>     第一行有两个数n,m分别表示n个烽火台，在m个烽火台中至少要有一个发出信号。

     第二行为n个数，表示每一个烽火台的代价。
</code></pre><p>输出格式 Output Format     </p>
<pre><code>    一个数，即最小代价。       
</code></pre><p>样例</p>
<p>输入：</p>
<pre><code>5 3    
1 2 5 6 2
</code></pre><p>输出：</p>
<pre><code>4
</code></pre><p>时间限制 Time Limitation    </p>
<pre><code>    各个测试点1s
</code></pre><p>注释 Hint      </p>
<pre><code><span class="attribute">    1&lt;</span>=<span class="string">n,m&lt;=1,000,000</span>
</code></pre><p>分析</p>
<p>要用动态规划的方法解决。我们可以写出这样的方程f[i]:=min{f[j]}+a[i]（i-m&lt;=j&lt;i-1）（因为要保证i之前的3个中必须存在被点亮的烽火台）。单纯这样循环会造成超时。</p>
<p>我们想到了用单调队列进行优化，由于随着i的循环，每次只有一个i进入决策区间也只有一个i出决策区间，由于每次选取决策区间中的最小值，所以维护一个单调递增序列，每次取出队首元素即可。</p>
<p>为什么可以将队尾元素无情的删去呢？由于后进队的序列同时满足在原序列中的位置更靠后和其在动态规划中的价值更大。这样选取这个元素就要比选取之前的任何一个决策要优，所以之前被删掉的决策都是无用的。</p>
<p>这道题的本质就是用单调队列维护了决策本身的价值和其在原序列中位置的同时单调。</p>
<p>要特别注意单调队列中的值是决策在原决策序列中的位置。</p>
<hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ul>
<li><p><a href="http://www.cnblogs.com/neverforget/archive/2011/10/13/ll.html" target="_blank" rel="external">单调队列及其应用</a>  <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/job_yi/article/details/10103509" target="_blank" rel="external">合并果子【单调队列】</a></p>
</li>
</ul>
]]></content>
    
    
      <category term="单调队列" scheme="http://zhonghuan.info/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[“浅析kmp算法”]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E2%80%9C%E6%B5%85%E6%9E%90kmp%E7%AE%97%E6%B3%95%E2%80%9D/"/>
    <id>http://zhonghuan.info/2014/09/16/“浅析kmp算法”/</id>
    <published>2014-09-16T08:00:57.000Z</published>
    <updated>2015-04-11T02:27:46.000Z</updated>
    <content type="html"><![CDATA[<p>首先，KMP是一个字符串匹配算法，什么是字符串匹配呢？简单地说，有一个字符串“BBC ABCDAB ABCDABCDABDE”，我想知道这个字符串里面是否有“ABCDABD”；我想，你的脑海中马上就浮现了一个简单的暴力算法，是的，它也有名字，叫做暴力匹配，就是从头开始进行匹配，如果不行的话，就从主字符串的下一个继续。看下面的图结合文字会更清晰些：</p>
<hr>
<h2 id="暴力匹配：">暴力匹配：</h2>
<p>1 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf1.png" alt=""></p>
<p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<p>2 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf2.png" alt=""><br>因为B与A不匹配，搜索词再往后移。</p>
<p>3 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf3.png" alt=""><br>就这样，直到字符串有一个字符，与搜索词的第一个字符相同。</p>
<p>4 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf4.png" alt=""><br>接着比较字符串和搜索词的下一个字符，还是相同。</p>
<p>5 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf5.png" alt=""><br>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<p>6 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf6.png" alt=""><br>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。</p>
<p>虽然这样做可行，但是你有没有想过这样的效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<hr>
<h2 id="真前缀和真后缀，部分匹配值">真前缀和真后缀，部分匹配值</h2>
<p>上面说了，暴力匹配的效率是非常低下的，但是我们有什么办法让效率提升呢？让我们先来了解三个概念，“真前缀”和“真后缀”；这个比较好理解，看下面就可以理解了。</p>
<pre><code>　　－　<span class="string">"A"</span>的真前缀和真后缀都为空集，共有元素的长度为<span class="number">0</span>；
　　－　<span class="string">"AB"</span>的真前缀为[<span class="literal">A</span>]，真后缀为[B]，共有元素的长度为<span class="number">0</span>；
　　－　<span class="string">"ABC"</span>的真前缀为[<span class="literal">A</span>, AB]，真后缀为[BC, C]，共有元素的长度<span class="number">0</span>；
　　－　<span class="string">"ABCD"</span>的真前缀为[<span class="literal">A</span>, AB, ABC]，真后缀为[BCD, CD, D]，共有元素的长度为<span class="number">0</span>；
　　－　<span class="string">"ABCDA"</span>的真前缀为[<span class="literal">A</span>, AB, ABC, ABCD]，真后缀为[BCDA, CDA, DA, <span class="literal">A</span>]，共有元素为<span class="string">"A"</span>，长度为<span class="number">1</span>；
　　－　<span class="string">"ABCDAB"</span>的真前缀为[<span class="literal">A</span>, AB, ABC, ABCD, ABCDA]，真后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为<span class="string">"AB"</span>，长度为<span class="number">2</span>；
　　－　<span class="string">"ABCDABD"</span>的真前缀为[<span class="literal">A</span>, AB, ABC, ABCD, ABCDA, ABCDAB]，真后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为<span class="number">0</span>。
</code></pre><p>从上面的例子可以体会到吧，真前缀就是从字符串第一个字符开始的所有字符串，但是不包括它自身；对于真后缀同理。</p>
<p>那么什么是部分匹配值呢？注意到上面提到的共有元素的长度了吗？部分匹配值的意思就是当前串的真前缀和真后缀中字符串相同的最大长度。“AB”的真前缀和真后缀中没有相同的，所以部分匹配值是0；“ABAB”的部分匹配值是2，因为真前缀中的“AB”和真后缀中的“AB”匹配，长度为2，所以部分匹配值是2。</p>
<hr>
<h2 id="如何使用部分匹配值呢？">如何使用部分匹配值呢？</h2>
<p>让我们来看一些前面的例子，在“BBC ABCDAB ABCDABCDABDE”中匹配“ABCDABD”。</p>
<p>首先看一下ABCDABD的部分匹配表：</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial1.png" alt=""></p>
<p>部分匹配表中的每一个值，对应的都是每一个字符为结尾的子串的部分匹配值。像“AB”，部分匹配值是0，所以对应的表里的值是0；“ABCDAB”，部分匹配值是2，所以对应的表里的值是2；</p>
<p>那么我们如何来用它呢？上面的暴力匹配我们说了，当ABCDABD的最后一个D和“ ”不匹配时，暴力匹配方式只会把ABCDABD右移一位，然后继续匹配。我们前面也说了，这样的方式没有充分利用一些信息。</p>
<p>那么我们该如何利用上面的信息呢？</p>
<p>比如前面我们说的情况，看下面的图：<br><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial2.png" alt=""></p>
<p>前面的这个时候，我们只是让“ABCDABD”右移一位。但是有没有发现，其实前面已经匹配上的“ABCDAB”这一部分的信息都知道，所以我们知道“ABCDAB”右移一位依然无法匹配，这个时候，我们只需要考虑ABCDAB的真前缀和真后缀匹配最多，如果我们知道这个真前缀和真后缀，那么我们就知道如何移动了。只需要移动至真前缀和真后缀部分匹配即可。而这里就是需要考虑部分匹配值了。</p>
<p>为什么是这样呢？我们可以简单地证明一下。我们知道“ABCDAB”的部分匹配值，2，也就是说真前缀和真后缀最大的匹配长度是“AB”这一部分。我们只需要将“ABCDAB”的前缀的“AB”移动至和后缀的“AB”匹配。假设我们不移动到它们匹配，在前面部分也可能匹配，那么它们的部分匹配值应该更大，但是这里最大就是2了。所以，假设不成立。所以我们只需要将最长的 真前缀和真后缀 匹配即可。</p>
<p>匹配的时候，我们可以利用部分匹配值。</p>
<p><strong><em>移动位数 = 已匹配的字符数 - 对应的部分匹配值</em></strong></p>
<p>对于“ABCDAB”，部分匹配值2，6-2=4；所以将搜索词向后移动4位即可。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial3.png" alt=""></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial4.png" alt=""></p>
<p>因为空格与A不匹配，继续后移一位。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial5.png" alt=""></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial6.png" alt=""></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<hr>
<h2 id="寻找部分匹配值">寻找部分匹配值</h2>
<p>现在的问题是，我们如何来寻求这个部分匹配值，在上面的过程中，我们可以发现，只要我们知道部分匹配值了，就能够让匹配的速度加快。而对于部分匹配值，我们关心的其实就是那个搜索词。所以从搜索词入手。</p>
<p>我们定义这样一个数组next[]，T标示匹配字符串，P标示搜索词。</p>
<p>那么next数组表示什么呢？看下面的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">搜索词</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">D</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>和上面的部分匹配表对比一下，你会发现，next数组就是 部分匹配值   整体向右移动了一位， 然后初始值赋值为 -1。</p>
<p>其实next数组也有含义，next[j]的值表示，当P[j] != T[i]时，指针 j 的下一步移动位置。</p>
<p>当j=0时不匹配怎么办？这个时候next[j]= -1；表示T需要左移1位。</p>
<p>所以当 P[j] != T[i] 时, 另 j = next[j] ，然后继续匹配。</p>
<p>当 P[j] == T[i] 时，i和j 分别都前进一位。</p>
<p>那么next数组该怎么求解呢？</p>
<p>当P[k] == P[i] 时，有 next[j+1] = next[j] +1;</p>
<p>当P[k] != P[i] 时，有 k = next[k]; 然后继续匹配。</p>
<p>如果 k == -1； 那么这个时候，表示P的第0字符都和现在的第i个字符不匹配，则 next[i] = 0; k++, i++;</p>
<p>所以，综上，便有了下面的程序。下面的getNext是获得next数组，KMP是进行匹配，下面的程序是poj3461 的示例程序。</p>
<pre><code>import  java.util.Scanner;

<span class="keyword">public</span> <span class="keyword">class</span> Main{

    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">getNext</span>(String P){
        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length()];  <span class="comment">// next 数组表示的是当 P[i]和P[k]不匹配时，k应该跳转到哪一个位置</span>
                                            <span class="comment">//这里的i时后缀指针，  k是前缀指针</span>

        next[<span class="number">0</span>]=-<span class="number">1</span>;  <span class="comment">// 因为开头的比较特殊，如果它不匹配，那么移动的应该是T，T应该左移,-1标示T左移</span>

        <span class="keyword">int</span> i=<span class="number">0</span>,k=-<span class="number">1</span>;

        <span class="keyword">while</span>(i &lt; P.length()-<span class="number">1</span>)
        {
            <span class="keyword">if</span>(k&lt;<span class="number">0</span> || P.charAt(i) == P.charAt(k))
            {
                next[++i] = ++k;
            }<span class="keyword">else</span>
                k = next[k];
        }

        <span class="keyword">return</span> next;

    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span>(String T, String P){

        <span class="keyword">int</span> res=<span class="number">0</span>;

        <span class="keyword">int</span>[] next = getNext(P);

        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;

        <span class="keyword">while</span>(<span class="keyword">true</span>)
        {

            <span class="keyword">if</span>(i &gt;= T.length())
                <span class="keyword">break</span>;
            <span class="keyword">if</span>( j==-<span class="number">1</span> || T.charAt(i) == P.charAt(j))
            {
                j++;
                <span class="keyword">if</span>(j == P.length())
                {
                    res++;
                    j = next[j-<span class="number">1</span>];
                }<span class="keyword">else</span>
                    i++;
            }<span class="keyword">else</span>
                j = next[j];

        }

        <span class="keyword">return</span> res;
    }


    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){
        Scanner scan = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);
        <span class="keyword">int</span> n = scan.nextInt();
        scan.nextLine();
        <span class="keyword">while</span>(n&gt;<span class="number">0</span>){
            String P = scan.nextLine();
            String T = scan.nextLine();

            System.<span class="keyword">out</span>.println(KMP(T,P));

            n--;
        }

    }

    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span>(String args[]){

        <span class="keyword">new</span> Main().run();

    }
}
</code></pre><hr>
<h2 id="拓展">拓展</h2>
<h3 id="最小覆盖字串">最小覆盖字串</h3>
<p>最小覆盖子串（串尾多一小段时，用前缀覆盖）长度为n-next[n]（n-pre[n]），n为串长。</p>
<p>证明分两部分：</p>
<p>１－长为n-next[n]的前缀必为覆盖子串。</p>
<p>当next[n]&lt;n-next[n]时，如图a，长为next[n]的前缀A与长为next[n]的后缀B相等，故长为n-next[n]的前缀C必覆盖后缀B；</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_least1.gif" alt=""></p>
<p>当next[n]&gt;n-next[n]时，如图b，将原串X向后移n-next[n]个单位得到Y串，根据next的定义，知长为next[n]的后缀串A与长为前缀串B相等，X串中的长为n-next[n]的前缀C与Y串中的前缀D相等，而X串中的串E又与Y串中的D相等……可见X串中的长为n-next[n]的前缀C可覆盖全串。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_least2.gif" alt=""></p>
<p>２－长为n-next[n]的前缀是最短的。</p>
<p>如图c，串A是长为n-next[n]的前缀，串B是长为next[n]的后缀，假设存在长度小于n-next[n]的前缀C能覆盖全串，则将原串X截去前面一段C，得到新串Ｙ，则Ｙ必与原串长度大于next[n]的前缀相等，与next数组的定义（使str[1..i]前k个字母与后k个字母相等的最大k值。）矛盾。得证！有人问，为什么Ｙ与原串长大于next[n]的前缀相等？由假设知原串的构成必为CCC……E（E为C的前缀），串Ｙ的构成必为CC……E（比原串少一个Ｃ），懂了吧！</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_least3.gif" alt=""></p>
<p>一个字符串A(1 &lt;= |A| &lt;= 1000000)可以写成某一个子串B重复N次所得，记为A = B^N，求最大的N。</p>
<p>算法分析：</p>
<p>令L = |A|，容易发现，用KMP自匹配后L - p[L]即得到最小覆盖子串的长度。<br>下面我们要证明一个问题：一个字符串的覆盖子串长度，一定是它的最小覆盖子串长度的倍数。<br>设最小覆盖子串长度d整除L, 假设存在u &gt; d满足u整除L且d不整除u。<br>易得，A<em>i = A</em>(i + d)，A<em>i = A</em>(i + u)，则A<em>(i + d) = A</em>(i + u)，即A<em>i = A</em>(i + u - d)，不断进行可得到A_i = A(i + u - kd)（k为正整数）。<br>因为d不整除u，那么必然存在k使得0 &lt; u - kd &lt; d，与d是最小循环子串长度矛盾。<br>所以，最小覆盖子串长度若为L的约数则得解否则输出1。时间复杂度O(L)。</p>
<p>最小覆盖字串的例题  poj2406   ， 代码可以参考以下：</p>
<pre><code>import  java.util.Scanner;

<span class="keyword">public</span> <span class="keyword">class</span> Main{

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(String P){
        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length()+<span class="number">10</span>];  <span class="comment">// next 数组表示的是当 P[i]和P[k]不匹配时，k应该跳转到哪一个位置</span>
                                            <span class="comment">//这里的i时后缀指针，  k是前缀指针</span>
        next[<span class="number">0</span>]=-<span class="number">1</span>;  <span class="comment">// 因为开头的比较特殊，如果它不匹配，那么移动的应该是T，T应该左移,-1标示T左移</span>

        <span class="keyword">int</span> i=<span class="number">0</span>,k=-<span class="number">1</span>;

        <span class="keyword">while</span>(i &lt; P.length())
        {
            <span class="keyword">if</span>(k&lt;<span class="number">0</span> || P.charAt(i) == P.charAt(k))
            {
                next[++i] = ++k;
            }<span class="keyword">else</span>
                k = next[k];
        }

        <span class="keyword">return</span> P.length()-next[P.length()];
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){
        Scanner scan = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);
        <span class="keyword">while</span>(scan.hasNext()){
            String P = scan.nextLine();

            <span class="keyword">if</span>(P.charAt(<span class="number">0</span>)==<span class="string">'.'</span>)
                <span class="keyword">break</span>;

            <span class="keyword">int</span> t = getNext(P);
            <span class="keyword">int</span> len = P.length();

            <span class="keyword">if</span>(len%t == <span class="number">0</span>)
            {
                System.<span class="keyword">out</span>.println(len/t);
            }<span class="keyword">else</span>
                System.<span class="keyword">out</span>.println(<span class="number">1</span>);
        }

    }

    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span>(String args[]){

        <span class="keyword">new</span> Main().run();

    }
}
</code></pre><hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p><a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="external">The Knuth-Morris-Pratt Algorithm in my own words</a> : <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="external">字符串匹配的KMP算法</a> : <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">从头到尾彻底理解KMP</a> : <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="external">详解KMP算法</a></p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Knuth–Morris–Pratt algorithm</a> <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/fjsd155/article/details/6866991" target="_blank" rel="external">KMP与最小覆盖子串</a> </p>
</li>
</ul>
]]></content>
    
    
      <category term="KMP" scheme="http://zhonghuan.info/tags/KMP/"/>
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="字符串匹配" scheme="http://zhonghuan.info/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式和python的re模块]]></title>
    <link href="http://zhonghuan.info/2014/09/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cpython%E7%9A%84re%E6%A8%A1%E5%9D%97/"/>
    <id>http://zhonghuan.info/2014/09/04/正则表达式和python的re模块/</id>
    <published>2014-09-04T15:04:30.000Z</published>
    <updated>2015-04-11T02:25:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是正则表达式">什么是正则表达式</h2>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。正则表达式就是记录文本规则的代码，换句话说，正则表达式是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”）。模式描述在搜索文本时要匹配的一个或多个字符串。</p>
<pre><code>字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。
</code></pre><p>假设你要在英文小说中查找Hi，那么使用的正则表达式就是<code>Hi</code>，这个很简单吧，不过，通常处理正则表达式的工具（例如后面会提到的python的re模块）会提供忽略大小写的选项。</p>
<p>不幸的是，很多单词里都包含了很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\bhi\b</code>。</p>
<pre><code><span class="command">\b</span>是正则表达式规定的一个特殊代码（这里称为元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。
</code></pre><p>假设你要找的Hi后面不远处有一个ZH，那么可以用<code>\bhi\b.*\bZH\b</code>.</p>
<pre><code>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<span class="keyword">*</span>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定<span class="keyword">*</span>前边的内容可以连续重复使用任意次以使整个表达式得到匹配,例如，zo<span class="keyword">*</span> 能匹配 <span class="string">"z"</span> 以及 <span class="string">"zoo"</span>等 。
</code></pre><p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：<br><code>0\d\d-\d\d\d\d\d\d\d\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p>
<p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。</p>
<p>下面来看看更多的例子：<br><code>\ba\w*\b</code>匹配以字母a开头的单词——先是某个单词开始处(<code>\b</code>)，然后是字母a,然后是任意数量的字母或数字(<code>\w*</code>)，最后是单词结束处(<code>\b</code>)。<br>好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的<code>\w</code>。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)<br><code>\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<code>*</code>类似的元字符，不同的是*匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。<br><code>\b\w{6}\b</code> 匹配刚好6个字符的单词。</p>
<hr>
<h2 id="元字符使用一览表：">元字符使用一览表：</h2>
<p>上面介绍了部分的metacharacter，下面给出元字符一览表，使用时可以查找。</p>
<div class="caption"></div><div class="tableSection"><table width="50%" frame="lhs"><tr><th><p>字符</p></th><th><p>说明</p></th></tr><tr><td><p>\</p></td><td><p>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\”匹配“\”，“(”匹配“(”。</p></td></tr><tr><td><p>^</p></td><td><p>匹配输入字符串开始的位置。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b> 属性，^ 还会与“\n”或“\r”之后的位置匹配。</p></td></tr><tr><td><p>$</p></td><td><p>匹配输入字符串结尾的位置。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b> 属性，$ 还会与“\n”或“\r”之前的位置匹配。</p></td></tr><tr><td><p><em> </em></p></td><td><p>零次或多次匹配前面的字符或子表达式。例如，zo 匹配“z”和“zoo”。<em> 等效于 {0,}。</em></p></td></tr><tr><td><p>+</p></td><td><p>一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。</p></td></tr><tr><td><p>?</p></td><td><p>零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。</p></td></tr><tr><td><p>{<i>n</i>}</p></td><td><p><i>n </i>是非负整数。正好匹配 <i>n</i> 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。</p></td></tr><tr><td><p>{<i>n</i>,}</p></td><td><p><i>n </i>是非负整数。至少匹配 <i>n </i>次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o ”。</p></td></tr><tr><td><p>{<i>n</i>,<i>m</i>}</p></td><td><p><i>M</i> 和 <i>n</i> 是非负整数，其中 <i>n</i> &lt;= <i>m</i>。匹配至少 <i>n</i> 次，至多 <i>m</i> 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</p></td></tr><tr><td><p>?</p></td><td><p>当此字符紧随任何其他限定符（*、+、?、{<i>n</i>}、{<i>n</i>,}、{<i>n</i>,<i>m</i>}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。</p></td></tr><tr><td><p>.</p></td><td><p>匹配除“\n”之外的任何单个字符。若要匹配包括“\n”在内的任意字符，请使用诸如“[\s\S]”之类的模式。</p></td></tr><tr><td><p>(<i>pattern</i>)</p></td><td><p>匹配 <i>pattern</i> 并捕获该匹配的子表达式。可以使用 <b>$0…$9</b> 属性从结果“匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用“(”或者“)”。</p></td></tr><tr><td><p>(?:<i>pattern</i>)</p></td><td><p>匹配 <i>pattern</i> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</p></td></tr><tr><td><p>(?=<i>pattern</i>)</p></td><td><p>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <i>pattern</i> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p></td></tr><tr><td><p>(?!<i>pattern</i>)</p></td><td><p>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <i>pattern</i> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p></td></tr><tr><td><p><i>x</i>|<i>y</i></p></td><td><p>匹配 <i>x</i> 或 <i>y</i>。例如，’z|food’ 匹配“z”或“food”。’(z|f)ood’ 匹配“zood”或“food”。</p></td></tr><tr><td><p>[<i>xyz</i>]</p></td><td><p>字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。</p></td></tr><tr><td><p>[^<i>xyz</i>]</p></td><td><p>反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。</p></td></tr><tr><td><p>[<i>a-z</i>]</p></td><td><p>字符范围。匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。</p></td></tr><tr><td><p>[^<i>a-z</i>]</p></td><td><p>反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。</p></td></tr><tr><td><p>\b</p></td><td><p>匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。</p></td></tr><tr><td><p>\B</p></td><td><p>非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。</p></td></tr><tr><td><p>\c<i>x</i></p></td><td><p>匹配 <i>x</i> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<i>x</i> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。</p></td></tr><tr><td><p>\d</p></td><td><p>数字字符匹配。等效于 [0-9]。</p></td></tr><tr><td><p>\D</p></td><td><p>非数字字符匹配。等效于 [^0-9]。</p></td></tr><tr><td><p>\f</p></td><td><p>换页符匹配。等效于 \x0c 和 \cL。</p></td></tr><tr><td><p>\n</p></td><td><p>换行符匹配。等效于 \x0a 和 \cJ。</p></td></tr><tr><td><p>\r</p></td><td><p>匹配一个回车符。等效于 \x0d 和 \cM。</p></td></tr><tr><td><p>\s</p></td><td><p>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</p></td></tr><tr><td><p>\S</p></td><td><p>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</p></td></tr><tr><td><p>\t</p></td><td><p>制表符匹配。与 \x09 和 \cI 等效。</p></td></tr><tr><td><p>\v</p></td><td><p>垂直制表符匹配。与 \x0b 和 \cK 等效。</p></td></tr><tr><td><p>\w</p></td><td><p>匹配任何字类字符，包括下划线。与“[A-Za-z0-9<em>]”等效。</em></p></td></tr><tr><td><p>\W</p></td><td><p>与任何非单词字符匹配。与“[^A-Za-z0-9]”等效。</p></td></tr><tr><td><p>\x<i>n</i></p></td><td><p>匹配 <i>n</i>，此处的 <i>n</i> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。</p></td></tr><tr><td><p>\<i>num</i></p></td><td><p>匹配 <i>num</i>，此处的 <i>num</i> 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。</p></td></tr><tr><td><p>\<i>n</i></p></td><td><p>标识一个八进制转义码或反向引用。如果 \<i>n</i> 前面至少有 <i>n</i> 个捕获子表达式，那么 <i>n</i> 是反向引用。否则，如果 <i>n</i> 是八进制数 (0-7)，那么 <i>n</i> 是八进制转义码。</p></td></tr><tr><td><p>\<i>nm</i></p></td><td><p>标识一个八进制转义码或反向引用。如果 \<i>nm</i> 前面至少有 <i>nm</i> 个捕获子表达式，那么 <i>nm</i> 是反向引用。如果 \<i>nm</i> 前面至少有 <i>n</i> 个捕获，则 <i>n</i> 是反向引用，后面跟有字符 <i>m</i>。如果两种前面的情况都不存在，则 \<i>nm</i> 匹配八进制值 <i>nm</i>，其中 <i>n </i>和 <i>m</i> 是八进制数字 (0-7)。</p></td></tr><tr><td><p>\<span class="parameter" sdata="paramReference">nml</span></p></td><td><p>当 <i>n</i> 是八进制数 (0-3)，<i>m</i> 和 <i>l</i> 是八进制数 (0-7) 时，匹配八进制转义码 <i>nml</i>。</p></td></tr><tr><td><p>\u<i>n</i></p></td><td><p>匹配 <i>n</i>，其中 <i>n</i> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</p></td></tr></table></div>

<hr>
<h2 id="字符转义">字符转义</h2>
<p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\.</p>
<p>例如：<code>deerchao\.net</code>匹配<code>deerchao.net</code>，<code>C:\\Windows</code>匹配<code>C:\Windows</code>。</p>
<hr>
<h2 id="重复">重复</h2>
<p>正则表达式第一件能做的事是能够匹配不定长的字符集，而这是其它能作用在字符串上的方法所不能做到的。 不过，如果那是正则表达式唯一的附加功能的话，那么它们也就不那么优秀了。它们的另一个功能就是你可以指定正则表达式的一部分的重复次数。</p>
<p>就像前面介绍的元字符 <code>*</code>. <code>*</code> 并不匹配字母字符 “*”；相反，它指定前一个字符可以被匹配零次或更多次，而不是只有一次。</p>
<p>上面我们的元字符表把大部分元字符都说了，这里我们抽取出重复限定符。</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<p>再举个例子，ca?t 将匹配 “ct” (0 个 “a” 字符) 或 “cat” (1 个 “a”);<br>有了上面的这些限定元字符，可以很好得处理重复情况，只要运用得当。</p>
<hr>
<h2 id="字符类">字符类</h2>
<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>
<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p>
<p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。</p>
<p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。</p>
<p>“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。</p>
<p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>
<hr>
<h2 id="分支条件">分支条件</h2>
<p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p>
<p><code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>
<p><code>\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}</code>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>
<p><code>\d{5}-\d{4}|\d{5}</code>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成<code>\d{5}|\d{5}-\d{4}</code>的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<hr>
<h2 id="分组">分组</h2>
<p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>
<p>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p>
<p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>
<p>不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</p>
<p>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>
<hr>
<h2 id="re模块">re模块</h2>
<p>Python中得正则表达式（regular expression）模块，即re模块，功能还是很强大的。在介绍re之前，先看下面这部分。</p>
<p>正则表达式使用反斜杠” \ “来代表特殊形式或用作转义字符，这里跟Python的语法冲突，因此，Python用” \\ “表示正则表达式中的” \ “，因为正则表达式中如果要匹配” \ “，需要用\来转义，变成” \ “，而Python语法中又需要对字符串中每一个\进行转义，所以就变成了” \\ “。</p>
<p>上面的写法是不是觉得很麻烦，为了使正则表达式具有更好的可读性，Python特别设计了原始字符串(raw string)，需要提醒你的是，在写文件路径的时候就不要使用raw string了，这里存在陷阱。raw string就是用’r’作为字符串的前缀，如 r”\n”：表示两个字符”\”和”n”，而不是换行符了。Python中写正则表达式时推荐使用这种形式。</p>
<p>下面来看一下re模块的几个函数：</p>
<h4 id="compile">compile</h4>
<p><strong>re.compile(strPattern[, flag]):</strong></p>
<p>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。<br>第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。<br>另外，你也可以在regex字符串中指定模式，<br>比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。<br>可选值有：</p>
<pre><code>re.I(IGNORECASE): 忽略大小写（括号内是完整写法，下同）
re.M(MULTILINE): 多行模式，改变'^'和'<span class="formula">$'的行为（参见上图）
re.S(DOTALL): 点任意匹配模式，改变'.'的行为
re.L(LOCALE): 使预定字符类 <span class="command">\w</span> <span class="command">\W</span> <span class="command">\b</span> <span class="command">\B</span> <span class="command">\s</span> <span class="command">\S</span> 取决于当前区域设定
re.U(UNICODE): 使预定字符类 <span class="command">\w</span> <span class="command">\W</span> <span class="command">\b</span> <span class="command">\B</span> <span class="command">\s</span> <span class="command">\S</span> <span class="command">\d</span> <span class="command">\D</span> 取决于unicode定义的字符属性
re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</span>
</code></pre><p>其实compile方法的作用，不是很明显，因为下面的两个得到的结果等价。调用compile后，返回RegexObject对象，可以用该对象调用macth()和search()等匹配方法。</p>
<pre><code><span class="keyword">import</span> re

pattern = <span class="string">r"hi"</span>;
string = <span class="string">"hi,jack"</span>;

prog = re.compile(pattern);
result1 = prog.match(string);
<span class="keyword">print</span> <span class="string">"result1: "</span>, result1.group();

result2 = re.match(pattern, string);
<span class="keyword">print</span> <span class="string">"result2: "</span>,result2.group();
</code></pre><p>输出的结果是一样的。这里match下面会介绍，它是一个匹配的方法，group方法后面也会介绍，它这里输出的时匹配的内容。可以试验一下，就明白他两是等效的。</p>
<h4 id="match和search">match和search</h4>
<p>两个方法都是进行匹配时调用的。但他们有不同之处。</p>
<p>Python提供了两种不同的原始操作：match和search。match是从字符串的起点开始做匹配，而search（perl默认）是从字符串做任意匹配。</p>
<p><strong>例子1</strong>    </p>
<pre><code><span class="keyword">import</span> re

result1 = re.match(<span class="string">"c"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"nothing"</span>);

result2 = re.search(<span class="string">"c"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
</code></pre><p>输出：<br><br>nothing<br><br>result2:c</p>
<p><strong>例子2</strong></p>
<pre><code><span class="keyword">import</span> re

result1 = re.match(<span class="string">"a"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"nothing"</span>);

result2 = re.search(<span class="string">"a"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
</code></pre><p>输出：<br><br>result1:a<br><br>result2:a</p>
<p><strong>例子3</strong></p>
<p>match函数可以设置匹配开始的位置，下面分别从0，1，2位置开始匹配。当然也可以设置终止的位置，具体可以查API文档。</p>
<pre><code>import re

pattern = re.compile(<span class="string">"c"</span>);

result1 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">0</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result1: nothing"</span>);

result2 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">1</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result2: nothing"</span>);

result3 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">2</span>);
<span class="keyword">if</span>(result3):
    <span class="keyword">print</span>(<span class="string">"result3:"</span>+result3.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result3: nothing"</span>);
</code></pre><p>输出：<br><br>result1: nothing<br><br>result2: nothing<br><br>result3:c</p>
<h4 id="split">split</h4>
<p><strong>re.split(pattern, string, maxsplit=0)</strong></p>
<p>通过正则表达式将字符串分离。如果用括号将正则表达式括起来，那么匹配的字符串也会被列入到list中返回。maxsplit是分离的次数，maxsplit=1分离一次，默认为0，不限制次数。</p>
<p>看一下例子：</p>
<pre><code>import re    
<span class="keyword">print</span> re.<span class="built_in">split</span>(<span class="string">'\W+'</span>, <span class="string">'Words, words, words.'</span>)
</code></pre><p>输出:<br><br>[‘Words’, ‘words’, ‘words’, ‘’]</p>
<p>思考一下为什么输出会是这个? 查看一下<code>\W</code>的作用，注意W是大写的。</p>
<h4 id="findall">findall</h4>
<p><strong>re.findall(pattern, string, flags=0)</strong></p>
<p>找到 RE 匹配的所有子串，并把它们作为一个列表返回。这个匹配是从左到右有序地返回。如果无匹配，返回空列表。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.<span class="keyword">findall</span>(<span class="string">"\d"</span>,<span class="string">"1a2b3c4d"</span>);
</code></pre><p>输出：<br><br>[‘1’, ‘2’, ‘3’, ‘4’]</p>
<h4 id="finditer">finditer</h4>
<p><strong>re.finditer(pattern, string, flags=0)</strong></p>
<p>找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。这个匹配是从左到右有序地返回。如果无匹配，返回空列表。</p>
<pre><code><span class="keyword">import</span> re

it = re.finditer(<span class="string">r"\d+"</span>,<span class="string">"123abc456efg789hij"</span>)
<span class="keyword">for</span> match <span class="keyword">in</span> it:
    <span class="keyword">print</span> match.group()
</code></pre><p>输出：<br><br>123<br>456<br>789</p>
<h4 id="sub">sub</h4>
<p><strong>sub(pattern, repl, string, count=0, flags=0)</strong></p>
<p>其用途是用来替换匹配成功的字串，被替换成repl。值得一提的时，这里的repl不仅仅可以是字符串，也可以是方法。</p>
<p>首先看下字符串的时候，被匹配的字符串就会被替换成为repl。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.sub(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)
</code></pre><p>输出：<br><br>Baked Beans &amp; Spam</p>
<p><code>可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组</code>.</p>
<p>当repl是方法的时候。这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 </p>
<pre><code><span class="keyword">import</span> re

<span class="function"><span class="keyword">def</span> <span class="title">dashrepl</span><span class="params">(matchobj)</span>:</span>
    <span class="keyword">if</span> matchobj.group(<span class="number">0</span>) == <span class="string">'-'</span>: <span class="keyword">return</span> <span class="string">' '</span>
    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">'-'</span>

<span class="keyword">print</span>  re.sub(<span class="string">'-{1,2}'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)
<span class="keyword">print</span>  re.sub(<span class="string">'-{1,2}'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)
</code></pre><p>输出：<br><br>pro—gram files    </p>
<h4 id="subn">subn</h4>
<p>subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]):<br>多返回 (sub(repl, string[, count]), 替换次数)。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.subn(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)
</code></pre><hr>
<p>笔者注：欢迎非商业转载，但请一定注明出处</p>
<p>如果你认为这篇不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳笔者的辛苦：</p>
<p><img src="http://zhonghuan.qiniudn.com/ZH_zhifubao.png" alt=""></p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a>  <strong>(推荐)</strong></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx" target="_blank" rel="external">正则表达式语法</a></li>
<li><a href="http://www.cnblogs.com/PythonHome/archive/2011/11/19/2255459.html" target="_blank" rel="external">Python-re模块</a></li>
<li><a href="http://dragon.cnblogs.com/archive/2006/05/08/394078.html" target="_blank" rel="external">深入浅出之正则表达式</a> <strong>(推荐)</strong></li>
<li><a href="http://www.crifan.com/files/doc/docbook/python_topic_re/release/html/python_topic_re.html" target="_blank" rel="external">正则表达式re模块详解</a> <strong>(推荐)</strong></li>
<li><a href="http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97" target="_blank" rel="external">Python正则表达式操作指南</a> <strong>(推荐)</strong></li>
<li><a href="http://blog.csdn.net/pleasecallmewhy/article/details/8929576" target="_blank" rel="external">python正则表达式教程</a></li>
</ol>
]]></content>
    
    
      <category term="python" scheme="http://zhonghuan.info/tags/python/"/>
    
      <category term="webspider" scheme="http://zhonghuan.info/tags/webspider/"/>
    
      <category term="re" scheme="http://zhonghuan.info/tags/re/"/>
    
      <category term="正则表达式" scheme="http://zhonghuan.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="python网络爬虫" scheme="http://zhonghuan.info/categories/webspider/"/>
    
  </entry>
  
</feed>
