<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[de部落格^_^]]></title>
  <subtitle><![CDATA[Enjoy your choice, enjoy your life.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhonghuan.info/"/>
  <updated>2015-03-10T09:04:08.515Z</updated>
  <id>http://zhonghuan.info/</id>
  
  <author>
    <name><![CDATA[钟桓]]></name>
    <email><![CDATA[zhonghuanblog@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[osx XAMPP 403 error及在mac下的XAMPP下配置VirtualHosts]]></title>
    <link href="http://zhonghuan.info/2015/03/10/osx-XAMPP-403-error%E5%8F%8A%E5%9C%A8mac%E4%B8%8B%E7%9A%84XAMPP%E4%B8%8B%E9%85%8D%E7%BD%AEVirtualHosts/"/>
    <id>http://zhonghuan.info/2015/03/10/osx-XAMPP-403-error及在mac下的XAMPP下配置VirtualHosts/</id>
    <published>2015-03-10T07:28:47.000Z</published>
    <updated>2015-03-10T09:03:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="error_403">error 403</h3>
<p>你发现，安装完XAMPP，默认的localhost对应的地址是在/Applications/XAMPP/xamppfiles/htdocs下，可以将应用部署在这儿。(当然，也可以不用，文章后面会介绍VirtualHosts，就是解决这个问题的。)</p>
<p>然后，通过XAMPP的manager-osx启动apache服务器后，访问你的应用，可能会提示出403 error。原因，主要是—权限-的问题。apache默认是没有用户的，但是，在mac下，你需要在XAMPP的配置文件里设置user。步骤如下：</p>
<ol>
<li>打开/Applications/XAMPP/xamppfiles/etc/httpd.conf</li>
<li><p>找到如下代码出：</p>
<pre><code> # User/<span class="keyword">Group</span>: The name (<span class="keyword">or</span> #number) <span class="keyword">of</span> the user/<span class="keyword">group</span> <span class="keyword">to</span> run httpd <span class="keyword">as</span>.
 # It <span class="keyword">is</span> usually good practice <span class="keyword">to</span> <span class="keyword">create</span> a dedicated user <span class="keyword">and</span> <span class="keyword">group</span> <span class="keyword">for</span>
 # running httpd, <span class="keyword">as</span> <span class="keyword">with</span> most system services.
 #
 User daemon
 <span class="keyword">Group</span> daemon
</code></pre><p>更改User和Group后面的内容，具体可以在mac下，系统偏好设置—&gt;用户与群组， 先解锁，然后触摸板双击或者鼠标右键当前用户，选择 高级选项。然后里面的账号名称对应User，群组对应group。</p>
</li>
<li><p>在终端中运行下面的命令。</p>
<pre><code> sudo chown -R 你当前的用户名字 <span class="regexp">/Applications/</span>XAMPP<span class="regexp">/xamppfiles/</span>htdocs
</code></pre></li>
</ol>
<p>然后，再重启Apache服务器,ok 问题解决。</p>
<h3 id="在mac下的XAMPP下配置VirtualHosts">在mac下的XAMPP下配置VirtualHosts</h3>
<p>什么是virtualHosts，virtualHosts允许apache将hostname和目录对应起来。怎么说呢，就像上面的localhost，对应的是/Applications/XAMPP/xamppfiles/htdocs目录，有时候我们需要mysite.local（名字自己随便取）对应 /Users/yourusername/mysite(应用所在的目录)。</p>
<p>过程如下：</p>
<h5 id="允许VirtualHosts">允许VirtualHosts</h5>
<p>打开/Applications/XAMPP/xamppfiles/etc/httpd.conf，找到下面的部分：</p>
<pre><code>        # Virtual hosts
        #<span class="keyword">Include</span> <span class="regexp">/Applications/</span>XAMPP<span class="regexp">/etc/</span>extra<span class="regexp">/httpd-vhosts.conf</span>
</code></pre><p>然后去掉#：</p>
<pre><code>        # Virtual hosts
        <span class="keyword">Include</span> <span class="regexp">/Applications/</span>XAMPP<span class="regexp">/etc/</span>extra<span class="regexp">/httpd-vhosts.conf</span>
</code></pre><h5 id="创建VirtualHosts">创建VirtualHosts</h5>
<p>创建VirtualHosts，在/Applications/XAMPP/xamppfiles/etc/extra/httpd-vhosts.conf尾部，添加</p>
<pre><code>        <span class="comment"># My custom host</span>
        <span class="tag">&lt;VirtualHost *:80&gt;</span>
            <span class="keyword"><span class="common">ServerName</span></span> mysite.local
            <span class="keyword"><span class="common">DocumentRoot</span></span> <span class="string">"/Users/yourusername/path/to/your/site"</span>
            <span class="tag">&lt;Directory "/Users/yourusername/path/to/your/site"&gt;</span>
                <span class="keyword"><span class="common">Options</span></span> Indexes FollowSymLinks Includes ExecCGI
                <span class="keyword">AllowOverride</span> <span class="literal">All</span>
                <span class="keyword">Require</span> <span class="literal">all</span> granted
            <span class="tag">&lt;/Directory&gt;</span>
            <span class="keyword">ErrorLog</span> <span class="string">"logs/mysite.local-error_log"</span>
        <span class="tag">&lt;/VirtualHost&gt;</span>
</code></pre><p>记住，mysite.local是自定义的host name。</p>
<h6 id="编辑hosts文件">编辑hosts文件</h6>
<p>完成上面的步骤，你只是在Apache内完成配置，当你在浏览器内访问mysite.local时候，浏览器并不知道这一切，你需要在hosts文件内，将mysite.local和127.0.0.1绑定映射。</p>
<p>打开终端，输入：</p>
<pre><code>    <span class="built_in">sudo</span> nano /etc/hosts
</code></pre><p>输入：</p>
<pre><code>    <span class="comment"># XAMPP VirtualHost mappings</span>
    <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> mysite.<span class="built_in">local</span>
</code></pre><p>使用control+o保存，使用control+x关闭。</p>
<h5 id="重启Apache服务器">重启Apache服务器</h5>
<h3 id="结束语">结束语</h3>
<p>希望能够帮助在osx下使用XAMPP的朋友。</p>
<h3 id="引用：">引用：</h3>
<ol>
<li><p><a href="http://jonathannicol.com/blog/2012/03/11/configuring-virtualhosts-in-xampp-on-mac/" target="_blank" rel="external">Configuring VirtualHosts in XAMPP on Mac</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/18365500/xampp-mac-virtual-host-showing-403" target="_blank" rel="external">XAMPP (Mac) Virtual host showing 403 (stackoverflow)</a></p>
</li>
</ol>
]]></content>
    
    
      <category term="osX" scheme="http://zhonghuan.info/tags/osX/"/>
    
      <category term="XAMPP" scheme="http://zhonghuan.info/tags/XAMPP/"/>
    
      <category term="问题笔记" scheme="http://zhonghuan.info/categories/%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下“一键回桌面”应用开发笔记]]></title>
    <link href="http://zhonghuan.info/2015/03/03/Mac%E4%B8%8B%E2%80%9C%E4%B8%80%E9%94%AE%E5%9B%9E%E6%A1%8C%E9%9D%A2%E2%80%9D%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhonghuan.info/2015/03/03/Mac下“一键回桌面”应用开发笔记/</id>
    <published>2015-03-03T13:48:32.000Z</published>
    <updated>2015-03-03T16:27:46.000Z</updated>
    <content type="html"><![CDATA[<p>偶然看到别人的写得一篇<a href="http://jiajixin.cn/2015/02/21/mac-application-show-desktop/" target="_blank" rel="external">Mac下显示桌面应用开发</a>,觉得挺有趣的，并且，一键回桌面，对我来说，也是挺常用的，所以，就试着自己开发了一个，不过原来的作者使用的是objective c开发的。这里使用的是Swift语言来进行开发，也是加深自己对于Swift的运用吧。</p>
<h3 id="功能">功能</h3>
<ol>
<li>状态栏点击图标，即显示桌面，所有显示窗口最小化。</li>
<li>开机默认自启动，用户可以选择是否开机自启动。</li>
</ol>
<p>原来的作者开发的是纯状态栏应用，初衷也挺好的，但是，有一个瑕疵是，用户不能手动退出应用了。所以，我把它放在dock了(其实这也是瑕疵！)，这样的好处，不用的时候，用户可以手动退出。</p>
<h3 id="状态栏">状态栏</h3>
<p>要在状态栏中显示icon，并且添加点击它的action，代码如下：</p>
<pre><code><span class="keyword">let</span> <span class="variable">statusItem =</span> NSStatusBar.systemStatusBar().statusItemWithLength(-<span class="number">1</span>)

//icon showed <span class="keyword">in</span> system status bar
<span class="keyword">let</span> <span class="variable">icon =</span> NSImage(named: <span class="string">"desktop"</span>)
icon?.setTemplate(<span class="constant">true</span>)
statusItem.<span class="variable">image =</span> icon

// define the action when the icon was clicked!
statusItem.<span class="variable">action =</span> Selector(<span class="string">"goBackDesktop:"</span>)
</code></pre><h3 id="显示桌面">显示桌面</h3>
<p>如何实现显示桌面呢？<br>其实显示桌面是有快捷键的，CMD+ALT+H+M，按下CMD+ALT+H就会隐藏当前窗口除外的窗口，CMD+M会隐藏当前窗口，所以同时按下CMD+ALT+H+M就会达到显示桌面的效果。</p>
<p>所以现在需要做的就是模拟按键，代码如下：</p>
<pre><code>    //simulate option+command+h+m 

    var <span class="variable">src =</span> CGEventSourceCreate(CGEventSourceStateID(kCGEventSourceStateHIDSystemState)).takeRetainedValue()

    <span class="keyword">let</span> <span class="variable">cmdDown =</span> CGEventCreateKeyboardEvent(src, <span class="number">0</span>x37, <span class="constant">true</span>).takeRetainedValue()
    <span class="keyword">let</span> <span class="variable">cmdUp =</span> CGEventCreateKeyboardEvent(src, <span class="number">0</span>x37, <span class="constant">false</span>).takeRetainedValue()
    CGEventSetFlags(cmdDown, CGEventFlags(kCGEventFlagMaskCommand))
    CGEventSetFlags(cmdUp, CGEventFlags(kCGEventFlagMaskCommand))


    <span class="keyword">let</span> <span class="variable">loc =</span> CGEventTapLocation(kCGHIDEventTap)

    CGEventPost(loc, cmdDown)

    CGEventPost(loc, cmdUp)
</code></pre><p>其中0x37，对应的是Command按键。</p>
<h3 id="开机启动">开机启动</h3>
<p>Swift开机启动，我是看了这个<a href="http://stackoverflow.com/questions/26475008/swift-getting-a-mac-app-to-launch-on-startup" target="_blank" rel="external">stackoverflow的提问</a>,了解的。</p>
<h3 id="效果展示">效果展示</h3>
<p><img src="http://zhonghuan.qiniudn.com/showDesktop.gif" alt=""></p>
<h3 id="应用下载">应用下载</h3>
<p><a href="http://zhonghuan.info/ZHShowDesktop.app.zip" target="_blank" rel="external">http://zhonghuan.info/ZHShowDesktop.app.zip</a></p>
<p>下载完后，直接拷贝到应用程序中即可</p>
<h3 id="代码">代码</h3>
<p>代码都放在我的github上了，喜欢的朋友请点个赞，觉得有必要改进的朋友，可以fork之后，再合并给我。</p>
<p>地址： <a href="https://github.com/ZHONGHuanGit/ZHShowDesktop" target="_blank" rel="external">https://github.com/ZHONGHuanGit/ZHShowDesktop</a></p>
]]></content>
    
    
      <category term="Swift" scheme="http://zhonghuan.info/tags/Swift/"/>
    
      <category term="osX" scheme="http://zhonghuan.info/tags/osX/"/>
    
      <category term="mac" scheme="http://zhonghuan.info/tags/mac/"/>
    
      <category term="Swift" scheme="http://zhonghuan.info/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析编译原理-上下文无关文法]]></title>
    <link href="http://zhonghuan.info/2014/11/23/%E6%B5%85%E6%9E%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    <id>http://zhonghuan.info/2014/11/23/浅析编译原理-上下文无关文法/</id>
    <published>2014-11-23T15:47:09.000Z</published>
    <updated>2014-11-23T15:50:09.000Z</updated>
    <content type="html"><![CDATA[<p>查找wiki，是这样说文法，文法即文章的书写法规，一般用来指以文字、词语、短句、句子[1]编排而成的完整语句和文章的合理性组织。语言的结构方式。包括词的构成和变化﹐词组和句子的组织。</p>
<pre><code>例如：
最简单的语句组合一：主词及动词：
“我”“哭了”
（主语）+（动词）
“天气”“改变了”
</code></pre><p>其实说白了，在程序语言中，就是语言的构造规则。例如中文的构造规则是：&lt;主语&gt;&lt;谓语&gt;&lt;宾语&gt;&lt;补语&gt;&lt;状语&gt;。英文的构造规则是：S十V主谓结构 S十V十F主系表结构 S十V十O主谓宾结构 S十V十O1十O2主谓双宾结构 S十V十O十C主谓宾补结构说明：S＝主语；V＝谓语；P＝表语；O＝宾语；O1＝间接宾语；O2＝直接宾语；C＝宾语补足语。我们可以看出汉语和英语有不同的编排，不同的规则，这就是文法的不同。 </p>
<hr>
<h3 id="上下文无关的文法">上下文无关的文法</h3>
<p>上下文无关的文法，是文法中一种，它是这样定义的：</p>
<p>一个上下文无关文法G包括四个组成部分：</p>
<ul>
<li>一组终结符号</li>
<li>一组非终结符</li>
<li>一个开始符号</li>
<li>一组产生式。</li>
</ul>
<p>所谓终结符号：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乃是组成语言的基本符号，即在程序语言中以前屡次提到的单词符号，如基本字，标识符，常数，算符和界符等</p>
<p>所谓非终结符号（也称语法变量）:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来代表语法范畴。如“算术表达式”、“布尔表达式”、“过程”等。一个非终结符代表一个一定的语法概念。因此非终结符是一个类（或集合）记号，而不是个体记号。</p>
<p>开始符号:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一个特殊的非终结符号，它代表所定义的语言中我们最感兴趣的语法范畴，这个语法范畴通常称为“句子”。但在程序语言中我们最终感兴趣的是“程序”这个语法范畴，而其他的语法范畴都只不过是构造“程序”的一块块砖石。</p>
<p>产生式（也称为产生规则或简称规则）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是定义语法范畴的一种书写规则。一个产生式的形式是  A→ α ,其中箭头左边的A是一个终结符，称为产生式的左部符号；箭头右边的α是终结符号或与非终结符号组成的一符号串，称为产生式的右部。</p>
<p>看完上面的概念，似乎仍旧不太理解，让我们来看下面的例子，从例子中理解。</p>
<hr>
<h3 id="从例子中理解">从例子中理解</h3>
<p>分析句子：The grey wolf will eat  the  goat .</p>
<p>这个句子的结构如下图:</p>
<p><img src="http://zhonghuan.qiniudn.com/CompilerTheory/上下文无关文法/上下文无关文法1.jpeg" alt=""></p>
<p>可以从上面的图中清晰地看出句子的成分。</p>
<p>上面树中的每一个<strong>叶子节点中的单词</strong>，对应的就是上下文无关文法中的<strong>终结符号</strong>。</p>
<p>而句子的<strong>开始符号</strong>就是<strong>根节点&lt;句子&gt;</strong></p>
<p>而句子的产生式，如下图：</p>
<p><img src="http://zhonghuan.qiniudn.com/CompilerTheory/上下文无关文法/上下文无关文法2.jpeg" alt=""></p>
<p>那么什么是<strong>非终结符号</strong>呢？它对应着上面树中的<strong>非叶子节点</strong>，是滴，你木有看错，飞叶子节点，包括<strong>根节点句子</strong>。</p>
<p><img src="http://zhonghuan.qiniudn.com/CompilerTheory/上下文无关文法/上下文无关文法3.jpeg" alt=""></p>
<p>看到这里，估计你对于上下文无关文法有了一个大致的了解。</p>
<p>前面我们提到过可以用一张图表示一个句型的推导，这种表示称为语法分析树，或简称语法树。</p>
<p>语法树的根结由开始符号所标记。随着推导的展开，当某个非终结符被它的某个候选式所替换时，这个非终结符的相应结就产生了下一代新结。每个新结和其父亲结间都有一条连线。在一棵语法树生长过程中的任何时刻，所有那些没有后代的端末结自左至右排列起来就是一个句型。</p>
<hr>
<h3 id="补充">补充</h3>
<p>首先引入几个概念：</p>
<p>设Σ是一个有穷字母表，它的每个元素称为一个符号。 Σ上的一个符号串是指由Σ中的符号所构成的有穷序列。不包含符号的序列称为空字符，记为ε。用Σ*表示Σ上的所有符号串的全体，空字也包括在其中。</p>
<pre><code>如：若Σ=<span class="list">{a,b}</span>则Σ*=<span class="list">{,a,b,aa,ab,bb,aaa,…}</span>。Σ表示不含人何元素的空集<span class="list">{}</span>。这里要注意ε、<span class="list">{}</span>和<span class="list">{ε}</span>的区别
</code></pre><p>Σ*的子集U和V中的（连接）积定义为:</p>
<pre><code><span class="attribute">UV</span>=<span class="string">{αβ∣α∈U &amp; β∈V }</span>
</code></pre><p>即集合UV中的符号串是由U和V的符号串连接而成的。注意，一般UV≠VU，但（UV)W=U(VW).<br>V自身的n次（连接）积记为：</p>
<pre><code><span class="attribute">Vn </span>=<span class="string"> V V…V   (n个V)</span>
</code></pre><p>规定 V0 = {}.<br>   令： V*  = V0 ∪ V1 ∪ V2 ∪ …<br>   称 V*是V的闭包。<br>记V+ = VV*, 称 V+是V的正则包。</p>
<p>闭包V*中的每个符号都是由V中的符号串经有限次连接而成的。</p>
<p>假定G是一个文法，S是它的开始符号。如果S→*α(表示从S出发，经0步或若干步可推出α），则称α是一个句型。仅含终结符号的句型是一个句子。文法G所产生的句子的全体是一个语言，将它记为L(G).</p>
<pre><code><span class="attribute"> L(G)</span>=<span class="string">{|S →* α &amp; α ∈ VT }</span>
</code></pre><p>例如：终结符号串（i*i+i)是文法</p>
<pre><code><span class="keyword">E</span>→<span class="keyword">E</span>+<span class="keyword">E</span>|<span class="keyword">E</span>\*<span class="keyword">E</span>|(<span class="keyword">E</span>)|ｉ　　　  (<span class="number">2.1</span>)
</code></pre><p>的一个句子。是因为有</p>
<pre><code><span class="keyword">E</span> → (<span class="keyword">E</span>) → (<span class="keyword">E</span>+<span class="keyword">E</span>) → (<span class="keyword">E</span>*<span class="keyword">E</span>+<span class="keyword">E</span>) → (i*<span class="keyword">E</span>+<span class="keyword">E</span>)
→ (i*i+<span class="keyword">E</span>) → (i*i+i)从开始符号<span class="keyword">E</span>至
 （i*i+i)的一个推导。而<span class="keyword">E</span>,(<span class="keyword">E</span>),(<span class="keyword">E</span>*<span class="keyword">E</span>+<span class="keyword">E</span>)等是文法的句型。
</code></pre><p>考虑一个文法G1:</p>
<pre><code>  S→bA
  <span class="literal">A</span>→aA|<span class="literal">a</span> 它定义了一个什么语言呢？
</code></pre><p>从开始符S出发，我们可以推出如下句子：<br>   S → bA → ba<br>   S → bA → baA → baa<br>   S → bA → baA → …  → baa…a<br>可以写为：L(G1)={ba^n|n≥1}</p>
<hr>
<h3 id="参考资料：">参考资料：</h3>
<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E6%96%87%E6%B3%95" target="_blank" rel="external">wiki 文法</a></li>
<li><a href="http://book.douban.com/subject/3296317/" target="_blank" rel="external">编译原理</a></li>
<li><a href="">编译原理学习周入门教程—（3）文法和语言</a></li>
</ul>
]]></content>
    
    
      <category term="编译原理" scheme="http://zhonghuan.info/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译" scheme="http://zhonghuan.info/categories/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flashlight--spotlight的好帮手]]></title>
    <link href="http://zhonghuan.info/2014/11/22/flashlight-spotlight%E7%9A%84%E5%A5%BD%E5%B8%AE%E6%89%8B/"/>
    <id>http://zhonghuan.info/2014/11/22/flashlight-spotlight的好帮手/</id>
    <published>2014-11-21T16:29:30.000Z</published>
    <updated>2014-11-21T16:32:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Flashlight简介：">Flashlight简介：</h3>
<p>OS X Yosemite 上全新的 Spotlight 越发强大，大有吞并 LaunchBar 6 与 Alfread 之势，但碍于官方 API 的种种限制，很多 Web 内容、文件和应用程序不能直接在其搜索框调用。为此一款基于 Python 编写的 Spotlight 插件应运而生。这个便是Flashlight啦。</p>
<p>那么它的作用是什么？如果你用过Alfred的话，那么对于Flashlight的定义就是给Spotlight写workflow的插件。</p>
<p>Spotlight的作用，用过的人都知道了，就不详述了，那么flashlight给Spotlight带来了什么呢？为什么大家说，有了flashlight的话，未来Spotlight会替代Alfred（当然，这句话有待观察，毕竟Flashlight现在还不太稳定）</p>
<hr>
<h3 id="功能">功能</h3>
<p>主要能够实现的功能。下面列出我觉得几个不错的扩展功能。</p>
<ul>
<li>天气搜索，通过 Flashlight 提供的 API 接口，Spotlight 搜索框内会显示动态天气动画与未来三天的天气预测，用法：weather + 地址</li>
</ul>
<p><img src="http://zhonghuan.qiniudn.com/osX/flashlight/weather.gif" alt=""></p>
<ul>
<li>有道词典翻译，通过 Flashlight 提供的 API 接口，Spotlight 搜索框内需要翻译的内容。用法yd + （内容）</li>
</ul>
<p><img src="http://zhonghuan.qiniudn.com/osX/flashlight/youdao1.gif" alt=""></p>
<ul>
<li>WolframAlpha搜索，WolframAlpha是一个自动问答网站，非常智慧。用法 walpha + 问题<br><img src="http://zhonghuan.qiniudn.com/osX/flashlight/walpha.gif" alt=""></li>
</ul>
<ul>
<li>知乎日报的功能。 用法 zhihu + (daily || hot || 20140822(该日期热点新闻)）<br><img src="http://zhonghuan.qiniudn.com/osX/flashlight/zhihu1.gif" alt=""></li>
</ul>
<hr>
<p>Flashlight，就是提供给开发者一个平台，给Spotlight增加用户需要的一些额外的功能。</p>
<p><img src="http://zhonghuan.qiniudn.com/osX/flashlight/flashlight.png" alt=""></p>
<hr>
<h3 id="开发">开发</h3>
<p>如果你想要给Spotlight增加一些额外的功能，可以看这里<a href="https://github.com/nate-parrott/Flashlight" target="_blank" rel="external">https://github.com/nate-parrott/Flashlight</a></p>
<p>上面的功能介绍中，第四个知乎日报，是由本人闲得时候贡献的，具体可以看这里<a href="https://github.com/ZHONGHuanGit/ZhihuDaily" target="_blank" rel="external">https://github.com/ZHONGHuanGit/ZhihuDaily</a> 要是觉得不错，请点个star</p>
]]></content>
    
    
      <category term="osX" scheme="http://zhonghuan.info/tags/osX/"/>
    
      <category term="工具类，软件类介绍" scheme="http://zhonghuan.info/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E8%BD%AF%E4%BB%B6%E7%B1%BB%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[电子商务发展对企业和消费者行为带来了哪些变化]]></title>
    <link href="http://zhonghuan.info/2014/10/16/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E5%8F%91%E5%B1%95%E5%AF%B9%E4%BC%81%E4%B8%9A%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E8%A1%8C%E4%B8%BA%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96/"/>
    <id>http://zhonghuan.info/2014/10/16/电子商务发展对企业和消费者行为带来了哪些变化/</id>
    <published>2014-10-15T16:46:48.000Z</published>
    <updated>2014-10-15T17:02:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="序">序</h2>
<p>经济学家认为,目前人类正在进行第三次商业革命:信息革命（第一次农业革命，第二次工业革命），电子商务是这次革命浪潮的最重要的表现形式.传统商贸必然在这次革命浪潮中,实现改造,脱胎换骨。那么，互联网和电子商务的出现带来了哪些深刻的变化呢？</p>
<p><img src="http://www.nxqcc.com/Uploads/goods/20140104/20140104183949_4205.jpg" alt=""></p>
<h2 id="直销得到发展">直销得到发展</h2>
<p>在线零售就是一种通过网络来实现的直销。直销和店铺是传统销售的两种形式。其实传统经济中直销早已存在，但过去由于信息不发达，物流条件受到限制，商品一般都是通过层层批发的供应链方式最终到达消费者手上，直销做起来比较困难。互联网打破了时间和空间的界限，打破了传统信息不对称的局面，买卖双方很容易通过互联网建立业务关系。因此直销得到极大地发展，直销的比例不断地增长。</p>
<hr>
<h2 id="多元电子商务模式得到发展">多元电子商务模式得到发展</h2>
<p>多元电子商务模式得到了充足发展。下面让我们来了解一下不同的模式。</p>
<h3 id="B2C：">B2C：</h3>
<p>是Business-to-Customer的缩写，而其中文简称为“商对客”。“商对客”是电子商务的一种模式，也就是通常说的商业零售，直接面向消费者销售产品和服务。B2C的典型代表就是亚马逊，这是一家美国的在线零售网站，在国内，当然也有不少代表网站，如天猫，京东等。（值得一提的是，拥有天猫的阿里巴巴和京东今年都在美国上市，都获得了巨额的融资，其中阿里巴巴一跃成为近两千亿市值的互联网公司。）但是，双方实现的形式略有不同，京东属于自主经营卖产品，而阿里巴巴则是为企业服务做平台。</p>
<h3 id="C2C：">C2C：</h3>
<p>C2C的意思就是个人与个人之间的电子商务。比如一个消费者有一台旧电脑，通过网络进行交易，把它出售给另外一个消费者，此种交易类型就称为C2C电子商务。在美国，有EBay；而在中国，有淘宝网，拍拍网。</p>
<h3 id="B2B：">B2B：</h3>
<p>B2B是指进行电子商务交易的供需双方都是商家（或企业、公司），她（他）们使用了Internet的技术或各种商务网络平台，完成商务交易的过程。典型代表是阿里巴巴。</p>
<h3 id="O2O：">O2O：</h3>
<p>O2O即Online To Offline（线上到线下），是指将线下的商务机会与互联网结合，让互联网成为线下交易的前台。说起O2O，不得不提前几年的火热的千团大战，指的是众多的团购网站突起，纷纷打起了价格战，当然时至今日，存在下来的团购网站数量大大减少。以糯米，美团，大众点评等，主打的是美食与电影，生活产品等等。当然还有家用电器为主的苏宁，国美也加入了O2O的行列，依靠自身众多的线下实体店，做起了线上网站。当然还有主打旅游出行的携程，艺龙等，主打和旅游出行有关的酒店住宿，机票预订等。近些时间，O2O依旧是火热的话题，经过不断探索，有很多新的方式出来。比如饿了么，淘点点主打外卖线上订购，送货上门，我觉得这也属于O2O模式的变种。还有改进社交模式而出现的约你，约你主打线上订购，线下约会，解决原本的社交没有分清约会，谁来请客的问题。O2O的潜力仍然未被完全发掘，如今被认为是下一个千亿企业的诞生之处。</p>
<hr>
<h2 id="对于企业的变化">对于企业的变化</h2>
<p>电子商务的发展，无疑带动了企业的成长。从各种互联网企业的崛起之外，传统企业也不得不跟进时势，求生存发展。众多线下零售巨头，不仅是美国的沃尔玛，中国的华润万家，万达等，建立起线上的电子商务网站。不仅是零售行业，对于连锁酒店，星级酒店也是如此，连锁酒店如七天，如家等，都有自己的线上网站。同样，对于火车票订购，同样建立其自己的网站，开售火车票，如今，从前的每逢节假日需要排队数小时才能买到票的场景已经不再，大多数人都会通过网络订票，线下取票。电子商务的发展促进了企业的发展的同时，也方便了客户的购买。</p>
<hr>
<h2 id="对于消费者行为的变化">对于消费者行为的变化</h2>
<h4 id="价格更透明：">价格更透明：</h4>
<p>有了众多的电子商务网站，如今的商品价格，在网上一查便可以马上了解个大概，因为相对来说，网络上的价格会更透明，更真实。同样，因为网络购物，商家一般都打价格战，所以网上的价格会更低廉。所以，线下购物，可以参考线上的价格。最终，导致更多地商品价格透明，线下的商家也更少像从前那样漫天要价。</p>
<h4 id="购物方式的巨大改变：">购物方式的巨大改变：</h4>
<p>曾经的在在线下实体商家购物的方式，如今更多的人（特别是年轻人），会选择在网络上购买商品，原因是综合的，网络上的价格低廉，购物平台可以看到众多已购者对于商品的评价，从而对该商品质量有一个大致的认识。这笔线下购物，会更有参考性一些。当然，线下实体购物依旧有其强大的优势，所以仍然是购物的主流，特别是对于生鲜产品一块</p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ol>
<li><p>张润彤，（2009.3）电子商务概论</p>
</li>
<li><p>（2014.7）互联网和电子商务给传统商贸带来哪些深刻变化？ </p>
</li>
</ol>
<p>From <a href="http://blog.sina.com.cn/s/profile_1796241195.html" target="_blank" rel="external">http://blog.sina.com.cn/s/profile_1796241195.html</a></p>
]]></content>
    
    
      <category term="电子商务" scheme="http://zhonghuan.info/tags/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/"/>
    
      <category term="记or谈" scheme="http://zhonghuan.info/categories/%E8%AE%B0or%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pip介绍与使用]]></title>
    <link href="http://zhonghuan.info/2014/10/01/pip%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhonghuan.info/2014/10/01/pip介绍与使用/</id>
    <published>2014-10-01T01:26:54.000Z</published>
    <updated>2014-10-01T06:14:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>pip 是一个安装和管理 Python 包的工具，python安装包的工具有easy_install, setuptools, pip，distribute。使用这些工具都能下载并安装django。，而pip是easy_install的替代品。在CPython解释器，pypy解释器，可以很好地工作</p>
<hr>
<h2 id="安装pip">安装pip</h2>
<p>安装和升级之前，先下载 <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="external">get-pip.py</a></p>
<p>然后使用下面的命令：</p>
<pre><code><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span>
</code></pre><p>不过注意一下，linux或osX下，需要权限，使用下面的命令，输入密码后即可。</p>
<pre><code>sudo <span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span> 
</code></pre><p>windows下需要管理员权限启动终端。</p>
<p>如果你还没有安装了<a href="http://baike.baidu.com/view/4944440.htm" target="_blank" rel="external">setuptools</a>，get-pip.py 会帮你安装。</p>
<p>如果你已经安装了setuptools，运行下面的命令进行升级。</p>
<pre><code>pip <span class="operator"><span class="keyword">install</span> -U setuptools</span>
</code></pre><p>windows下，注意将pip路劲加到系统的path中，原因就不解释了吧。</p>
<hr>
<h2 id="升级pip">升级pip</h2>
<p>Linux or OS X系统，运行下面的命令:</p>
<pre><code>pip <span class="operator"><span class="keyword">install</span> -U pip</span>
</code></pre><p>windows系统运行下面的命令：</p>
<pre><code><span class="keyword">python</span> -<span class="keyword">m</span> pip install -U pip
</code></pre><hr>
<h2 id="安装包">安装包</h2>
<p>使用下面的命令来安装包</p>
<pre><code>pip <span class="operator"><span class="keyword">install</span> SomePackage            # latest <span class="keyword">version</span>
pip <span class="keyword">install</span> SomePackage==<span class="number">1.0</span><span class="number">.4</span>     # specific <span class="keyword">version</span>
pip <span class="keyword">install</span> <span class="string">'SomePackage&gt;=1.0.4'</span>     # minimum <span class="keyword">version</span></span>
</code></pre><p>要看更多地例子，可以看这里<a href="https://pip.pypa.io/en/latest/reference/pip_install.html#pip-install" target="_blank" rel="external">pip install</a></p>
<p>例如我要安装Django，用下面的一条命令即可，方便快捷。</p>
<pre><code><span class="attribute">pip install Django=</span>=<span class="string">1.7</span>
</code></pre><hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://pip.pypa.io/en/latest/installing.html" target="_blank" rel="external">pip</a></li>
</ul>
]]></content>
    
    
      <category term="python安装管理工具" scheme="http://zhonghuan.info/tags/python%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="pip" scheme="http://zhonghuan.info/tags/pip/"/>
    
      <category term="工具类，软件类介绍" scheme="http://zhonghuan.info/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E8%BD%AF%E4%BB%B6%E7%B1%BB%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[清华大学软件2014机试]]></title>
    <link href="http://zhonghuan.info/2014/09/24/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B62014%E6%9C%BA%E8%AF%95/"/>
    <id>http://zhonghuan.info/2014/09/24/清华大学软件2014机试/</id>
    <published>2014-09-24T11:33:15.000Z</published>
    <updated>2014-09-24T11:34:35.000Z</updated>
    <content type="html"><![CDATA[<p>今天刚刚机试完，乘者还没忘记，把自己知道的记下来，也算是泽被后来人吧~~~</p>
<p>这次的机试题，相对来说，会更简单一点，总共3题，时间是3小时。</p>
<h3 id="1_超级幸运数">1 超级幸运数</h3>
<p>题目大致描述：</p>
<p>一个数字，若是只含有1和4，这个数字就是幸运数，例如，14，114。但是514这样的就不是了，因为含有其它数字。  若这个幸运数字中，1和4的数量相同，那么就是超级幸运数，例如14，1144，41等等。</p>
<p>题目要求，输入一个n，n的范围是[1,1e9]，输出[1,n]的最大超级幸运数。无解的话，输出-1.</p>
<p>解题思路：</p>
<p>这个题目，当n<14，那么显然是无解的，其余情况，最起码还有14，其实就是当>=14的时候，找一个最大的就好了，那么最大有什么规律，假设输入的n有x位，当位数是奇数的时候，输出(x-1)/2个4，和(x-1)/2个1，就好了。如果位数是偶数的话，那么，要考虑一下一些情况了，因为输出是不能大于n的，并且4和1的个数相等。还有，注意这样的数据1000，它的输出应该是41。</14，那么显然是无解的，其余情况，最起码还有14，其实就是当></p>
<p>一些测试数据：</p>
<p>in： 20  out：14</p>
<p>in： 10  out： -1</p>
<p>in：1000  out： 41</p>
<h3 id="2_移动小球">2 移动小球</h3>
<p>有一些小球，1，2，。。。，n；<br>有两种操作，分别是</p>
<ul>
<li>1 x y ,把x移动至y的左边</li>
<li>2 x y ,把x移动至y的右边</li>
</ul>
<p>问得是，m次操作后，小球的顺序是什么..</p>
<p>其实就是这样的，原本1，2，3，4，5.（如果n=5的话）。经过1 1 4操作后，变成2 3 1 4 5</p>
<p>n数据范围[1,1000]</p>
<p>m 数据范围[1,200000]</p>
<p>解题思路：</p>
<p>双向链表就能够解决这个问题。再用一个数组存储这些个节点的位置。</p>
<p>测试数据：</p>
<p>in ：  </p>
<p>5， 2  （输入是 n m）</p>
<p>1 1 4   （表示操作，1，x， y）</p>
<p>2 4 2</p>
<p>out：  2 4 3 1 5；</p>
<h3 id="3_整理书架">3 整理书架</h3>
<p>书店管理员要把书架上的书整理一下，其实就是一排书，让书的排序是按照书的高低，每本书有一个重量，重量越大，移动书时越费力，越累，让我们求的是，总的移动书本的最小重量是多少。</p>
<p>给出的数据是：</p>
<p>5（书的数量）</p>
<p>1 2 5 3 3 （表示书的高度）</p>
<p>1 1 3 1 1 （标示书的重量）</p>
<p>输出是2，</p>
<p>为什么是2，因为这里只需要把第4，第5本书移动到第三本书的前面，就能够保证书的有序，移动的重量和是2。</p>
<p>解题思路：</p>
<p>移动的重量和最小，其实就是求，不移动重量和的最大是多少。那么怎么求不移动的最大重量和呢？其实就是记录下每本书的位置，高度，重量，然后按照高度排序，排序完后，按照节点的位置，来求一个最大子序列，不过这个最大子序列，大不在长度上，而是重量和上，这样求出来的最大子序列重量和，就是不移动的最大重量和，总的重量减去它，就是我们要的答案</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析快速排序]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhonghuan.info/2014/09/16/浅析快速排序/</id>
    <published>2014-09-16T08:08:44.000Z</published>
    <updated>2014-11-21T16:30:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本思想与特性">基本思想与特性</h2>
<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<ol>
<li><p>先从数列中取出一个数作为基准数。</p>
</li>
<li><p>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
</li>
<li><p>再对左右区间重复第二步，直到各区间只有一个数。</p>
</li>
</ol>
<p>快速排序算法的基本特性:</p>
<ol>
<li><p>时间复杂度：O（n*lgn）</p>
</li>
<li><p>最坏：O（n^2）</p>
</li>
<li><p>空间复杂度：O（n*lgn）</p>
</li>
<li><p>不稳定。</p>
</li>
</ol>
<p>快速排序是一种排序算法，对包含n个数的输入数组，平均时间为O（nlgn），最坏情况是O（n^2）。<br>通常是用于排序的最佳选择。因为，基于比较的排序，最快也只能达到O（nlgn）。</p>
<hr>
<h2 id="步骤与代码实现">步骤与代码实现</h2>
<p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：</p>
<p>先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。</p>
<p>以一个数组作为示例，取区间第一个数为基准数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">72</td>
<td style="text-align:center">6</td>
<td style="text-align:center">57</td>
<td style="text-align:center">88</td>
<td style="text-align:center">60</td>
<td style="text-align:center">42</td>
<td style="text-align:center">83</td>
<td style="text-align:center">73</td>
<td style="text-align:center">48</td>
<td style="text-align:center">85</td>
</tr>
</tbody>
</table>
<p>初始时，i = 0;  j = 9;   X = a[i] = 72</p>
<p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p>
<p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j—;</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">6</td>
<td style="text-align:center">57</td>
<td style="text-align:center">88</td>
<td style="text-align:center">60</td>
<td style="text-align:center">42</td>
<td style="text-align:center">83</td>
<td style="text-align:center">73</td>
<td style="text-align:center">48</td>
<td style="text-align:center">85</td>
</tr>
</tbody>
</table>
<p> i = 3;   j = 7;   X=72</p>
<p>再重复上面的步骤，先从后向前找，再从前向后找。</p>
<p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p>
<p>从i开始向后找，当i=5时，由于i==j退出。</p>
<p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p>
<p>数组变为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">6</td>
<td style="text-align:center">57</td>
<td style="text-align:center">42</td>
<td style="text-align:center">60</td>
<td style="text-align:center">72</td>
<td style="text-align:center">83</td>
<td style="text-align:center">73</td>
<td style="text-align:center">88</td>
<td style="text-align:center">85</td>
</tr>
</tbody>
</table>
<p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。</p>
<p>对挖坑填数进行总结</p>
<ol>
<li><p>i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p>
</li>
<li><p>j—由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p>
</li>
<li><p>i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p>
</li>
<li><p>再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p>
</li>
</ol>
<p>照着这个总结很容易实现挖坑填数的代码：</p>
<pre><code><span class="keyword">void</span> quick_sort1(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)
{
    <span class="keyword">if</span> (l &lt; r)
    {
        <span class="keyword">int</span> i = AdjustArray(s, l, r);<span class="comment">//先成挖坑填数法调整s[]</span>
        quick_sort1(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span>
        quick_sort1(s, i + <span class="number">1</span>, r);
    }
}

<span class="comment">//快速排序</span>
<span class="keyword">void</span> quick_sort(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)
{
    <span class="keyword">if</span> (l &lt; r)
    {
        <span class="comment">//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1</span>
        <span class="keyword">int</span> i = l, j = r, x = s[l];
        <span class="keyword">while</span> (i &lt; j)
        {
            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[j] &gt;= x) <span class="comment">// 从右向左找第一个小于x的数</span>
                j--;  
            <span class="keyword">if</span>(i &lt; j) 
                s[i++] = s[j];

            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt; x) <span class="comment">// 从左向右找第一个大于等于x的数</span>
                i++;  
            <span class="keyword">if</span>(i &lt; j) 
                s[j--] = s[i];
        }
        s[i] = x;
        quick_sort(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span>
        quick_sort(s, i + <span class="number">1</span>, r);
    }
}
</code></pre><hr>
<h2 id="算法分析">算法分析</h2>
<p>快速排序的时间主要耗费在划分操作上，对长度为k的区间进行划分，共需k-1次关键字的比较。</p>
<h3 id="（1）最坏时间复杂度">（1）最坏时间复杂度</h3>
<p>最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。<br>    　<br>因此，快速排序必须做n-1次划分，第i次划分开始时区间长度为n-i+1，所需的比较次数为n-i(1≤i≤n-1)，故总的比较次数达到最大值：</p>
<pre><code><span class="attribute">           Cmax </span>=<span class="string"> n(n-1)/2=O(n2)
　</span>
</code></pre><p>如果按上面给出的划分算法，每次取当前无序区的第1个记录为基准，那么当文件的记录已按递增序(或递减序)排列时，每次划分所取的基准就是当前无序区中关键字最小(或最大)的记录，则快速排序所需的比较次数反而最多。</p>
<h3 id="（2）_最好时间复杂度">（2）    最好时间复杂度</h3>
<p> 　<br>在最好情况下，每次划分所取的基准都是当前无序区的”中值”记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。总的关键字比较次数 ：O(nlgn)</p>
<p>注意：
    　</p>
<pre><code>    用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为<span class="keyword">O</span>(lgn)，而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数<span class="keyword">C</span>(n)=<span class="keyword">O</span>(nlgn)。
    因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为<span class="number">0</span>(n2)，最好时间复杂度为<span class="keyword">O</span>(nlgn)。
</code></pre><h3 id="（3）基准关键字的选取">（3）基准关键字的选取</h3>
<p>在当前无序区中选取划分的基准关键字是决定算法性能的关键。</p>
<ul>
<li>“三者取中”的规则<br>  　“三者取中”规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准，在划分开始前将该基准记录和该区伺的第1个记录进行交换，此后的划分过程与上面所给的Partition算法完全相同。
 　</li>
<li>取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准<br>  　选取基准最好的方法是用一个随机函数产生一个取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准，这相当于强迫R[low..high]中的记录是随机分布的。用此方法所得到的快速排序一般称为随机的快速排序。具体算法【参见教材】</li>
</ul>
<p>注意：
　    </p>
<pre><code>随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件，一般不可能导致最坏情况的发生。算法的随机化不仅仅适用于快速排序，也适用于其它需要数据随机分布的算法。
</code></pre><h3 id="（4）平均时间复杂度">（4）平均时间复杂度</h3>
<p>尽管快速排序的最坏时间为O(n2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。它的平均时间复杂度为O(nlgn)。</p>
<h3 id="（5）空间复杂度">（5）空间复杂度</h3>
<p>快速排序在系统内部需要一个栈来实现递归。若每次划分较为均匀，则其递归树的高度为O(lgn)，故递归后需栈空间为O(lgn)。最坏情况下，递归树的高度为O(n)，所需的栈空间为O(n)。</p>
<h3 id="（6）稳定性">（6）稳定性</h3>
<p>快速排序是非稳定的.</p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ul>
<li><p><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.4.htm" target="_blank" rel="external">快速排序—算法分析</a></p>
</li>
<li><p><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external">白话经典算法系列之六 快速排序 快速搞定</a></p>
</li>
<li><p><a href="http://blog.csdn.net/v_july_v/article/details/6116297" target="_blank" rel="external">快速排序算法</a></p>
</li>
</ul>
]]></content>
    
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析连续子向量,子数组和(一维，二维)问题]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%90%91%E9%87%8F(%E5%AD%90%E6%95%B0%E7%BB%84)%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>http://zhonghuan.info/2014/09/16/浅析连续子向量(子数组)和问题/</id>
    <published>2014-09-16T08:06:47.000Z</published>
    <updated>2014-09-16T08:12:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="最大连续子向量和">最大连续子向量和</h2>
<h4 id="问题描述：">问题描述：</h4>
<pre><code>输入是具有n个浮点数的向量x，输出这个向量的任何连续子向量中的最大和。
</code></pre><p>简单分析：子向量可以是一个空向量，空向量的和为0；如果向量的所有元素都是负数，最大子向量和就是0；</p>
<p>1 简单分析后，对于这个问题，我们立马能向想到的就是暴力算法，对所有0&lt;=i&lt;=j&lt;n的整数对进行迭代。对每个整数对(i,j)，程序都要计算x[i…j]的总和，并判断其是否大于当前的最大总和。</p>
<pre><code>解法<span class="number">1</span>：简单粗暴型
<span class="keyword">int</span> res=<span class="number">0</span>; <span class="comment">//答案</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ; i&lt;n;i++)
    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)
    {
        <span class="keyword">sum</span>=<span class="number">0</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++) 
            <span class="keyword">sum</span>+=x[k]
        res=max(res,<span class="keyword">sum</span>)    
    }
</code></pre><p>2 怎么看，上面的算法都是简单粗暴型，O(n^3)的时间复杂度实在不敢恭维，数据量一大，时间上实在不能容忍。那么有没有稍微优雅一点的？我们发现后面的部分有重复计算的，那么我们如何节省它~~一种就是从i开始往前加的时候，每次都记录下来。直接看代码：</p>
<pre><code>解法<span class="number">2</span>：
<span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//答案</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
{
    <span class="keyword">int</span> <span class="keyword">sum</span>=<span class="number">0</span>;  
    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)
    {
        <span class="keyword">sum</span>+=x[j];  <span class="comment">// sum 就是 x[i]至x[j]的和 </span>
        res=max(res,<span class="keyword">sum</span>);  
    }
}
</code></pre><p>3 上面的代码，虽然比简单粗暴型有一些改进，算法的时间复杂度降为O(n^2),还有一种O(n^2)的算法，令sum(i)表示x[0…i]的总和，然后，x[i] = sum(i) - sum(i-1);</p>
<pre><code>解法<span class="number">3</span>：
<span class="built_in">sum</span>[-<span class="number">1</span>]=<span class="number">0</span>
<span class="keyword">for</span> i=[<span class="number">0</span>,n)
    <span class="built_in">sum</span>[i]=<span class="built_in">sum</span>[i-<span class="number">1</span>]+x[i]
res=<span class="number">0</span> <span class="comment"> //储存答案</span>
<span class="keyword">for</span> i=[<span class="number">0</span>,n)
    <span class="keyword">for</span> j=[i,n)
        tem=<span class="built_in">sum</span>[j]-<span class="built_in">sum</span>[i-<span class="number">1</span>] 
        res=<span class="built_in">max</span>(res,tem)
</code></pre><p>4 O(n^2)的效率，我们还是觉得不行，可不可以优化一下，好了，我们可以采用分治的思想。要解决规模为n的问题，可递归地解决两个规模近似为n/2的子问题，然后对两个结果进行合并以得到整个问题的答案。将x划分为两个近似相等的子向量ab，在a和b中分别找出总和最大的子向量ma和mb，然后找到跨越a和b边界的最大子向量mc，返回三个总和中的最大者。通过观察发现mc在a中的部分是a中包含右边界的最大子向量，mc在b中的部分是b中包含左边界的最大子向量。伪代码如下：</p>
<pre><code>解法<span class="number">4</span>：
float maxsum(<span class="keyword">l</span>,<span class="keyword">u</span>)
    <span class="keyword">if</span>(<span class="keyword">l</span>&gt;<span class="keyword">u</span>)  <span class="keyword">return</span> <span class="number">0</span>  /* zero elements */
    <span class="keyword">if</span>(<span class="keyword">l</span>==<span class="keyword">u</span>)  <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>,<span class="keyword">x</span>[<span class="number">1</span>])  /* one element */
    <span class="keyword">m</span>=(<span class="keyword">l</span>+<span class="keyword">u</span>)/<span class="number">2</span>
    lmax=sum=<span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">i</span>=<span class="keyword">m</span>;<span class="keyword">i</span>&gt;=<span class="keyword">l</span>;<span class="keyword">i</span>--)  /* <span class="keyword">find</span> <span class="built_in">max</span> crossing <span class="keyword">to</span> <span class="keyword">left</span> */
        sum+=<span class="keyword">x</span>[<span class="keyword">i</span>]
        lmax=<span class="built_in">max</span>(lmax,sum)
    rmax=sum=<span class="number">0</span>
    <span class="keyword">for</span> <span class="keyword">i</span>=(<span class="keyword">m</span>,<span class="keyword">u</span>]  /* <span class="keyword">find</span> <span class="built_in">max</span> crossing <span class="keyword">to</span> <span class="keyword">right</span> */
        sum+=<span class="keyword">x</span>[<span class="keyword">i</span>]
        rmax=<span class="built_in">max</span>(rmax,sum)
    <span class="keyword">return</span>  <span class="built_in">max</span>(lmax+rmax,maxsum(<span class="keyword">l</span>,<span class="keyword">m</span>),maxsum(<span class="keyword">m</span>+<span class="number">1</span>,<span class="keyword">u</span>))
</code></pre><p>5 是否可以再优化一下?好了，其实可以。使用扫描算法：我们采用从x[0]开始扫描，一起到最右端x[n-1]，并记下所遇到的最大子向量总和（初始值设为0）。假设我们已解决了x[0,i-1]的问题，如何将其扩展到x[0…i]呢？前i个元素中，最大总和子数组要么在前i-1个元素中（用maxsofar存储），要么其结束位置为i（用maxendinghere存储）。</p>
<pre><code><span class="variable">maxsofar=</span><span class="number">0</span>
<span class="variable">maxendinghere=</span><span class="number">0</span>
for <span class="variable">i=</span>[<span class="number">0</span>,n)
    <span class="variable">maxendinghere=</span>max(maxendinghere+x[i],<span class="number">0</span>) <span class="comment">/* 计算前maxendinghere是结束位置为i-1的最大子向量的和 */</span>
    <span class="variable">maxsofar=</span>max(maxsofar,maxendinghere)
</code></pre><hr>
<p>几个重要的算法设计技术：</p>
<ul>
<li><p>保存状态，避免重复计算：</p>
</li>
<li><p>将信息预处理至数据结构：
　　</p>
</li>
<li>分治算法：</li>
</ul>
<hr>
<h2 id="子向量和接近于0">子向量和接近于0</h2>
<p>假设我们想要查找的是总和最接近0的子向量，而不是具有最大总和的子向量，该如何设计算法？</p>
<p>可初始化累加数组cum，使得cum[i]=x[0]+…+x[i]。如果cum[l-1]=cum[u]，那么子向量x[l…u]之和就为0.因此可以通过定位cum中最接近的两个元素来找出和最接近0的子向量。这可以通过排序数组，在O(nlogn)时间内完成。</p>
<hr>
<h2 id="收费站问题">收费站问题</h2>
<p>问题描述：</p>
<pre><code>收费公路由n个收费站之间的n-<span class="number">1</span>段公路组成，每一段都和行驶费用挂钩，仅使用费用数组按照<span class="keyword">O</span>(n)的时间，或者使用具有<span class="keyword">O</span>(n^<span class="number">2</span>)个项的表按照<span class="keyword">O</span>(<span class="number">1</span>)的时间描述任意两站之间的费用是无意义的，请设计一个结构，它需要<span class="keyword">O</span>(n)的空间，但它允许<span class="keyword">O</span>(<span class="number">1</span>)的时间复杂度求解。
</code></pre><p>驶过两个收费站，就是一段公路，汽车在行驶时，只能连续行驶，不会从这段公路跳到后面的公路。所以就符合连续子向量的求和问题。</p>
<p>可初始化累加数组cum，使得cum[i]=x[0]+…+x[i]，</p>
<p>对于收费站i和j，cum[j] - cum[i-1]就表示在i和j内行驶的路段费用，并且只占用 cum[n]的线性空间。</p>
<hr>
<h2 id="区间赋值问题">区间赋值问题</h2>
<p>对数组array[0…n-1]初始化为全0后，执行n次运算：for i = [l,u] {x[i] += v;}，其中l,u,v是每次运算的参数，0&lt;=l&lt;=u&lt;=n-1。直接用这个伪码需要O(n2)的时间，请给出更快的算法。</p>
<p>初始化y[0,…,n-1]为全0，对每个操作令y[l]+=v和y[u+1]-=v。则结束时x[i]=sigma{k=0 to i}(y[k])。正确性：只需证明每一次执行完操作之后该性质保持不变即可。注意这里的y[i]表示的意义</p>
<hr>
<h2 id="二维连续子数组和">二维连续子数组和</h2>
<p>二维数组连续的二维子数组的和怎么求，肯定是一个矩形，我们要遍历吗？？？<br>遍历的话估计复杂度扛不住吧。。如何遍历也是一个问题。</p>
<p><img src="http://img.blog.csdn.net/20130722170955390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这个时候我们可以把每一行看成是一个元素，这样就变成了一个纵向的一维数组了。</p>
<p><img src="http://img.blog.csdn.net/20130722171123781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这样对一维数组的遍历是和刚才一样的。而对于每一行我们遍历也是和一维是一样的。编码试一试</p>
<pre><code>　<span class="comment">//求二维数组的连续子数组之和的最大值</span>
　　<span class="keyword">int</span> MaxSum(<span class="keyword">int</span> (*<span class="built_in">array</span>)[N])
　　{
　　    <span class="keyword">int</span> i,j;
　　    <span class="keyword">int</span> MaxSum=-INFINITY;<span class="comment">//初始化</span>
　　    <span class="keyword">int</span> imin,imax,jmin,jmax;
　　    <span class="keyword">for</span>(imin=<span class="number">1</span>;imin&lt;=N;imin++)
　　{
　　        <span class="keyword">for</span>(imax=imin;imax&lt;=N;imax++)<span class="comment">//当成是遍历纵向的一维</span>
　　{
　　            <span class="keyword">for</span>(jmin=<span class="number">1</span>;jmin&lt;=M;jmin++)
　　{
　　                <span class="keyword">for</span>(jmax=jmin;jmax&lt;=M;jmax++)<span class="comment">//当成是遍历横向的一维</span>
　　                        MaxSum=MaxNum(MaxSum,PartSum(imin,jmin,imax,jmax));
　　            }
　　}
　　}            
　　    <span class="keyword">return</span> MaxSum;
　　}
　　
</code></pre><p>时间复杂度(N^2<em>M^2</em>O(PartSum))，如何求部分和PartSum呢？如果这个还是要遍历求的话，复杂度真是不敢看了。。<br>    求一维的时候我们求Sum[i-j]很好求，可是求二维的时候就变成了四个坐标了，不敢遍历求和了。我们可以先求部分和，把他当作已知的，这个时候遍历求的时候复杂度就是O(1)。<br>    如何求？我们定义一个部分和数组PartSum，其中PartSum[i][[j]代表了下标(0，0)，(0，j)，(i，0)，(i，j)包围的区间的和。</p>
<p><img src="http://img.blog.csdn.net/20130722171320921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>而此时下标(imin，jmin)，(imin，jmax)，(imax，jmin)，(imax，jmax)包围的区间和就等于</p>
<pre><code>PartSum[<span class="link_label">imax</span>][<span class="link_reference">[jmax</span>]-PartSum[<span class="link_label">imin-1</span>][<span class="link_reference">[jmax</span>]-PartSum[<span class="link_label">imax</span>][<span class="link_reference">[jmin-1</span>]+PartSum[<span class="link_label">imin-1</span>][<span class="link_reference">[jmin-1</span>]。
</code></pre><p><img src="http://img.blog.csdn.net/20130722171448515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这就是我们要求的PartSum(imin,jmin,imax,jmax)，接下来就是求PartSum数组了。如何求呢？<br>对于每一个PartSum[i][[j]都不是孤立的，都是和其他的有关系的。我们要找出这个关系式</p>
<p><img src="http://img.blog.csdn.net/20130722171535921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<pre><code>PartSum[<span class="link_label">i</span>][<span class="link_reference">[j</span>]=PartSum[<span class="link_label">i-1</span>][<span class="link_reference">[j</span>]+PartSum[<span class="link_label">i</span>][<span class="link_reference">[j-1</span>]-PartSum[<span class="link_label">i-1</span>][<span class="link_reference">[j-1</span>]+array[<span class="link_label">i</span>][<span class="link_reference">j</span>]。
</code></pre><p>这样求可以求出全部的PartSum[i][[j]，可是我们不要忽略了一点，PartSum[0][[0]=？对于边界值我们要处理好，而且下标要从1开始。对于PartSum[i][[0]和PartSum[0][[j]都要初始化0，而且array[i][j]的下标也是要-1，因为数组的下标是从0开始的。这是一个办法，不过我们也可以单独求PartSum[i][[0]和PartSum[0][[j]的值，连续相加即可，然后再求其他的也是可以的，空间复杂度也是一样。可是在4重遍历的时候对于PartSum[i][[0]和PartSum[0][[j]我们还是要另外处理，这就比较麻烦了。我们还是用预处理的方法来编码吧。。</p>
<pre><code>    int PartSum<span class="matrix">[N+<span class="number">1</span>]</span><span class="matrix">[M+<span class="number">1</span>]</span>;
　　    int <span class="built_in">i</span>,<span class="built_in">j</span>;
　　    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;=N;<span class="built_in">i</span>++)
　　        PartSum<span class="matrix">[i]</span><span class="matrix">[<span class="number">0</span>]</span>=<span class="number">0</span>;
　　    <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;=M;<span class="built_in">j</span>++)
　　        PartSum<span class="matrix">[<span class="number">0</span>]</span><span class="matrix">[j]</span>=<span class="number">0</span>;
　　    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=N;<span class="built_in">i</span>++)
　　        <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=M;<span class="built_in">j</span>++)
　　        PartSum<span class="matrix">[i]</span><span class="matrix">[j]</span>=PartSum<span class="matrix">[i-<span class="number">1</span>]</span><span class="matrix">[j]</span>+PartSum<span class="matrix">[i]</span><span class="matrix">[j-<span class="number">1</span>]</span>-PartSum<span class="matrix">[i-<span class="number">1</span>]</span><span class="matrix">[j-<span class="number">1</span>]</span>+array<span class="matrix">[i-<span class="number">1</span>]</span><span class="matrix">[j-<span class="number">1</span>]</span>;
</code></pre><p>OK，求得部分和之后我们就开始完善我们的编码了。记住一点，下标(imin,jmin)，(imin,jmax),(imax,jmin),(imax,jmax)包围的区间和等于<br>        PartSum[imax][[jmax]-PartSum[imin-1][[jmax]-PartSum[imax][[jmin-1]+PartSum[imin-1][[jmin-1]。<br>编码开始：</p>
<pre><code><span class="comment">//求二维数组的连续子数组之和的最大值</span>
<span class="keyword">int</span> MaxSum(<span class="keyword">int</span> (*<span class="built_in">array</span>)[N])
{
    <span class="keyword">int</span> PartSum[N+<span class="number">1</span>][M+<span class="number">1</span>];
    <span class="keyword">int</span> i,j;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N;i++)
        PartSum[i][<span class="number">0</span>]=<span class="number">0</span>;
    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=M;j++)
        PartSum[<span class="number">0</span>][j]=<span class="number">0</span>;
    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)
        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=M;j++)
            PartSum[i][j]=PartSum[i-<span class="number">1</span>][j]+PartSum[i][j-<span class="number">1</span>]-PartSum[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="built_in">array</span>[i-<span class="number">1</span>][j-<span class="number">1</span>];
    <span class="keyword">int</span> MaxSum=-INFINITY;<span class="comment">//初始化</span>
    <span class="keyword">int</span> imin,imax,jmin,jmax;
    <span class="keyword">for</span>(imin=<span class="number">1</span>;imin&lt;=N;imin++)
        <span class="keyword">for</span>(imax=imin;imax&lt;=N;imax++)
            <span class="keyword">for</span>(jmin=<span class="number">1</span>;jmin&lt;=M;jmin++)
                <span class="keyword">for</span>(jmax=jmin;jmax&lt;=M;jmax++)
                        MaxSum=MaxNum(MaxSum,PartSum[imax][jmax]-PartSum[imin-<span class="number">1</span>][jmax]-PartSum[imax][jmin-<span class="number">1</span>]+PartSum[imin-<span class="number">1</span>][jmin-<span class="number">1</span>]);

    <span class="keyword">return</span> MaxSum;
}
</code></pre><p>时间复杂度是O(N^2*M^2)，有点坑啊。想一想一维的时候我们用DP来做，这个也可以吗？可以的。我们把每一列看成一个元素。这样对于遍历的行区间，我们就可以当成一维来做。</p>
<p><img src="http://img.blog.csdn.net/20130722171750125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VzdGxpYW5nYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>对于imin和imax之间的每一列，就相当于一维的一个元素。</p>
<p>假设这个一维数组是BC，则BC[j]=array[imin][j]+….+array[imax][j]，问题就变成了求BC数组的连续子数组之和的最大值了。而根据刚才求的部分和，我们可以知道对于imin行和imax行之间的区间第j列的值是</p>
<p>BC(PartSum,imin,imax,j)=PartSum[imax][j]-PartSum[imin-1][j]-PartSum[imax][j-1]+PartSum[imin-1][j-1].（此时BC是一个函数）<br>OK，编码开始</p>
<pre><code><span class="comment">//求二维数组的连续子数组之和的最大值</span>
<span class="keyword">int</span> MaxSum(<span class="keyword">int</span> (*array)[N])
{
    <span class="keyword">int</span> PartSum[N+<span class="number">1</span>][M+<span class="number">1</span>];
    <span class="keyword">int</span> i,j;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N;i++)
        PartSum[i][<span class="number">0</span>]=<span class="number">0</span>;
    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=M;j++)
        PartSum[<span class="number">0</span>][j]=<span class="number">0</span>;
    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)
        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=M;j++)
            PartSum[i][j]=PartSum[i-<span class="number">1</span>][j]+PartSum[i][j-<span class="number">1</span>]-PartSum[i-<span class="number">1</span>][j-<span class="number">1</span>]+array[i-<span class="number">1</span>][j-<span class="number">1</span>];
    <span class="keyword">int</span> MaxSum=-INFINITY;
    <span class="keyword">int</span> Start,All;
    <span class="keyword">int</span> imin,imax;
    <span class="keyword">for</span>(imin=<span class="number">1</span>;imin&lt;=N;imin++)
    {
        <span class="keyword">for</span>(imax=imin;imax&lt;=N;imax++)
        {
            Start=BC(PartSum,imin,imax,M);
            All=BC(PartSum,imin,imax,M);
            <span class="keyword">for</span>(j=M-<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)
            {
                <span class="keyword">if</span>(Start&gt;<span class="number">0</span>)
                    Start+=BC(PartSum,imin,imax,j);
                <span class="keyword">else</span>
                    Start=BC(PartSum,imin,imax,j);
                <span class="keyword">if</span>(Start&gt;All)
                    All=Start;
            }
            <span class="keyword">if</span>(All&gt;MaxSum)
                MaxSum=All;
        }
    }
    <span class="keyword">return</span> MaxSum;
}

<span class="keyword">int</span> BC(<span class="keyword">int</span> (*PartSum)[N+<span class="number">1</span>],<span class="keyword">int</span> imin,<span class="keyword">int</span> imax,<span class="keyword">int</span> j) <span class="comment">//imin--imax第j列的和</span>
{
    <span class="keyword">int</span> <span class="keyword">value</span>;
    <span class="keyword">value</span>=PartSum[imax][j]-PartSum[imin-<span class="number">1</span>][j]-PartSum[imax][j-<span class="number">1</span>]+PartSum[imin-<span class="number">1</span>][j-<span class="number">1</span>];
    <span class="keyword">return</span> <span class="keyword">value</span>;
}
</code></pre><p>时间辅助度降到O(N<em>M</em>min(M,N)),差不多O(N^3)吧。</p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ul>
<li><p>Programming pearls <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/zhoudaxia/article/details/5649991" target="_blank" rel="external">最大子序列问题</a></p>
</li>
<li><p><a href="http://blog.csdn.net/liangbopirates/article/details/9411335" target="_blank" rel="external">求数组的连续子数组之和的最大值（一维二维）</a></p>
</li>
</ul>
]]></content>
    
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析单调队列]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>http://zhonghuan.info/2014/09/16/浅析单调队列/</id>
    <published>2014-09-16T08:04:36.000Z</published>
    <updated>2014-09-16T08:06:04.000Z</updated>
    <content type="html"><![CDATA[<p>大家应该了解什么是队列，那么在队列前面加上“单调”，意思也是显而易见的，就是这个队列是从前往后单调递增或者单调递减的。</p>
<p>如：{a1,a2,a3,a4……an}满足a1&lt;=a2&lt;=a3……&lt;=an,a序列便是单调递增序列。同理递减队列也是存在的。</p>
<pre><code>单调队列的出现可以简化问题，队首元素便是最大（小）值，这样，选取最大（小）值的复杂度便为o（1），由于队列的性质，每个元素入队一次，出队一次，维护队列的复杂度均摊下来便是o（1）。
</code></pre><p>如何维护单调队列呢，以单调递增序列为例：</p>
<ol>
<li><p>如果队列的长度一定，先判断队首元素是否在规定范围内，如果超范围则增长队首。</p>
</li>
<li><p>每次加入元素时和队尾比较，如果当前元素小于队尾且队列非空，则减小尾指针，队尾元素依次出队，直到满足队列的调性为止。</p>
</li>
</ol>
<p>例如：</p>
<pre><code><span class="input"><span class="prompt">队列是一个单调递增的队列：
1 ，5 ， 7 ， 9。    现在要插入一个 6；
因为 9 &gt;</span> <span class="number">6</span> ,所以  <span class="number">9</span>  出队列</span>
<span class="input"><span class="prompt">---&gt;</span> <span class="number">1</span> ， <span class="number">5</span>， <span class="number">7</span>。   </span>
<span class="input"><span class="prompt">因为要 7 &gt;</span> <span class="number">6</span> ,所以 <span class="number">7</span> 出队列</span>
<span class="input"><span class="prompt">---&gt;</span> <span class="number">1</span>, <span class="number">5</span> . </span>
<span class="input"><span class="prompt">6放在队列尾部,最终队列变为：
---&gt;</span> <span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>.</span>
</code></pre><p>说完了单调队列的性质，那么我们该如何运用呢？</p>
<hr>
<h2 id="简单的单调队列的应用：">简单的单调队列的应用：</h2>
<hr>
<h3 id="1-果子合并问题">1.果子合并问题</h3>
<p>【问题描述】<br> 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 </p>
<p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 </p>
<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 </p>
<p>例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。 </p>
<p>【输入文件】 </p>
<p> 输入文件fruit.in包括两行，第一行是一个整数n(1&lt;＝n&lt;=10000)，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai(1&lt;＝ai&lt;=20000)是第i种果子的数目。 </p>
<p>【输出文件】 </p>
<p> 输出文件fruit.out包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于231。 </p>
<p>【样例输入】 </p>
<pre><code>3 
1 2 9 
</code></pre><p>【样例输出】 </p>
<pre><code>15 
</code></pre><p>【数据规模】 </p>
<pre><code><span class="xml">对于30％的数据，保证有n<span class="tag">&lt;<span class="title">=1000：</span> 
对于<span class="attribute">50</span>％的数据，保证有<span class="attribute">n</span>&lt;=<span class="value">5000；</span> 
对于全部的数据，保证有<span class="attribute">n</span>&lt;=<span class="value">10000。</span></span></span>
</code></pre><p>这个题目非常的经典，发放也很多，可以采用快排或者堆，其思想都是选取当前最小的两个堆进行合并。复杂度均为O(nlogn)，如果用有序队列维护，时间复杂度为O（n）。</p>
<p>每次选取进行合并的两堆，不是最先给定的堆，就是合并最初堆若干次后得到的新堆，所以需要维护两个单调递增队列，一个队列存最初给定的堆的值（1），一个存合并后得到的新值（2）。</p>
<p>每次选择时有三种状态：</p>
<ol>
<li><p>选取队一的队首两个</p>
</li>
<li><p>选取队2的的队首两个</p>
</li>
<li><p>选取二者队首各一个</p>
</li>
</ol>
<p>只需对每个队列的指针做相应的更改。</p>
<p>特别注意初始化。</p>
<p>这道题很好的运用了题目中决策的单调性，对初始对经行排序，保证了其单调性。而对于新产生的堆来说，一旦有新元素加入其中，则新元素一定大于原有元素。（很显然，由于队列1的单调性）。</p>
<p>也就是说，队列的单调性是自然而然的。是不需要维护的。要善于观察分析，才能发现。</p>
<hr>
<h3 id="Window">Window</h3>
<h4 id="_poj2823_"><a href="http://poj.org/problem?id=2823" target="_blank" rel="external"> poj2823 </a></h4>
<p>Description</p>
<p>An array of size n ≤ 106 is given to you. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves rightwards by one position. Following is an example: </p>
<p>The array is [1 3 -1 -3 5 3 6 7], and k is 3.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Window position</th>
<th style="text-align:center">Minimum value</th>
<th style="text-align:center">Maximum value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[1  3  -1] -3  5  3  6  7</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">1 [3  -1  -3] 5  3  6  7</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">1  3 [-1  -3  5] 3  6  7</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1 [-3  5  3] 6  7</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1  -3 [5  3  6] 7</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1  -3  5 [3  6  7]</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>Your task is to determine the maximum and minimum values in the sliding window at each position. </p>
<p>Input</p>
<p>The input consists of two lines. The first line contains two integers n and k which are the lengths of the array and the sliding window. There are n integers in the second line. </p>
<p>Output</p>
<p>There are two lines in the output. The first line gives the minimum values in the window at each position, from left to right, respectively. The second line gives the maximum values.<br>Sample Input</p>
<pre><code>8 3
1 3 -1 -3 5 3 6 7
</code></pre><p>Sample Output</p>
<pre><code>-<span class="ruby"><span class="number">1</span> -<span class="number">3</span> -<span class="number">3</span> -<span class="number">3</span> <span class="number">3</span> <span class="number">3</span>
</span>3 3 5 5 6 7
</code></pre><p>题目大意：给出一组数，一个固定大小的窗体在这个数组上滑动，要求出每次滑动该窗体内的最大值和最小值。</p>
<p>这就是典型的单调队列，单调队列的作用就在此。单调队列的队首为区间内的最值，可是整个队列不用保持单调。</p>
<p>用两个队列分别处理最大值和最小值，在此说明一下最大值；</p>
<p>往队列中加入值num时，从队尾開始扫，直到遇到一个小于num的d值，将num插入d的后一位。之后的元素所有无效化（无论后面的元素即可）。查找最大值的时候，从队首開始找，假设该元素没在此时的区间的话，查找下一个，直到找到满足条件的第一个元素，这个元素便是最值。</p>
<p>求最小值和最大值大同小异，仅仅须要将加入值num的条件改一下就可以。</p>
<hr>
<h3 id="广告印刷">广告印刷</h3>
<p>【问题描述】</p>
<p>　　最近，afy决定给TOJ印刷广告，广告牌是刷在城市的建筑物上的，城市里有紧靠着的N个建筑。afy决定在上面找一块尽可能大的矩形放置广告牌。我们假设每个建筑物都有一个高度，从左到右给出每个建筑物的高度H1,H2…HN，且0&lt;Hi&lt;=1,000,000,000，并且我们假设每个建筑物的宽度均为1。要求输出广告牌的最大面积。</p>
<p>【输入文件】</p>
<p>第一行是一个数n (n&lt;= 400,000 ）</p>
<p>第二行是n个数，分别表示每个建筑物高度H1,H2…HN，且0&lt;Hi&lt;=1,000,000,000。</p>
<p>【输出文件】</p>
<p>输出文件 ad.out 中一共有一行，表示广告牌的最大面积。</p>
<p>【输入样例】</p>
<pre><code>6

5 8 4 4 8 4
</code></pre><p>【输出样例】</p>
<pre><code>24
</code></pre><p>【分析】</p>
<p>最终的广告牌一定等于某个建筑物的高度×其能达到的最大长度</p>
<p>现在，建筑物的高度已知，现在只需要知道每个高度能达到的最大长度是多少。由于n是400000，我们只能用O（n）或O（nlogn）的算法。可以使用rmq，在后边的论文中会讲到。</p>
<p>现在讲时间复杂度为o（n）的单调队列的方法。</p>
<p>继续上边的思路，对于每个建筑物，只需要找到其能够扩展到的最大宽度即可。也就是这个建筑物的左右两边的比它低或等于它的建筑物个数。</p>
<p>如何用单调队列呢？</p>
<p>我们从1~n一次进队，维护一个单调递减序列。每次加入元素后维护其单调性，当然这样做必然会使一些元素出队，出队的元素一定要比当前加入的元素小，也就是说当前元素就是出队的元素能在右侧达到的最远的建筑物！</p>
<p>注意，要让h[n+1]=0并且让该元素入队一次（会使当前队列中的所有元素出队），保证每个元素都有其“右极限”的值。</p>
<p>要求“左极限”同理，只需从n~0循环即可，注意0</p>
<p>这道题是对单调队列的变形使用。由于问题的结果具有单调性，很好的利用出队元素的特性.</p>
<hr>
<h2 id="单调队列在动态规划中的应用">单调队列在动态规划中的应用</h2>
<p> 做动态规划时常常会见到形如这样的转移方程：</p>
<p>　　f[x] = max or min{g(k) | b[x] &lt;= k &lt; x} + w[x]</p>
<p>　　(其中b[x]随x单调不降，即b<a href="http://www.cnblogs.com/neverforget/archive/2011/10/13/ll.html" target="_blank" rel="external">1</a>&lt;=b<a href="http://blog.csdn.net/job_yi/article/details/10103509" target="_blank" rel="external">2</a>&lt;=b[3]&lt;=…&lt;=b[n])</p>
<p>　　(g[k]表示一个和k或f[k]有关的函数，w[x]表示一个和x有关的函数)</p>
<p>　　这个方程怎样求解呢？我们注意到这样一个性质：如果存在两个数j, k，使得j &lt;= k，而且g(k) &lt;= g(j)，则决策j是毫无用处的。因为根据b[x]单调的特性，如果j可以作为合法决策，那么k一定可以作为合法决策，又因为k比j要优，（注意：在这个经典模型中，“优”是绝对的，是与当前正在计算的状态无关的），所以说，如果把待决策表中的决策按照k排序的话，则g(k)必然是不降的。</p>
<p>　　这样，就引导我们使用一个单调队列来维护决策表。对于每一个状态f(x)来说，计算过程分为以下几步：</p>
<ol>
<li><p>队首元素出队，直到队首元素在给定的范围中。</p>
</li>
<li><p>此时，队首元素就是状态f(x)的最优决策，</p>
</li>
<li><p>计算g(x)，并将其插入到单调队列的尾部，同时维持队列的单调性（不断地出队，直到队列单调为止）。</p>
</li>
</ol>
<p>　　重复上述步骤直到所有的函数值均被计算出来。不难看出这样的算法均摊时间复杂度是O(1)的。因此求解f(x)的时间复杂度从O(n^2)降到了O(n)。</p>
<p>单调队列指一个队列中的所有的数符合单调性（单调增或单调减），在信息学竞赛的一些题目上应用，会减少时间复杂度</p>
<p>单调队列的每个元素一般会存储两个值：</p>
<p>1.在原数列中的位置（下标）</p>
<p>2.该元素在动态规划中的状态值（价值）</p>
<p>单调队列同时保证这两个值单调。</p>
<hr>
<p> 烽火传递</p>
<p>描述 Description  </p>
<p>烽火台又称烽燧，是重要的防御设施，一般建在险要处或交通要道上。一旦有敌情发生，白天燃烧柴草，通过浓烟表达信息：夜晚燃烧干柴，以火光传递军情。在某两座城市之间有n个烽火台，每个烽火台发出信号都有一定的代价。为了使情报准确的传递，在m个烽火台中至少要有一个发出信号。现输入n、m和每个烽火台发出的信号的代价，请计算总共最少需要话费多少代价，才能使敌军来袭之时，情报能在这两座城市之间准确的传递！！！</p>
<p>输入格式 Input Format</p>
<pre><code>     第一行有两个数n,m分别表示n个烽火台，在m个烽火台中至少要有一个发出信号。

     第二行为n个数，表示每一个烽火台的代价。
</code></pre><p>输出格式 Output Format     </p>
<pre><code>    一个数，即最小代价。       
</code></pre><p>样例</p>
<p>输入：</p>
<pre><code>5 3    
1 2 5 6 2
</code></pre><p>输出：</p>
<pre><code>4
</code></pre><p>时间限制 Time Limitation    </p>
<pre><code>    各个测试点1s
</code></pre><p>注释 Hint      </p>
<pre><code><span class="attribute">    1&lt;</span>=<span class="string">n,m&lt;=1,000,000</span>
</code></pre><p>分析</p>
<p>要用动态规划的方法解决。我们可以写出这样的方程f[i]:=min{f[j]}+a[i]（i-m&lt;=j&lt;i-1）（因为要保证i之前的3个中必须存在被点亮的烽火台）。单纯这样循环会造成超时。</p>
<p>我们想到了用单调队列进行优化，由于随着i的循环，每次只有一个i进入决策区间也只有一个i出决策区间，由于每次选取决策区间中的最小值，所以维护一个单调递增序列，每次取出队首元素即可。</p>
<p>为什么可以将队尾元素无情的删去呢？由于后进队的序列同时满足在原序列中的位置更靠后和其在动态规划中的价值更大。这样选取这个元素就要比选取之前的任何一个决策要优，所以之前被删掉的决策都是无用的。</p>
<p>这道题的本质就是用单调队列维护了决策本身的价值和其在原序列中位置的同时单调。</p>
<p>要特别注意单调队列中的值是决策在原决策序列中的位置。</p>
<hr>
<h2 id="参考资料：">参考资料：</h2>
<ul>
<li><p><a href="http://www.cnblogs.com/neverforget/archive/2011/10/13/ll.html" target="_blank" rel="external">单调队列及其应用</a>  <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/job_yi/article/details/10103509" target="_blank" rel="external">合并果子【单调队列】</a></p>
</li>
</ul>
]]></content>
    
    
      <category term="单调队列" scheme="http://zhonghuan.info/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[“浅析kmp算法”]]></title>
    <link href="http://zhonghuan.info/2014/09/16/%E2%80%9C%E6%B5%85%E6%9E%90kmp%E7%AE%97%E6%B3%95%E2%80%9D/"/>
    <id>http://zhonghuan.info/2014/09/16/“浅析kmp算法”/</id>
    <published>2014-09-16T08:00:57.000Z</published>
    <updated>2014-09-16T08:03:11.000Z</updated>
    <content type="html"><![CDATA[<p>首先，KMP是一个字符串匹配算法，什么是字符串匹配呢？简单地说，有一个字符串“BBC ABCDAB ABCDABCDABDE”，我想知道这个字符串里面是否有“ABCDABD”；我想，你的脑海中马上就浮现了一个简单的暴力算法，是的，它也有名字，叫做暴力匹配，就是从头开始进行匹配，如果不行的话，就从主字符串的下一个继续。看下面的图结合文字会更清晰些：</p>
<hr>
<h2 id="暴力匹配：">暴力匹配：</h2>
<p>1 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf1.png" alt=""></p>
<p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<p>2 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf2.png" alt=""><br>因为B与A不匹配，搜索词再往后移。</p>
<p>3 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf3.png" alt=""><br>就这样，直到字符串有一个字符，与搜索词的第一个字符相同。</p>
<p>4 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf4.png" alt=""><br>接着比较字符串和搜索词的下一个字符，还是相同。</p>
<p>5 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf5.png" alt=""><br>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<p>6 <img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_bf6.png" alt=""><br>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。</p>
<p>虽然这样做可行，但是你有没有想过这样的效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<hr>
<h2 id="真前缀和真后缀，部分匹配值">真前缀和真后缀，部分匹配值</h2>
<p>上面说了，暴力匹配的效率是非常低下的，但是我们有什么办法让效率提升呢？让我们先来了解三个概念，“真前缀”和“真后缀”；这个比较好理解，看下面就可以理解了。</p>
<pre><code>　　－　<span class="string">"A"</span>的真前缀和真后缀都为空集，共有元素的长度为<span class="number">0</span>；
　　－　<span class="string">"AB"</span>的真前缀为[<span class="literal">A</span>]，真后缀为[B]，共有元素的长度为<span class="number">0</span>；
　　－　<span class="string">"ABC"</span>的真前缀为[<span class="literal">A</span>, AB]，真后缀为[BC, C]，共有元素的长度<span class="number">0</span>；
　　－　<span class="string">"ABCD"</span>的真前缀为[<span class="literal">A</span>, AB, ABC]，真后缀为[BCD, CD, D]，共有元素的长度为<span class="number">0</span>；
　　－　<span class="string">"ABCDA"</span>的真前缀为[<span class="literal">A</span>, AB, ABC, ABCD]，真后缀为[BCDA, CDA, DA, <span class="literal">A</span>]，共有元素为<span class="string">"A"</span>，长度为<span class="number">1</span>；
　　－　<span class="string">"ABCDAB"</span>的真前缀为[<span class="literal">A</span>, AB, ABC, ABCD, ABCDA]，真后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为<span class="string">"AB"</span>，长度为<span class="number">2</span>；
　　－　<span class="string">"ABCDABD"</span>的真前缀为[<span class="literal">A</span>, AB, ABC, ABCD, ABCDA, ABCDAB]，真后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为<span class="number">0</span>。
</code></pre><p>从上面的例子可以体会到吧，真前缀就是从字符串第一个字符开始的所有字符串，但是不包括它自身；对于真后缀同理。</p>
<p>那么什么是部分匹配值呢？注意到上面提到的共有元素的长度了吗？部分匹配值的意思就是当前串的真前缀和真后缀中字符串相同的最大长度。“AB”的真前缀和真后缀中没有相同的，所以部分匹配值是0；“ABAB”的部分匹配值是2，因为真前缀中的“AB”和真后缀中的“AB”匹配，长度为2，所以部分匹配值是2。</p>
<hr>
<h2 id="如何使用部分匹配值呢？">如何使用部分匹配值呢？</h2>
<p>让我们来看一些前面的例子，在“BBC ABCDAB ABCDABCDABDE”中匹配“ABCDABD”。</p>
<p>首先看一下ABCDABD的部分匹配表：</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial1.png" alt=""></p>
<p>部分匹配表中的每一个值，对应的都是每一个字符为结尾的子串的部分匹配值。像“AB”，部分匹配值是0，所以对应的表里的值是0；“ABCDAB”，部分匹配值是2，所以对应的表里的值是2；</p>
<p>那么我们如何来用它呢？上面的暴力匹配我们说了，当ABCDABD的最后一个D和“ ”不匹配时，暴力匹配方式只会把ABCDABD右移一位，然后继续匹配。我们前面也说了，这样的方式没有充分利用一些信息。</p>
<p>那么我们该如何利用上面的信息呢？</p>
<p>比如前面我们说的情况，看下面的图：<br><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial2.png" alt=""></p>
<p>前面的这个时候，我们只是让“ABCDABD”右移一位。但是有没有发现，其实前面已经匹配上的“ABCDAB”这一部分的信息都知道，所以我们知道“ABCDAB”右移一位依然无法匹配，这个时候，我们只需要考虑ABCDAB的真前缀和真后缀匹配最多，如果我们知道这个真前缀和真后缀，那么我们就知道如何移动了。只需要移动至真前缀和真后缀部分匹配即可。而这里就是需要考虑部分匹配值了。</p>
<p>为什么是这样呢？我们可以简单地证明一下。我们知道“ABCDAB”的部分匹配值，2，也就是说真前缀和真后缀最大的匹配长度是“AB”这一部分。我们只需要将“ABCDAB”的前缀的“AB”移动至和后缀的“AB”匹配。假设我们不移动到它们匹配，在前面部分也可能匹配，那么它们的部分匹配值应该更大，但是这里最大就是2了。所以，假设不成立。所以我们只需要将最长的 真前缀和真后缀 匹配即可。</p>
<p>匹配的时候，我们可以利用部分匹配值。</p>
<p><strong><em>移动位数 = 已匹配的字符数 - 对应的部分匹配值</em></strong></p>
<p>对于“ABCDAB”，部分匹配值2，6-2=4；所以将搜索词向后移动4位即可。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial3.png" alt=""></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial4.png" alt=""></p>
<p>因为空格与A不匹配，继续后移一位。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial5.png" alt=""></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_partial6.png" alt=""></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<hr>
<h2 id="寻找部分匹配值">寻找部分匹配值</h2>
<p>现在的问题是，我们如何来寻求这个部分匹配值，在上面的过程中，我们可以发现，只要我们知道部分匹配值了，就能够让匹配的速度加快。而对于部分匹配值，我们关心的其实就是那个搜索词。所以从搜索词入手。</p>
<p>我们定义这样一个数组next[]，T标示匹配字符串，P标示搜索词。</p>
<p>那么next数组表示什么呢？看下面的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">搜索词</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">D</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>和上面的部分匹配表对比一下，你会发现，next数组就是 部分匹配值   整体向右移动了一位， 然后初始值赋值为 -1。</p>
<p>其实next数组也有含义，next[j]的值表示，当P[j] != T[i]时，指针 j 的下一步移动位置。</p>
<p>当j=0时不匹配怎么办？这个时候next[j]= -1；表示T需要左移1位。</p>
<p>所以当 P[j] != T[i] 时, 另 j = next[j] ，然后继续匹配。</p>
<p>当 P[j] == T[i] 时，i和j 分别都前进一位。</p>
<p>那么next数组该怎么求解呢？</p>
<p>当P[k] == P[i] 时，有 next[j+1] = next[j] +1;</p>
<p>当P[k] != P[i] 时，有 k = next[k]; 然后继续匹配。</p>
<p>如果 k == -1； 那么这个时候，表示P的第0字符都和现在的第i个字符不匹配，则 next[i] = 0; k++, i++;</p>
<p>所以，综上，便有了下面的程序。下面的getNext是获得next数组，KMP是进行匹配，下面的程序是poj3461 的示例程序。</p>
<pre><code>import  java.util.Scanner;

<span class="keyword">public</span> <span class="keyword">class</span> Main{

    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">getNext</span>(String P){
        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length()];  <span class="comment">// next 数组表示的是当 P[i]和P[k]不匹配时，k应该跳转到哪一个位置</span>
                                            <span class="comment">//这里的i时后缀指针，  k是前缀指针</span>

        next[<span class="number">0</span>]=-<span class="number">1</span>;  <span class="comment">// 因为开头的比较特殊，如果它不匹配，那么移动的应该是T，T应该左移,-1标示T左移</span>

        <span class="keyword">int</span> i=<span class="number">0</span>,k=-<span class="number">1</span>;

        <span class="keyword">while</span>(i &lt; P.length()-<span class="number">1</span>)
        {
            <span class="keyword">if</span>(k&lt;<span class="number">0</span> || P.charAt(i) == P.charAt(k))
            {
                next[++i] = ++k;
            }<span class="keyword">else</span>
                k = next[k];
        }

        <span class="keyword">return</span> next;

    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span>(String T, String P){

        <span class="keyword">int</span> res=<span class="number">0</span>;

        <span class="keyword">int</span>[] next = getNext(P);

        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;

        <span class="keyword">while</span>(<span class="keyword">true</span>)
        {

            <span class="keyword">if</span>(i &gt;= T.length())
                <span class="keyword">break</span>;
            <span class="keyword">if</span>( j==-<span class="number">1</span> || T.charAt(i) == P.charAt(j))
            {
                j++;
                <span class="keyword">if</span>(j == P.length())
                {
                    res++;
                    j = next[j-<span class="number">1</span>];
                }<span class="keyword">else</span>
                    i++;
            }<span class="keyword">else</span>
                j = next[j];

        }

        <span class="keyword">return</span> res;
    }


    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){
        Scanner scan = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);
        <span class="keyword">int</span> n = scan.nextInt();
        scan.nextLine();
        <span class="keyword">while</span>(n&gt;<span class="number">0</span>){
            String P = scan.nextLine();
            String T = scan.nextLine();

            System.<span class="keyword">out</span>.println(KMP(T,P));

            n--;
        }

    }

    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span>(String args[]){

        <span class="keyword">new</span> Main().run();

    }
}
</code></pre><hr>
<h2 id="拓展">拓展</h2>
<h3 id="最小覆盖字串">最小覆盖字串</h3>
<p>最小覆盖子串（串尾多一小段时，用前缀覆盖）长度为n-next[n]（n-pre[n]），n为串长。</p>
<p>证明分两部分：</p>
<p>１－长为n-next[n]的前缀必为覆盖子串。</p>
<p>当next[n]&lt;n-next[n]时，如图a，长为next[n]的前缀A与长为next[n]的后缀B相等，故长为n-next[n]的前缀C必覆盖后缀B；</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_least1.gif" alt=""></p>
<p>当next[n]&gt;n-next[n]时，如图b，将原串X向后移n-next[n]个单位得到Y串，根据next的定义，知长为next[n]的后缀串A与长为前缀串B相等，X串中的长为n-next[n]的前缀C与Y串中的前缀D相等，而X串中的串E又与Y串中的D相等……可见X串中的长为n-next[n]的前缀C可覆盖全串。</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_least2.gif" alt=""></p>
<p>２－长为n-next[n]的前缀是最短的。</p>
<p>如图c，串A是长为n-next[n]的前缀，串B是长为next[n]的后缀，假设存在长度小于n-next[n]的前缀C能覆盖全串，则将原串X截去前面一段C，得到新串Ｙ，则Ｙ必与原串长度大于next[n]的前缀相等，与next数组的定义（使str[1..i]前k个字母与后k个字母相等的最大k值。）矛盾。得证！有人问，为什么Ｙ与原串长大于next[n]的前缀相等？由假设知原串的构成必为CCC……E（E为C的前缀），串Ｙ的构成必为CC……E（比原串少一个Ｃ），懂了吧！</p>
<p><img src="http://zhonghuan.qiniudn.com/algorithm%2FKMP%2Fkmp_least3.gif" alt=""></p>
<p>一个字符串A(1 &lt;= |A| &lt;= 1000000)可以写成某一个子串B重复N次所得，记为A = B^N，求最大的N。</p>
<p>算法分析：</p>
<p>令L = |A|，容易发现，用KMP自匹配后L - p[L]即得到最小覆盖子串的长度。<br>下面我们要证明一个问题：一个字符串的覆盖子串长度，一定是它的最小覆盖子串长度的倍数。<br>设最小覆盖子串长度d整除L, 假设存在u &gt; d满足u整除L且d不整除u。<br>易得，A<em>i = A</em>(i + d)，A<em>i = A</em>(i + u)，则A<em>(i + d) = A</em>(i + u)，即A<em>i = A</em>(i + u - d)，不断进行可得到A_i = A(i + u - kd)（k为正整数）。<br>因为d不整除u，那么必然存在k使得0 &lt; u - kd &lt; d，与d是最小循环子串长度矛盾。<br>所以，最小覆盖子串长度若为L的约数则得解否则输出1。时间复杂度O(L)。</p>
<p>最小覆盖字串的例题  poj2406   ， 代码可以参考以下：</p>
<pre><code>import  java.util.Scanner;

<span class="keyword">public</span> <span class="keyword">class</span> Main{

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(String P){
        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length()+<span class="number">10</span>];  <span class="comment">// next 数组表示的是当 P[i]和P[k]不匹配时，k应该跳转到哪一个位置</span>
                                            <span class="comment">//这里的i时后缀指针，  k是前缀指针</span>
        next[<span class="number">0</span>]=-<span class="number">1</span>;  <span class="comment">// 因为开头的比较特殊，如果它不匹配，那么移动的应该是T，T应该左移,-1标示T左移</span>

        <span class="keyword">int</span> i=<span class="number">0</span>,k=-<span class="number">1</span>;

        <span class="keyword">while</span>(i &lt; P.length())
        {
            <span class="keyword">if</span>(k&lt;<span class="number">0</span> || P.charAt(i) == P.charAt(k))
            {
                next[++i] = ++k;
            }<span class="keyword">else</span>
                k = next[k];
        }

        <span class="keyword">return</span> P.length()-next[P.length()];
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){
        Scanner scan = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);
        <span class="keyword">while</span>(scan.hasNext()){
            String P = scan.nextLine();

            <span class="keyword">if</span>(P.charAt(<span class="number">0</span>)==<span class="string">'.'</span>)
                <span class="keyword">break</span>;

            <span class="keyword">int</span> t = getNext(P);
            <span class="keyword">int</span> len = P.length();

            <span class="keyword">if</span>(len%t == <span class="number">0</span>)
            {
                System.<span class="keyword">out</span>.println(len/t);
            }<span class="keyword">else</span>
                System.<span class="keyword">out</span>.println(<span class="number">1</span>);
        }

    }

    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span>(String args[]){

        <span class="keyword">new</span> Main().run();

    }
}
</code></pre><hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p><a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="external">The Knuth-Morris-Pratt Algorithm in my own words</a> : <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="external">字符串匹配的KMP算法</a> : <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">从头到尾彻底理解KMP</a> : <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="external">详解KMP算法</a></p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Knuth–Morris–Pratt algorithm</a> <strong>[推荐]</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/fjsd155/article/details/6866991" target="_blank" rel="external">KMP与最小覆盖子串</a> </p>
</li>
</ul>
]]></content>
    
    
      <category term="KMP" scheme="http://zhonghuan.info/tags/KMP/"/>
    
      <category term="algorithm" scheme="http://zhonghuan.info/tags/algorithm/"/>
    
      <category term="字符串匹配" scheme="http://zhonghuan.info/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="算法" scheme="http://zhonghuan.info/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式和python的re模块]]></title>
    <link href="http://zhonghuan.info/2014/09/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cpython%E7%9A%84re%E6%A8%A1%E5%9D%97/"/>
    <id>http://zhonghuan.info/2014/09/04/正则表达式和python的re模块/</id>
    <published>2014-09-04T15:04:30.000Z</published>
    <updated>2014-09-04T15:26:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是正则表达式">什么是正则表达式</h2>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。正则表达式就是记录文本规则的代码，换句话说，正则表达式是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”）。模式描述在搜索文本时要匹配的一个或多个字符串。</p>
<pre><code>字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。
</code></pre><p>假设你要在英文小说中查找Hi，那么使用的正则表达式就是<code>Hi</code>，这个很简单吧，不过，通常处理正则表达式的工具（例如后面会提到的python的re模块）会提供忽略大小写的选项。</p>
<p>不幸的是，很多单词里都包含了很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\bhi\b</code>。</p>
<pre><code><span class="command">\b</span>是正则表达式规定的一个特殊代码（这里称为元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。
</code></pre><p>假设你要找的Hi后面不远处有一个ZH，那么可以用<code>\bhi\b.*\bZH\b</code>.</p>
<pre><code>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<span class="keyword">*</span>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定<span class="keyword">*</span>前边的内容可以连续重复使用任意次以使整个表达式得到匹配,例如，zo<span class="keyword">*</span> 能匹配 <span class="string">"z"</span> 以及 <span class="string">"zoo"</span>等 。
</code></pre><p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：<br><code>0\d\d-\d\d\d\d\d\d\d\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p>
<p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。</p>
<p>下面来看看更多的例子：<br><code>\ba\w*\b</code>匹配以字母a开头的单词——先是某个单词开始处(<code>\b</code>)，然后是字母a,然后是任意数量的字母或数字(<code>\w*</code>)，最后是单词结束处(<code>\b</code>)。<br>好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的<code>\w</code>。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)<br><code>\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<code>*</code>类似的元字符，不同的是*匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。<br><code>\b\w{6}\b</code> 匹配刚好6个字符的单词。</p>
<hr>
<h2 id="元字符使用一览表：">元字符使用一览表：</h2>
<p>上面介绍了部分的metacharacter，下面给出元字符一览表，使用时可以查找。</p>
<div class="caption"></div><div class="tableSection"><table width="50%" frame="lhs"><tr><th><p>字符</p></th><th><p>说明</p></th></tr><tr><td><p>\</p></td><td><p>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\”匹配“\”，“(”匹配“(”。</p></td></tr><tr><td><p>^</p></td><td><p>匹配输入字符串开始的位置。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b> 属性，^ 还会与“\n”或“\r”之后的位置匹配。</p></td></tr><tr><td><p>$</p></td><td><p>匹配输入字符串结尾的位置。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b> 属性，$ 还会与“\n”或“\r”之前的位置匹配。</p></td></tr><tr><td><p><em> </em></p></td><td><p>零次或多次匹配前面的字符或子表达式。例如，zo 匹配“z”和“zoo”。<em> 等效于 {0,}。</em></p></td></tr><tr><td><p>+</p></td><td><p>一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。</p></td></tr><tr><td><p>?</p></td><td><p>零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。</p></td></tr><tr><td><p>{<i>n</i>}</p></td><td><p><i>n </i>是非负整数。正好匹配 <i>n</i> 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。</p></td></tr><tr><td><p>{<i>n</i>,}</p></td><td><p><i>n </i>是非负整数。至少匹配 <i>n </i>次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o ”。</p></td></tr><tr><td><p>{<i>n</i>,<i>m</i>}</p></td><td><p><i>M</i> 和 <i>n</i> 是非负整数，其中 <i>n</i> &lt;= <i>m</i>。匹配至少 <i>n</i> 次，至多 <i>m</i> 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</p></td></tr><tr><td><p>?</p></td><td><p>当此字符紧随任何其他限定符（*、+、?、{<i>n</i>}、{<i>n</i>,}、{<i>n</i>,<i>m</i>}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。</p></td></tr><tr><td><p>.</p></td><td><p>匹配除“\n”之外的任何单个字符。若要匹配包括“\n”在内的任意字符，请使用诸如“[\s\S]”之类的模式。</p></td></tr><tr><td><p>(<i>pattern</i>)</p></td><td><p>匹配 <i>pattern</i> 并捕获该匹配的子表达式。可以使用 <b>$0…$9</b> 属性从结果“匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用“(”或者“)”。</p></td></tr><tr><td><p>(?:<i>pattern</i>)</p></td><td><p>匹配 <i>pattern</i> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</p></td></tr><tr><td><p>(?=<i>pattern</i>)</p></td><td><p>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <i>pattern</i> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p></td></tr><tr><td><p>(?!<i>pattern</i>)</p></td><td><p>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <i>pattern</i> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p></td></tr><tr><td><p><i>x</i>|<i>y</i></p></td><td><p>匹配 <i>x</i> 或 <i>y</i>。例如，’z|food’ 匹配“z”或“food”。’(z|f)ood’ 匹配“zood”或“food”。</p></td></tr><tr><td><p>[<i>xyz</i>]</p></td><td><p>字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。</p></td></tr><tr><td><p>[^<i>xyz</i>]</p></td><td><p>反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。</p></td></tr><tr><td><p>[<i>a-z</i>]</p></td><td><p>字符范围。匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。</p></td></tr><tr><td><p>[^<i>a-z</i>]</p></td><td><p>反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。</p></td></tr><tr><td><p>\b</p></td><td><p>匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。</p></td></tr><tr><td><p>\B</p></td><td><p>非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。</p></td></tr><tr><td><p>\c<i>x</i></p></td><td><p>匹配 <i>x</i> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<i>x</i> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。</p></td></tr><tr><td><p>\d</p></td><td><p>数字字符匹配。等效于 [0-9]。</p></td></tr><tr><td><p>\D</p></td><td><p>非数字字符匹配。等效于 [^0-9]。</p></td></tr><tr><td><p>\f</p></td><td><p>换页符匹配。等效于 \x0c 和 \cL。</p></td></tr><tr><td><p>\n</p></td><td><p>换行符匹配。等效于 \x0a 和 \cJ。</p></td></tr><tr><td><p>\r</p></td><td><p>匹配一个回车符。等效于 \x0d 和 \cM。</p></td></tr><tr><td><p>\s</p></td><td><p>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</p></td></tr><tr><td><p>\S</p></td><td><p>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</p></td></tr><tr><td><p>\t</p></td><td><p>制表符匹配。与 \x09 和 \cI 等效。</p></td></tr><tr><td><p>\v</p></td><td><p>垂直制表符匹配。与 \x0b 和 \cK 等效。</p></td></tr><tr><td><p>\w</p></td><td><p>匹配任何字类字符，包括下划线。与“[A-Za-z0-9<em>]”等效。</em></p></td></tr><tr><td><p>\W</p></td><td><p>与任何非单词字符匹配。与“[^A-Za-z0-9]”等效。</p></td></tr><tr><td><p>\x<i>n</i></p></td><td><p>匹配 <i>n</i>，此处的 <i>n</i> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。</p></td></tr><tr><td><p>\<i>num</i></p></td><td><p>匹配 <i>num</i>，此处的 <i>num</i> 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。</p></td></tr><tr><td><p>\<i>n</i></p></td><td><p>标识一个八进制转义码或反向引用。如果 \<i>n</i> 前面至少有 <i>n</i> 个捕获子表达式，那么 <i>n</i> 是反向引用。否则，如果 <i>n</i> 是八进制数 (0-7)，那么 <i>n</i> 是八进制转义码。</p></td></tr><tr><td><p>\<i>nm</i></p></td><td><p>标识一个八进制转义码或反向引用。如果 \<i>nm</i> 前面至少有 <i>nm</i> 个捕获子表达式，那么 <i>nm</i> 是反向引用。如果 \<i>nm</i> 前面至少有 <i>n</i> 个捕获，则 <i>n</i> 是反向引用，后面跟有字符 <i>m</i>。如果两种前面的情况都不存在，则 \<i>nm</i> 匹配八进制值 <i>nm</i>，其中 <i>n </i>和 <i>m</i> 是八进制数字 (0-7)。</p></td></tr><tr><td><p>\<span class="parameter" sdata="paramReference">nml</span></p></td><td><p>当 <i>n</i> 是八进制数 (0-3)，<i>m</i> 和 <i>l</i> 是八进制数 (0-7) 时，匹配八进制转义码 <i>nml</i>。</p></td></tr><tr><td><p>\u<i>n</i></p></td><td><p>匹配 <i>n</i>，其中 <i>n</i> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</p></td></tr></table></div>

<hr>
<h2 id="字符转义">字符转义</h2>
<p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\.</p>
<p>例如：<code>deerchao\.net</code>匹配<code>deerchao.net</code>，<code>C:\\Windows</code>匹配<code>C:\Windows</code>。</p>
<hr>
<h2 id="重复">重复</h2>
<p>正则表达式第一件能做的事是能够匹配不定长的字符集，而这是其它能作用在字符串上的方法所不能做到的。 不过，如果那是正则表达式唯一的附加功能的话，那么它们也就不那么优秀了。它们的另一个功能就是你可以指定正则表达式的一部分的重复次数。</p>
<p>就像前面介绍的元字符 <code>*</code>. <code>*</code> 并不匹配字母字符 “*”；相反，它指定前一个字符可以被匹配零次或更多次，而不是只有一次。</p>
<p>上面我们的元字符表把大部分元字符都说了，这里我们抽取出重复限定符。</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<p>再举个例子，ca?t 将匹配 “ct” (0 个 “a” 字符) 或 “cat” (1 个 “a”);<br>有了上面的这些限定元字符，可以很好得处理重复情况，只要运用得当。</p>
<hr>
<h2 id="字符类">字符类</h2>
<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>
<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p>
<p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。</p>
<p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。</p>
<p>“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。</p>
<p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>
<hr>
<h2 id="分支条件">分支条件</h2>
<p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p>
<p><code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>
<p><code>\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}</code>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>
<p><code>\d{5}-\d{4}|\d{5}</code>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成<code>\d{5}|\d{5}-\d{4}</code>的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<hr>
<h2 id="分组">分组</h2>
<p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>
<p>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p>
<p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>
<p>不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</p>
<p>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>
<hr>
<h2 id="re模块">re模块</h2>
<p>Python中得正则表达式（regular expression）模块，即re模块，功能还是很强大的。在介绍re之前，先看下面这部分。</p>
<p>正则表达式使用反斜杠” \ “来代表特殊形式或用作转义字符，这里跟Python的语法冲突，因此，Python用” \\ “表示正则表达式中的” \ “，因为正则表达式中如果要匹配” \ “，需要用\来转义，变成” \ “，而Python语法中又需要对字符串中每一个\进行转义，所以就变成了” \\ “。</p>
<p>上面的写法是不是觉得很麻烦，为了使正则表达式具有更好的可读性，Python特别设计了原始字符串(raw string)，需要提醒你的是，在写文件路径的时候就不要使用raw string了，这里存在陷阱。raw string就是用’r’作为字符串的前缀，如 r”\n”：表示两个字符”\”和”n”，而不是换行符了。Python中写正则表达式时推荐使用这种形式。</p>
<p>下面来看一下re模块的几个函数：</p>
<h4 id="compile">compile</h4>
<p><strong>re.compile(strPattern[, flag]):</strong></p>
<p>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。<br>第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。<br>另外，你也可以在regex字符串中指定模式，<br>比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。<br>可选值有：</p>
<pre><code>re.I(IGNORECASE): 忽略大小写（括号内是完整写法，下同）
re.M(MULTILINE): 多行模式，改变'^'和'<span class="formula">$'的行为（参见上图）
re.S(DOTALL): 点任意匹配模式，改变'.'的行为
re.L(LOCALE): 使预定字符类 <span class="command">\w</span> <span class="command">\W</span> <span class="command">\b</span> <span class="command">\B</span> <span class="command">\s</span> <span class="command">\S</span> 取决于当前区域设定
re.U(UNICODE): 使预定字符类 <span class="command">\w</span> <span class="command">\W</span> <span class="command">\b</span> <span class="command">\B</span> <span class="command">\s</span> <span class="command">\S</span> <span class="command">\d</span> <span class="command">\D</span> 取决于unicode定义的字符属性
re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</span>
</code></pre><p>其实compile方法的作用，不是很明显，因为下面的两个得到的结果等价。调用compile后，返回RegexObject对象，可以用该对象调用macth()和search()等匹配方法。</p>
<pre><code><span class="keyword">import</span> re

pattern = <span class="string">r"hi"</span>;
string = <span class="string">"hi,jack"</span>;

prog = re.compile(pattern);
result1 = prog.match(string);
<span class="keyword">print</span> <span class="string">"result1: "</span>, result1.group();

result2 = re.match(pattern, string);
<span class="keyword">print</span> <span class="string">"result2: "</span>,result2.group();
</code></pre><p>输出的结果是一样的。这里match下面会介绍，它是一个匹配的方法，group方法后面也会介绍，它这里输出的时匹配的内容。可以试验一下，就明白他两是等效的。</p>
<h4 id="match和search">match和search</h4>
<p>两个方法都是进行匹配时调用的。但他们有不同之处。</p>
<p>Python提供了两种不同的原始操作：match和search。match是从字符串的起点开始做匹配，而search（perl默认）是从字符串做任意匹配。</p>
<p><strong>例子1</strong>    </p>
<pre><code><span class="keyword">import</span> re

result1 = re.match(<span class="string">"c"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"nothing"</span>);

result2 = re.search(<span class="string">"c"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
</code></pre><p>输出：<br><br>nothing<br><br>result2:c</p>
<p><strong>例子2</strong></p>
<pre><code><span class="keyword">import</span> re

result1 = re.match(<span class="string">"a"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"nothing"</span>);

result2 = re.search(<span class="string">"a"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
</code></pre><p>输出：<br><br>result1:a<br><br>result2:a</p>
<p><strong>例子3</strong></p>
<p>match函数可以设置匹配开始的位置，下面分别从0，1，2位置开始匹配。当然也可以设置终止的位置，具体可以查API文档。</p>
<pre><code>import re

pattern = re.compile(<span class="string">"c"</span>);

result1 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">0</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result1: nothing"</span>);

result2 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">1</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result2: nothing"</span>);

result3 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">2</span>);
<span class="keyword">if</span>(result3):
    <span class="keyword">print</span>(<span class="string">"result3:"</span>+result3.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result3: nothing"</span>);
</code></pre><p>输出：<br><br>result1: nothing<br><br>result2: nothing<br><br>result3:c</p>
<h4 id="split">split</h4>
<p><strong>re.split(pattern, string, maxsplit=0)</strong></p>
<p>通过正则表达式将字符串分离。如果用括号将正则表达式括起来，那么匹配的字符串也会被列入到list中返回。maxsplit是分离的次数，maxsplit=1分离一次，默认为0，不限制次数。</p>
<p>看一下例子：</p>
<pre><code>import re    
<span class="keyword">print</span> re.<span class="built_in">split</span>(<span class="string">'\W+'</span>, <span class="string">'Words, words, words.'</span>)
</code></pre><p>输出:<br><br>[‘Words’, ‘words’, ‘words’, ‘’]</p>
<p>思考一下为什么输出会是这个? 查看一下<code>\W</code>的作用，注意W是大写的。</p>
<h4 id="findall">findall</h4>
<p><strong>re.findall(pattern, string, flags=0)</strong></p>
<p>找到 RE 匹配的所有子串，并把它们作为一个列表返回。这个匹配是从左到右有序地返回。如果无匹配，返回空列表。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.<span class="keyword">findall</span>(<span class="string">"\d"</span>,<span class="string">"1a2b3c4d"</span>);
</code></pre><p>输出：<br><br>[‘1’, ‘2’, ‘3’, ‘4’]</p>
<h4 id="finditer">finditer</h4>
<p><strong>re.finditer(pattern, string, flags=0)</strong></p>
<p>找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。这个匹配是从左到右有序地返回。如果无匹配，返回空列表。</p>
<pre><code><span class="keyword">import</span> re

it = re.finditer(<span class="string">r"\d+"</span>,<span class="string">"123abc456efg789hij"</span>)
<span class="keyword">for</span> match <span class="keyword">in</span> it:
    <span class="keyword">print</span> match.group()
</code></pre><p>输出：<br><br>123<br>456<br>789</p>
<h4 id="sub">sub</h4>
<p><strong>sub(pattern, repl, string, count=0, flags=0)</strong></p>
<p>其用途是用来替换匹配成功的字串，被替换成repl。值得一提的时，这里的repl不仅仅可以是字符串，也可以是方法。</p>
<p>首先看下字符串的时候，被匹配的字符串就会被替换成为repl。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.sub(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)
</code></pre><p>输出：<br><br>Baked Beans &amp; Spam</p>
<p><code>可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组</code>.</p>
<p>当repl是方法的时候。这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 </p>
<pre><code><span class="keyword">import</span> re

<span class="function"><span class="keyword">def</span> <span class="title">dashrepl</span><span class="params">(matchobj)</span>:</span>
    <span class="keyword">if</span> matchobj.group(<span class="number">0</span>) == <span class="string">'-'</span>: <span class="keyword">return</span> <span class="string">' '</span>
    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">'-'</span>

<span class="keyword">print</span>  re.sub(<span class="string">'-{1,2}'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)
<span class="keyword">print</span>  re.sub(<span class="string">'-{1,2}'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)
</code></pre><p>输出：<br><br>pro—gram files    </p>
<h4 id="subn">subn</h4>
<p>subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]):<br>多返回 (sub(repl, string[, count]), 替换次数)。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.subn(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)
</code></pre><hr>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a>  <strong>(推荐)</strong></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx" target="_blank" rel="external">正则表达式语法</a></li>
<li><a href="http://www.cnblogs.com/PythonHome/archive/2011/11/19/2255459.html" target="_blank" rel="external">Python-re模块</a></li>
<li><a href="http://dragon.cnblogs.com/archive/2006/05/08/394078.html" target="_blank" rel="external">深入浅出之正则表达式</a> <strong>(推荐)</strong></li>
<li><a href="http://www.crifan.com/files/doc/docbook/python_topic_re/release/html/python_topic_re.html" target="_blank" rel="external">正则表达式re模块详解</a> <strong>(推荐)</strong></li>
<li><a href="http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97" target="_blank" rel="external">Python正则表达式操作指南</a> <strong>(推荐)</strong></li>
<li><a href="http://blog.csdn.net/pleasecallmewhy/article/details/8929576" target="_blank" rel="external">python正则表达式教程</a></li>
</ol>
]]></content>
    
    
      <category term="python" scheme="http://zhonghuan.info/tags/python/"/>
    
      <category term="webspider" scheme="http://zhonghuan.info/tags/webspider/"/>
    
      <category term="re" scheme="http://zhonghuan.info/tags/re/"/>
    
      <category term="正则表达式" scheme="http://zhonghuan.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="python网络爬虫" scheme="http://zhonghuan.info/categories/webspider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python网络爬虫学习笔记]]></title>
    <link href="http://zhonghuan.info/2014/09/04/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhonghuan.info/2014/09/04/python网络爬虫学习笔记/</id>
    <published>2014-09-03T20:38:11.000Z</published>
    <updated>2014-09-04T05:09:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍：">介绍：</h2>
<p>网络爬虫的名字很有意思，英文名称web spider。真得很形象，蜘蛛结网为了获取食物，而我们的爬虫程序，也是为了获取网络上的资源。这篇blog是本人学习过程中的记录。学习过程中，使用的语言是python2.7；python2.7有两个模块，urllib和urllib2，这两个模块提供了很好的网络访问的功能。下面会更好的体会。值得一提的时，在python3中，将urllib和urllib2这两个模块合为一个urllib。感兴趣的可以看<a href="https://docs.python.org/3.4/howto/urllib2.html" target="_blank" rel="external">这里</a></p>
<p>urllib和urllib2是python中功能强大得网络工作库，它们让你的网络访问像文件访问一样（例如，文件访问我们要先open()一个文件，它的操作也是类似的，后面就会看到例子）。之所以能够这么方便，因为这些模块的内部很好的使用不同的网络协议来完成这些功能，（学过网络应该了解，访问一个网页这个简单的过程，其实涉及到很多的网络协议，像http，dns等等，而urllib和urllib2封装了这些协议，让我们不用和它们打交道，只需要调用这些模块的方法来完成我们需要的功能）。同时，这些模块也提供一些稍微更复杂一点的借口来处理一些情形，例如用户认证，cookies和代理等等。下面让我们开始来学习它们吧。</p>
<hr>
<h2 id="从简单语句中开始:">从简单语句中开始:</h2>
<p>前面说过，使用两个模块，访问网页变得就会像访问文件一样方便。在一般情况下，urllib2访问会更好些（效率上更好，不过urllib还是需要使用，后面会介绍需要urllib做一些事情），所以下面我们来看看使用urllib2的最简单的例子。</p>
<pre><code><span class="title">import</span> urllib2;

<span class="title">response</span> = urllib2.urlopen(<span class="string">"http://www.zhonghuan.info"</span>);
<span class="title">html</span> = response.read();
<span class="title">print</span> html;
</code></pre><p>在终端下下输入命令行  python test.py &gt; zhonghuan.html ,<br>打开文件后显示的是我的个人blog首页的html代码：</p>
<p><img style="width:100%" alt="" src="http://zhonghuan.qiniudn.com/python%2Fwebspider%2Fwebspider2.png"> </p>
<p>这是最简单的一个利用urllib2访问网页的例子，urllib2是根据URL中:前面的部分来判断是用什么协议访问的，例如，上面的例子我们用的时http，这里也可以换成ftp:,file:,等。。。我们可以不用去了解它内部是如何封装这些网络协议的。</p>
<p>urllib2中可以用一个镜像对象（Request Object）来表示我们http访问，它标示你想要访问的URL地址，我们来看一下下面的例子。</p>
<pre><code><span class="built_in">import</span> urllib2

<span class="variable">req =</span> urllib2.Request('http://www.zhonghuan.info')
<span class="variable">response =</span> urllib2.urlopen(req)
<span class="variable">the_page =</span> response.read()
print(the_page)
</code></pre><p>req变量就是一个Request对象。它确切的标示了你要访问的URL地址。（这里是<a href="http://www.zhonghuan.info）；对于其它的形式的访问，例如ftp和file，形式也是类似的，具体可以看[这里][2" target="_blank" rel="external">http://www.zhonghuan.info）；对于其它的形式的访问，例如ftp和file，形式也是类似的，具体可以看[这里][2</a>];</p>
<p>其实，Request对象还能做两个额外的事情。</p>
<ol>
<li>你可以发送数据给服务器。</li>
<li>你可以发送一些额外的信息（又叫元数据，描述数据的数据。一些语言里面的元类是生成类的类，如python就在这些语言中；所以元数据，顾名思义，描述数据的数据，那么这些被描述的数据是什么呢？上面中，还有request对象的一些信息，而这些描述被放在http头部发送出去了。有关http header，可以看<a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">这里</a>）;</li>
</ol>
<hr>
<h2 id="传送数据给服务器">传送数据给服务器</h2>
<p>有时候，你需要发送数据给服务器，这个地址是URL表示的，通常呢，这个地址的指向是CGI（Common Gateway Interface）脚本或者是其它一些网络应用。（关于CGI脚本,可以看<a href="http://www.jdon.com/idea/cgi.htm" target="_blank" rel="external">这里</a>，简单的说就是处理上传数据的脚本程序）。在HTTP访问中，通常使用哪个POST方式将数据发送出去，就好像你填完了html中得表单，你需要把表单中得数据发送出去，通常这里使用post请求。当然，post使用还有其它的情况，不单单指的是表单这一种情况。</p>
<p>让我们先看下面的代码：</p>
<pre><code>import urllib
import urllib2

url = <span class="string">'http://www.someserver.com/cgi-bin/register.cgi'</span>
<span class="keyword">values</span> = {<span class="string">'name'</span> : <span class="string">'Michael Foord'</span>,
      <span class="string">'location'</span> : <span class="string">'Northampton'</span>,
      <span class="string">'language'</span> : <span class="string">'Python'</span> }
data = urllib.urlencode(<span class="keyword">values</span>)  <span class="comment">#数据需要重新编码成合适的格式，这里使用的时urllib中得方法，因为urllib2中没有编码的方法</span>
req = urllib2.Request(url, data)  <span class="comment"># #这里将需要上传的数据，传递给了equest对象，作为它的参数</span>
response = urllib2.urlopen(req)
the_page = response.<span class="keyword">read</span>()
</code></pre><p>关于其它类型的数据上传，可以看<a href="http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13" target="_blank" rel="external">这里</a></p>
<p>除了使用post方式上传数据外，还可以使用get方式上传数据，get上传和post上传明显的区别就是get上传的数据会在URL中得尾部显示出来。可以看下面的代码：</p>
<hr>
<pre><code><span class="import"><span class="keyword">import</span> urllib</span>
<span class="import"><span class="keyword">import</span> urllib2</span>

<span class="typedef"><span class="keyword">data</span> = <span class="container">{}</span></span>
<span class="typedef"><span class="keyword">data</span>['name'] = '<span class="type">Somebody</span> <span class="type">Here'</span></span>
<span class="typedef"><span class="keyword">data</span>['location'] = '<span class="type">Northampton'</span></span>
<span class="typedef"><span class="keyword">data</span>['language'] = '<span class="type">Python'</span></span>

<span class="title">url_values</span> = urllib.urlencode(<span class="typedef"><span class="keyword">data</span>)</span>
<span class="title">print</span> url_values  # 这里的顺序不一定

<span class="title">url</span> = 'http://www.example.com/example.cgi'
<span class="title">full_url</span> = url + '?' + url_values
<span class="typedef"><span class="keyword">data</span> = urllib2.urlopen<span class="container">(<span class="title">full_url</span>)</span></span>
</code></pre><p>可以悄悄打印出来url_value的形式。</p>
<hr>
<h2 id="HTTP头—描述数据的数据">HTTP头—描述数据的数据</h2>
<p>现在，我们来讨论一下HTTP头，来看看如何在你的HTTP的Request对象，增加一个HTTP头。</p>
<p>有一些网站，它比较智能，它不喜欢被程序访问（非人为的点击只会加重它服务器的负担）。或者有些网站更加智能点，对于不同的浏览器，会发送不同的网页数据。</p>
<p>可是呢，urllib2默认,会这样标示自己，<code>Python-urllib/x.y</code>(其中，x和y分别是大小版本号，例如我现在使用的时<code>Python-urllib/2.7</code>);而这些数据可能会让一些站点觉得迷惑，要是遇上了不喜欢被程序访问的网站，那么这样的访问可能会直接被忽视。所以，你可以构造一些身份，让站点不会拒绝你。看下面的例子。</p>
<pre><code><span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib2

url <span class="subst">=</span> <span class="string">'http://www.someserver.com/cgi-bin/register.cgi'</span>
user_agent <span class="subst">=</span> <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span> <span class="variable">#user_agent</span>用来标示你的浏览器的，向这里就是mozilla
values <span class="subst">=</span> {<span class="string">'name'</span> : <span class="string">'Michael Foord'</span>,
      <span class="string">'location'</span> : <span class="string">'Northampton'</span>,
      <span class="string">'language'</span> : <span class="string">'Python'</span> }

headers <span class="subst">=</span> { <span class="string">'User-Agent'</span> : user_agent }
<span class="built_in">data</span> <span class="subst">=</span> urllib<span class="built_in">.</span>urlencode(values)

req <span class="subst">=</span> urllib2<span class="built_in">.</span>Request(url, <span class="built_in">data</span>, headers)

response <span class="subst">=</span> urllib2<span class="built_in">.</span>urlopen(req)

the_page <span class="subst">=</span> response<span class="built_in">.</span>read()    
</code></pre><hr>
<h2 id="异常">异常</h2>
<p>异常时常有，要小心提防呐！想想一般文件操作的时候，会有什么异常呢？文件无法打开，什么权限不够啊，文件不存在啊等等异常。同样的，对于URL访问，也会遇到这些问题，（python一些内部异常，例如ValueError，TypeError等异常，也可能会发生）</p>
<p><br></p>
<h4 id="URLError">URLError</h4>
<p>先说说URLError，当没有网络连接，或者访问的服务器地址不存在的时候，在这种情况下，URLError会被抛出来，这个时候，URLError异常会有个“reason”属性，它是一个元组，包含error code（int型）和text error message（string型），看下面的代码</p>
<pre><code><span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib2


req = urllib2.Request(<span class="string">'http://www.pretend_server.org'</span>)
<span class="keyword">try</span>: urllib2.urlopen(req)
<span class="keyword">except</span> urllib2.URLError <span class="keyword">as</span> e:
    <span class="keyword">print</span> e.reason
</code></pre><p>输出<code>[Errno 8] nodename nor servname provided, or not known</code>;输出的内容就是reason，</p>
<p><br></p>
<h4 id="HTTPError">HTTPError</h4>
<p>每一个HTTP访问，会从服务器那儿获得一个“status code”（状态码），通常这些状态码告诉我们服务器无法满足一些访问（直白点说就是一些数据而已，只不过表示的是当前访问的状态，比如当前访问被拒绝了，status code可以告诉你，你哪些举动过分了，出格了，注意，咸猪手不可以有啊~~）。</p>
<p>不过呢，urllib2的默认处理器能够帮助你处理一些服务器的响应，比如说你当前访问的网址被服务器重定向了，就是说你的服务器给你一个新的URL访问了，处理器会帮你直接去访问新的URL。</p>
<p>但是默认的处理器毕竟功能有限，它不能帮助你解决所有问题，比如你访问的网站不存在了（对应404错误，我们有时候会看到这个错误），或者你的访问被禁止了（对应403错误，禁止的原因可能是因为你的权限不够啦等等），又或者是需要你验证啦（对应401）。具体的其它错误本文就不介绍啦，具体可以看<a href="http://baike.baidu.com/view/1399931.htm" target="_blank" rel="external">这里</a></p>
<p>让我们看下面的程序，看一下当HTTPError的404错误，也就是页面不存在时候，它会输出点什么。</p>
<pre><code><span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib2


req = urllib2.Request(<span class="string">'http://www.zhonghuan.info/no_way'</span>)
<span class="keyword">try</span>: urllib2.urlopen(req)
<span class="keyword">except</span> urllib2.HTTPError <span class="keyword">as</span> e:
       <span class="keyword">print</span> e.code;
     <span class="keyword">print</span> e.read();         
</code></pre><p>输出：<br>404</p>
<p><code>&lt;!DOCTYPE html&gt;</code></p>
<p>…</p>
<p><code>&lt;title&gt;Page not found &amp;middot; GitHub Pages&lt;/title&gt;</code></p>
<p>…</p>
<p><br></p>
<h4 id="处理异常">处理异常</h4>
<p>假设你想要捕捉HTTPError和URLError，有两种基本的方法，推荐第二种噢！</p>
<p><strong>第一种：</strong></p>
<pre><code><span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request, urlopen, URLError, HTTPError


req = Request(http://zhonghuan.info)
<span class="keyword">try</span>:
    response = urlopen(req)
<span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:
    <span class="keyword">print</span> <span class="string">'The server couldn\'t fulfill the request.'</span>
    <span class="keyword">print</span> <span class="string">'Error code: '</span>, e.code
<span class="keyword">except</span> URLError <span class="keyword">as</span> e:
    <span class="keyword">print</span> <span class="string">'We failed to reach a server.'</span>
    <span class="keyword">print</span> <span class="string">'Reason: '</span>, e.reason
<span class="keyword">else</span>:
    <span class="comment"># everything is fine</span>
</code></pre><p>第一种方法，HTTPError一定要放在URLError前面，原因呢，和很多语言的异常处理机制一样，HTTPError是URLError的子类，如果发生了HTTPError，它可以被当做是URLError被捕捉。   </p>
<p><strong>第二种：</strong></p>
<pre><code><span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request, urlopen, URLError


req = Request(someurl)
<span class="keyword">try</span>:
       response = urlopen(req)
<span class="keyword">except</span> URLError <span class="keyword">as</span> e:
    <span class="keyword">if</span> hasattr(e, <span class="string">'reason'</span>):
        <span class="keyword">print</span> <span class="string">'We failed to reach a server.'</span>
        <span class="keyword">print</span> <span class="string">'Reason: '</span>, e.reason
    <span class="keyword">elif</span> hasattr(e, <span class="string">'code'</span>):
        <span class="keyword">print</span> <span class="string">'The server couldn\'t fulfill the request.'</span>
        <span class="keyword">print</span> <span class="string">'Error code: '</span>, e.code
<span class="keyword">else</span>:
    <span class="comment"># everything is fine        </span>
</code></pre><p><br></p>
<h4 id="info和geturl">info和geturl</h4>
<p>这里介绍两个方法info()和geturl()；</p>
<p>geturl():该方法会返回访问的页面的真实的URL，它的价值在于我们访问的网页可能会被重定向，所以导致访问的URL和我们输入的可能不一样。看下面的例子：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> urllib</span>
<span class="preprocessor"><span class="keyword">import</span> urllib2</span>

url = <span class="comment">'http://weibo.com/u/2103243911';</span>
req = urllib2.Request(url);
response = urllib2.urlopen(req)

<span class="built_in">print</span> <span class="string">"URL:"</span>,url;
<span class="built_in">print</span> <span class="string">"After redirection:"</span>,response.geturl();
</code></pre><p>以我的微博个人主页为例，其实真实访问被重定向了，真实的网址，从输出中可以看出:</p>
<p><code>URL: http://weibo.com/u/2103243911</code><br><br><code>After redirection: http://passport.weibo.com/visitor/visitor?a=enter&amp;url=http%3A%2F%2Fweibo.com%2Fu%2F2103243911&amp;_rand=1409761358.1794</code></p>
<p><br><br>info():可以得到描述页面的信息，返回的是一个<code>httplib.HTTPMessage</code>实例，打印出来很像字典。看下面的代码：</p>
<pre><code><span class="title">import</span> urllib
import urllib2


url = <span class="string">'http://zhonghuan.info'</span>;
<span class="title">req</span> = urllib2.Request(url);
<span class="title">response</span> = urllib2.urlopen(req);
<span class="title">print</span> response.<span class="built_in">info</span>();
<span class="title">print</span> response.<span class="built_in">info</span>().__class__;
</code></pre><p>输出：</p>
<pre><code><span class="attribute">Server</span>: <span class="string">GitHub.com</span>
<span class="attribute">Content-Type</span>: <span class="string">text/html; charset=utf-8</span>
<span class="attribute">Last-Modified</span>: <span class="string">Tue, 02 Sep 2014 17:01:39 GMT</span>
<span class="attribute">Expires</span>: <span class="string">Wed, 03 Sep 2014 15:23:02 GMT</span>
<span class="attribute">Cache-Control</span>: <span class="string">max-age=600</span>
<span class="attribute">Content-Length</span>: <span class="string">4784</span>
<span class="attribute">Accept-Ranges</span>: <span class="string">bytes</span>
<span class="attribute">Date</span>: <span class="string">Wed, 03 Sep 2014 16:38:29 GMT</span>
<span class="attribute">Via</span>: <span class="string">1.1 varnish</span>
<span class="attribute">Age</span>: <span class="string">5127</span>
<span class="attribute">Connection</span>: <span class="string">close</span>
<span class="attribute">X-Served-By</span>: <span class="string">cache-lax1433-LAX</span>
<span class="attribute">X-Cache</span>: <span class="string">HIT</span>
<span class="attribute">X-Cache-Hits</span>: <span class="string">1</span>
<span class="attribute">X-Timer</span>: <span class="string">S1409762309.465760,VS0,VE0</span>
<span class="attribute">Vary</span>: <span class="string">Accept-Encoding</span>

<span class="http"><span class="attribute">Class</span>: <span class="string">httplib.HTTPMessage</span></span>
</code></pre><hr>
<p><br></p>
<h2 id="Opener和Handler">Opener和Handler</h2>
<p>这里介绍Opener和Handler。</p>
<p>什么是Opener呢？其实上面的例子我们一直在用Opener了，就是urlopen。这个是默认的opener，网络访问情况很多，你可以创建比较合适的opener，</p>
<p>什么是Handler呢？其实Opener会调用Handler来处理访问中得琐事，所以Handler很重要，对于特定的协议（例如FTP，HTTP），它知道如何如何处理访问，例如它会帮你处理重定向问题。</p>
<p>在访问的时候，你可能对于Opener有一些要求，例如，你希望得到的Opener能够处理cookie，或者你不希望Opener帮助你处理重定向。</p>
<p>我们如何生成需要得Opener呢？（这里插一下，个人觉得这里的Opener生成方式，和设计模式中得生成器欧式，又叫建造者模式，英文名称Builder Pattern；有些相似，不过不完全一样，但总觉得，在看下去之前，先了解一下这个模式会有好处，没有接触过的朋友可以看这篇<a href="http://blog.csdn.net/zhonghuan1992/article/details/38418139" target="_blank" rel="external">Builder pattern</a>）;</p>
<p>要创建一个 opener，可以实例化一个OpenerDirector，<br>然后调用.add_handler(some_handler_instance)。</p>
<p>不过，可以使用build_opener，这是一个更加方便的函数，用来创建opener对象，他只需要一次函数调用。build_opener默认添加几个处理器，但提供快捷的方法来添加或更新默认处理器。<br>其他的处理器handlers你或许会希望处理代理，验证，和其他常用但有点特殊的情况。</p>
<p>刚刚提到handler会帮我们处理重定向，但是，如果我们不想要重定向呢，该怎么办，自定义一个handler。看下面的代码：</p>
<pre><code>mport urllib
<span class="keyword">import</span> urllib2


<span class="class"><span class="keyword">class</span> <span class="title">RedirectHandler</span><span class="params">(urllib2.HTTPRedirectHandler)</span>:</span><span class="comment"># 这个RedirectHandler继承了HTTPRedirectHandler，不过，它覆盖了父类的方法，让它什么都不做，失去了重定向的功能。</span>
    <span class="function"><span class="keyword">def</span> <span class="title">http_error_301</span><span class="params">(self, req, fp, code, msg, headers)</span>:</span>
        <span class="keyword">pass</span>
    <span class="function"><span class="keyword">def</span> <span class="title">http_error_302</span><span class="params">(self, req, fp, code, msg, headers)</span>:</span>
        <span class="keyword">pass</span>


webo = <span class="string">"http://weibo.com/u/2103243911"</span>; <span class="comment">#访问的是我的微博页面，因为正常情况下，访问时会发生重定向</span>
opener = urllib2.build_opener(RedirectHandler) <span class="comment">#这里，我们自定义了一个opener，添加了一个重定向时处理的自定义handler</span>
response = opener.open(webo);<span class="comment"># response  = urllib2.urlopen(webo);</span>
<span class="keyword">print</span> response.geturl();
urllib2.install_opener(opener);  <span class="comment">#安装自定义的opener，以后调用urllib2的时候，返回的就是这个opener。</span>
</code></pre><p>输出结果是：<br><code>urllib2.HTTPError: HTTP Error 302: Moved Temporarily</code></p>
<p>之所以发生http error 302，是因为本来访问我的微博个人主页的时候，它应该发生重定向的，可是我们自己的重定向Handler什么都不做，结果就是发生异常了。</p>
<p>可以看看下面的urllib2关于创建自定义Opener的类图</p>
<p><br><br><img src="http://zhonghuan.qiniudn.com/python%2Fwebspider%2Fwebspider3.gif" alt=""></p>
<hr>
<p><br></p>
<h2 id="Basic_Authentication">Basic Authentication</h2>
<p>如果一个网站，他提供注册登入这些功能，那么一般它有用户名/密码,如果你访问的页面，系统要求你提供用户名/密码，这个过程叫做Authentication，实在服务器那端所做的操作。它给一些页面提供了安全保护。</p>
<p>一个基本的Authentication（验证）过程是这样的：</p>
<ol>
<li>客户端提出请求访问某些页面。</li>
<li>服务器返回一个错误，要求进行身份验证。</li>
<li>客户端把用户名/密码（一般这样）编码后发给服务器。</li>
<li>服务器检查这对用户名/密码是否正确，然后返回用户请求的页面或者是一些错误。</li>
</ol>
<p>上面的过程，还有可能是其它形式，这里只是举个比较普遍的。</p>
<p>通常服务器返回的是401错误，表明访问的网页未授权，同时，返回的response的header内有形如</p>
<p><code>WWW-Authenticate: SCHEME realm=&quot;REALM&quot;.</code></p>
<p>的内容，例如，你想要访问cPanel的管理应用程序，你会收到这样的header：<code>WWW-Authenticate: Basic realm=&quot;cPanel&quot;</code>（cPanel 是一套在网页寄存业中最享负盛名的商业软件，其基于 Linux 和 BSD 系统及以 PHP 开发且性质为闭源软件；cPanel 主要是面向客户权级的控制系统）</p>
<p>当我们访问页面的时候，opener会调用handler来处理各种情况，而处理Authentication的handler是urllib2.HTTPBasicAuthHandler，同时需要一个用户密码管理器urllib2.HTTPPasswordMgr。</p>
<p>不幸的时，HTTPPasswordMgr有一个小问题，就是在获取网页前，你需要知道它的realm。幸运的是，它有一个表兄弟HTTPPasswordMgrWithDefaultRealm，这个表兄弟可以事先不知道realm，在realm参数位置上，可以传一个None进去，它更友好的被使用。</p>
<p>下面参考下面的代码：</p>
<pre><code><span class="built_in">import</span> urllib2


<span class="variable">url =</span> 'http://www.weibo.com'<span class="comment">#分别对应域名，账号，密码</span>
<span class="variable">username =</span> 'zhonghuan'
<span class="variable">password =</span> 'forget_it'
<span class="variable">passman =</span> urllib2.HTTPPasswordMgrWithDefaultRealm() <span class="comment">#创建密码管理器</span>
passman.add_password(None, url, username, password)<span class="comment"># 参数形式（realm，URL，UserName，Password）</span>
<span class="variable">authhandler =</span> urllib2.HTTPBasicAuthHandler(passman)<span class="comment">#创建Authentication的handler</span>
<span class="variable">opener =</span> urllib2.build_opener(authhandler)
urllib2.install_opener(opener) <span class="comment">#和上面介绍的一样，install_opener后，每次调用urllib2的urlopen，返回的就是这个opener</span>
<span class="variable">pagehandle =</span> urllib2.urlopen(url)
</code></pre><hr>
<p><br></p>
<h2 id="代理">代理</h2>
<p>有时候，我们本机不能直接访问，需要代理服务器去访问。urllib2对这个设置代理支持的还不错，可以直接实例化ProxyHandler，它的参数是一个map，key值是代理的访问协议名称，value值是代理的地址。看下面的代码实现。</p>
<pre><code><span class="built_in">import</span> urllib2


<span class="variable">enable_proxy =</span> True
<span class="variable">proxy_handler =</span> urllib2.ProxyHandler({<span class="string">"http"</span> : 'http://some-proxy.com:<span class="number">8080</span>'})
<span class="variable">null_proxy_handler =</span> urllib2.ProxyHandler({})
<span class="keyword">if</span> enable_proxy:
    <span class="variable">opener =</span> urllib2.build_opener(proxy_handler)
<span class="keyword">else</span>:
    <span class="variable">opener =</span> urllib2.build_opener(null_proxy_handler)
urllib2.install_opener(opener)
</code></pre><hr>
<p><br></p>
<h2 id="Timeout_设置">Timeout 设置</h2>
<p>在老版 Python 中，urllib2 的 API 并没有暴露 Timeout 的设置，要设置 Timeout 值，只能更改 Socket 的全局 Timeout 值。</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> urllib2</span>
<span class="preprocessor"><span class="keyword">import</span> socket</span>


socket.setdefaulttimeout(<span class="number">10</span>)<span class="preprocessor"> # 10 秒钟后超时</span>
urllib2.socket.setdefaulttimeout(<span class="number">10</span>)<span class="preprocessor"> # 另一种方式</span>
</code></pre><p>在 Python 2.6 以后，超时可以通过 urllib2.urlopen() 的 timeout 参数直接设置。</p>
<pre><code><span class="built_in">import</span> urllib2

<span class="variable">response =</span> urllib2.urlopen('http://www.google.com', <span class="variable">timeout=</span><span class="number">10</span>)
</code></pre><hr>
<p><br></p>
<h2 id="Cookie">Cookie</h2>
<p>urllib2 对 Cookie 的处理也是自动的。如果需要得到某个 Cookie 项的值，可以这么做：</p>
<pre><code>import urllib2
import cookielib


cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))
response = opener.<span class="built_in">open</span>(<span class="string">'http://www.google.com'</span>)
<span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> cookie:
    <span class="keyword">if</span> <span class="keyword">item</span>.name == <span class="string">'some_cookie_item_name'</span>:
        print <span class="keyword">item</span>.<span class="built_in">value</span>
</code></pre><hr>
<p><br></p>
<h2 id="Debug_Log">Debug Log</h2>
<p>使用 urllib2 时，可以通过下面的方法把 debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试，有时可以省去抓包的工作</p>
<pre><code><span class="built_in">import</span> urllib2


<span class="variable">httpHandler =</span> urllib2.HTTPHandler(<span class="variable">debuglevel=</span><span class="number">1</span>)
<span class="variable">httpsHandler =</span> urllib2.HTTPSHandler(<span class="variable">debuglevel=</span><span class="number">1</span>)
<span class="variable">opener =</span> urllib2.build_opener(httpHandler, httpsHandler)
urllib2.install_opener(opener)
<span class="variable">response =</span> urllib2.urlopen('http://www.google.com')
</code></pre><hr>
<h2 id="参考资料：">参考资料：</h2>
<ol>
<li><p><a href="https://docs.python.org/2.7/howto/urllib2.html" target="_blank" rel="external">python urllib2的使用</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/column/details/why-bug.html" target="_blank" rel="external">python网络爬虫入门教程</a> <strong>(推荐)</strong> </p>
</li>
<li><p><a href="http://www.jdon.com/idea/cgi.htm" target="_blank" rel="external">CGI脚本入门</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://daoluan.net/blog/urllib2-source-decode/" target="_blank" rel="external">urllib2 源码小剖</a> </p>
</li>
<li><p><a href="http://zhuoqiang.me/python-urllib2-usage.html" target="_blank" rel="external">Python 标准库 urllib2 的使用细节</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://www.voidspace.org.uk/python/articles/authentication.shtml" target="_blank" rel="external">Authentication with Python</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">http://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a></p>
</li>
</ol>
<hr>
]]></content>
    
    
      <category term="python" scheme="http://zhonghuan.info/tags/python/"/>
    
      <category term="webspider" scheme="http://zhonghuan.info/tags/webspider/"/>
    
      <category term="urllib" scheme="http://zhonghuan.info/tags/urllib/"/>
    
      <category term="urllib2" scheme="http://zhonghuan.info/tags/urllib2/"/>
    
      <category term="python网络爬虫" scheme="http://zhonghuan.info/categories/webspider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://zhonghuan.info/2014/09/01/hello-world/"/>
    <id>http://zhonghuan.info/2014/09/01/hello-world/</id>
    <published>2014-09-01T08:28:04.000Z</published>
    <updated>2014-09-01T08:28:04.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    
  </entry>
  
</feed>
