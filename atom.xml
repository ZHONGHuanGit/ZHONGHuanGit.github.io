<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[de部落格^_^]]></title>
  <subtitle><![CDATA[Keep Blogging，keep trying，never give up~]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhonghuan.info/"/>
  <updated>2014-09-05T05:07:33.799Z</updated>
  <id>http://zhonghuan.info/</id>
  
  <author>
    <name><![CDATA[钟桓]]></name>
    <email><![CDATA[zhonghuanblog@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[正则表达式和python的re模块]]></title>
    <link href="http://zhonghuan.info/2014/09/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cpython%E7%9A%84re%E6%A8%A1%E5%9D%97/"/>
    <id>http://zhonghuan.info/2014/09/04/正则表达式和python的re模块/</id>
    <published>2014-09-04T15:04:30.000Z</published>
    <updated>2014-09-04T15:26:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是正则表达式">什么是正则表达式</h2>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。正则表达式就是记录文本规则的代码，换句话说，正则表达式是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”）。模式描述在搜索文本时要匹配的一个或多个字符串。</p>
<pre><code>字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。
</code></pre><p>假设你要在英文小说中查找Hi，那么使用的正则表达式就是<code>Hi</code>，这个很简单吧，不过，通常处理正则表达式的工具（例如后面会提到的python的re模块）会提供忽略大小写的选项。</p>
<p>不幸的是，很多单词里都包含了很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\bhi\b</code>。</p>
<pre><code><span class="command">\b</span>是正则表达式规定的一个特殊代码（这里称为元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。
</code></pre><p>假设你要找的Hi后面不远处有一个ZH，那么可以用<code>\bhi\b.*\bZH\b</code>.</p>
<pre><code>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<span class="keyword">*</span>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定<span class="keyword">*</span>前边的内容可以连续重复使用任意次以使整个表达式得到匹配,例如，zo<span class="keyword">*</span> 能匹配 <span class="string">"z"</span> 以及 <span class="string">"zoo"</span>等 。
</code></pre><p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：<br><code>0\d\d-\d\d\d\d\d\d\d\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p>
<p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。</p>
<p>下面来看看更多的例子：<br><code>\ba\w*\b</code>匹配以字母a开头的单词——先是某个单词开始处(<code>\b</code>)，然后是字母a,然后是任意数量的字母或数字(<code>\w*</code>)，最后是单词结束处(<code>\b</code>)。<br>好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的<code>\w</code>。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)<br><code>\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<code>*</code>类似的元字符，不同的是*匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。<br><code>\b\w{6}\b</code> 匹配刚好6个字符的单词。</p>
<hr>
<h2 id="元字符使用一览表：">元字符使用一览表：</h2>
<p>上面介绍了部分的metacharacter，下面给出元字符一览表，使用时可以查找。</p>
<div class="caption"></div><div class="tableSection"><table width="50%" frame="lhs"><tr><th><p>字符</p></th><th><p>说明</p></th></tr><tr><td><p>\</p></td><td><p>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\”匹配“\”，“(”匹配“(”。</p></td></tr><tr><td><p>^</p></td><td><p>匹配输入字符串开始的位置。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b> 属性，^ 还会与“\n”或“\r”之后的位置匹配。</p></td></tr><tr><td><p>$</p></td><td><p>匹配输入字符串结尾的位置。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b> 属性，$ 还会与“\n”或“\r”之前的位置匹配。</p></td></tr><tr><td><p><em> </em></p></td><td><p>零次或多次匹配前面的字符或子表达式。例如，zo 匹配“z”和“zoo”。<em> 等效于 {0,}。</em></p></td></tr><tr><td><p>+</p></td><td><p>一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。</p></td></tr><tr><td><p>?</p></td><td><p>零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。</p></td></tr><tr><td><p>{<i>n</i>}</p></td><td><p><i>n </i>是非负整数。正好匹配 <i>n</i> 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。</p></td></tr><tr><td><p>{<i>n</i>,}</p></td><td><p><i>n </i>是非负整数。至少匹配 <i>n </i>次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o ”。</p></td></tr><tr><td><p>{<i>n</i>,<i>m</i>}</p></td><td><p><i>M</i> 和 <i>n</i> 是非负整数，其中 <i>n</i> &lt;= <i>m</i>。匹配至少 <i>n</i> 次，至多 <i>m</i> 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</p></td></tr><tr><td><p>?</p></td><td><p>当此字符紧随任何其他限定符（*、+、?、{<i>n</i>}、{<i>n</i>,}、{<i>n</i>,<i>m</i>}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。</p></td></tr><tr><td><p>.</p></td><td><p>匹配除“\n”之外的任何单个字符。若要匹配包括“\n”在内的任意字符，请使用诸如“[\s\S]”之类的模式。</p></td></tr><tr><td><p>(<i>pattern</i>)</p></td><td><p>匹配 <i>pattern</i> 并捕获该匹配的子表达式。可以使用 <b>$0…$9</b> 属性从结果“匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用“(”或者“)”。</p></td></tr><tr><td><p>(?:<i>pattern</i>)</p></td><td><p>匹配 <i>pattern</i> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</p></td></tr><tr><td><p>(?=<i>pattern</i>)</p></td><td><p>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <i>pattern</i> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p></td></tr><tr><td><p>(?!<i>pattern</i>)</p></td><td><p>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <i>pattern</i> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p></td></tr><tr><td><p><i>x</i>|<i>y</i></p></td><td><p>匹配 <i>x</i> 或 <i>y</i>。例如，’z|food’ 匹配“z”或“food”。’(z|f)ood’ 匹配“zood”或“food”。</p></td></tr><tr><td><p>[<i>xyz</i>]</p></td><td><p>字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。</p></td></tr><tr><td><p>[^<i>xyz</i>]</p></td><td><p>反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。</p></td></tr><tr><td><p>[<i>a-z</i>]</p></td><td><p>字符范围。匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。</p></td></tr><tr><td><p>[^<i>a-z</i>]</p></td><td><p>反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。</p></td></tr><tr><td><p>\b</p></td><td><p>匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。</p></td></tr><tr><td><p>\B</p></td><td><p>非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。</p></td></tr><tr><td><p>\c<i>x</i></p></td><td><p>匹配 <i>x</i> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<i>x</i> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。</p></td></tr><tr><td><p>\d</p></td><td><p>数字字符匹配。等效于 [0-9]。</p></td></tr><tr><td><p>\D</p></td><td><p>非数字字符匹配。等效于 [^0-9]。</p></td></tr><tr><td><p>\f</p></td><td><p>换页符匹配。等效于 \x0c 和 \cL。</p></td></tr><tr><td><p>\n</p></td><td><p>换行符匹配。等效于 \x0a 和 \cJ。</p></td></tr><tr><td><p>\r</p></td><td><p>匹配一个回车符。等效于 \x0d 和 \cM。</p></td></tr><tr><td><p>\s</p></td><td><p>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</p></td></tr><tr><td><p>\S</p></td><td><p>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</p></td></tr><tr><td><p>\t</p></td><td><p>制表符匹配。与 \x09 和 \cI 等效。</p></td></tr><tr><td><p>\v</p></td><td><p>垂直制表符匹配。与 \x0b 和 \cK 等效。</p></td></tr><tr><td><p>\w</p></td><td><p>匹配任何字类字符，包括下划线。与“[A-Za-z0-9<em>]”等效。</em></p></td></tr><tr><td><p>\W</p></td><td><p>与任何非单词字符匹配。与“[^A-Za-z0-9]”等效。</p></td></tr><tr><td><p>\x<i>n</i></p></td><td><p>匹配 <i>n</i>，此处的 <i>n</i> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。</p></td></tr><tr><td><p>\<i>num</i></p></td><td><p>匹配 <i>num</i>，此处的 <i>num</i> 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。</p></td></tr><tr><td><p>\<i>n</i></p></td><td><p>标识一个八进制转义码或反向引用。如果 \<i>n</i> 前面至少有 <i>n</i> 个捕获子表达式，那么 <i>n</i> 是反向引用。否则，如果 <i>n</i> 是八进制数 (0-7)，那么 <i>n</i> 是八进制转义码。</p></td></tr><tr><td><p>\<i>nm</i></p></td><td><p>标识一个八进制转义码或反向引用。如果 \<i>nm</i> 前面至少有 <i>nm</i> 个捕获子表达式，那么 <i>nm</i> 是反向引用。如果 \<i>nm</i> 前面至少有 <i>n</i> 个捕获，则 <i>n</i> 是反向引用，后面跟有字符 <i>m</i>。如果两种前面的情况都不存在，则 \<i>nm</i> 匹配八进制值 <i>nm</i>，其中 <i>n </i>和 <i>m</i> 是八进制数字 (0-7)。</p></td></tr><tr><td><p>\<span class="parameter" sdata="paramReference">nml</span></p></td><td><p>当 <i>n</i> 是八进制数 (0-3)，<i>m</i> 和 <i>l</i> 是八进制数 (0-7) 时，匹配八进制转义码 <i>nml</i>。</p></td></tr><tr><td><p>\u<i>n</i></p></td><td><p>匹配 <i>n</i>，其中 <i>n</i> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</p></td></tr></table></div>

<hr>
<h2 id="字符转义">字符转义</h2>
<p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\.</p>
<p>例如：<code>deerchao\.net</code>匹配<code>deerchao.net</code>，<code>C:\\Windows</code>匹配<code>C:\Windows</code>。</p>
<hr>
<h2 id="重复">重复</h2>
<p>正则表达式第一件能做的事是能够匹配不定长的字符集，而这是其它能作用在字符串上的方法所不能做到的。 不过，如果那是正则表达式唯一的附加功能的话，那么它们也就不那么优秀了。它们的另一个功能就是你可以指定正则表达式的一部分的重复次数。</p>
<p>就像前面介绍的元字符 <code>*</code>. <code>*</code> 并不匹配字母字符 “*”；相反，它指定前一个字符可以被匹配零次或更多次，而不是只有一次。</p>
<p>上面我们的元字符表把大部分元字符都说了，这里我们抽取出重复限定符。</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<p>再举个例子，ca?t 将匹配 “ct” (0 个 “a” 字符) 或 “cat” (1 个 “a”);<br>有了上面的这些限定元字符，可以很好得处理重复情况，只要运用得当。</p>
<hr>
<h2 id="字符类">字符类</h2>
<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>
<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p>
<p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。</p>
<p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。</p>
<p>“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。</p>
<p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>
<hr>
<h2 id="分支条件">分支条件</h2>
<p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p>
<p><code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>
<p><code>\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}</code>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>
<p><code>\d{5}-\d{4}|\d{5}</code>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成<code>\d{5}|\d{5}-\d{4}</code>的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<hr>
<h2 id="分组">分组</h2>
<p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>
<p>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p>
<p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>
<p>不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</p>
<p>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>
<hr>
<h2 id="re模块">re模块</h2>
<p>Python中得正则表达式（regular expression）模块，即re模块，功能还是很强大的。在介绍re之前，先看下面这部分。</p>
<p>正则表达式使用反斜杠” \ “来代表特殊形式或用作转义字符，这里跟Python的语法冲突，因此，Python用” \\ “表示正则表达式中的” \ “，因为正则表达式中如果要匹配” \ “，需要用\来转义，变成” \ “，而Python语法中又需要对字符串中每一个\进行转义，所以就变成了” \\ “。</p>
<p>上面的写法是不是觉得很麻烦，为了使正则表达式具有更好的可读性，Python特别设计了原始字符串(raw string)，需要提醒你的是，在写文件路径的时候就不要使用raw string了，这里存在陷阱。raw string就是用’r’作为字符串的前缀，如 r”\n”：表示两个字符”\”和”n”，而不是换行符了。Python中写正则表达式时推荐使用这种形式。</p>
<p>下面来看一下re模块的几个函数：</p>
<h4 id="compile">compile</h4>
<p><strong>re.compile(strPattern[, flag]):</strong></p>
<p>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。<br>第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。<br>另外，你也可以在regex字符串中指定模式，<br>比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。<br>可选值有：</p>
<pre><code>re.I(IGNORECASE): 忽略大小写（括号内是完整写法，下同）
re.M(MULTILINE): 多行模式，改变'^'和'<span class="formula">$'的行为（参见上图）
re.S(DOTALL): 点任意匹配模式，改变'.'的行为
re.L(LOCALE): 使预定字符类 <span class="command">\w</span> <span class="command">\W</span> <span class="command">\b</span> <span class="command">\B</span> <span class="command">\s</span> <span class="command">\S</span> 取决于当前区域设定
re.U(UNICODE): 使预定字符类 <span class="command">\w</span> <span class="command">\W</span> <span class="command">\b</span> <span class="command">\B</span> <span class="command">\s</span> <span class="command">\S</span> <span class="command">\d</span> <span class="command">\D</span> 取决于unicode定义的字符属性
re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</span>
</code></pre><p>其实compile方法的作用，不是很明显，因为下面的两个得到的结果等价。调用compile后，返回RegexObject对象，可以用该对象调用macth()和search()等匹配方法。</p>
<pre><code><span class="keyword">import</span> re

pattern = <span class="string">r"hi"</span>;
string = <span class="string">"hi,jack"</span>;

prog = re.compile(pattern);
result1 = prog.match(string);
<span class="keyword">print</span> <span class="string">"result1: "</span>, result1.group();

result2 = re.match(pattern, string);
<span class="keyword">print</span> <span class="string">"result2: "</span>,result2.group();
</code></pre><p>输出的结果是一样的。这里match下面会介绍，它是一个匹配的方法，group方法后面也会介绍，它这里输出的时匹配的内容。可以试验一下，就明白他两是等效的。</p>
<h4 id="match和search">match和search</h4>
<p>两个方法都是进行匹配时调用的。但他们有不同之处。</p>
<p>Python提供了两种不同的原始操作：match和search。match是从字符串的起点开始做匹配，而search（perl默认）是从字符串做任意匹配。</p>
<p><strong>例子1</strong>    </p>
<pre><code><span class="keyword">import</span> re

result1 = re.match(<span class="string">"c"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"nothing"</span>);

result2 = re.search(<span class="string">"c"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
</code></pre><p>输出：<br><br>nothing<br><br>result2:c</p>
<p><strong>例子2</strong></p>
<pre><code><span class="keyword">import</span> re

result1 = re.match(<span class="string">"a"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"nothing"</span>);

result2 = re.search(<span class="string">"a"</span>,<span class="string">"abcde"</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
</code></pre><p>输出：<br><br>result1:a<br><br>result2:a</p>
<p><strong>例子3</strong></p>
<p>match函数可以设置匹配开始的位置，下面分别从0，1，2位置开始匹配。当然也可以设置终止的位置，具体可以查API文档。</p>
<pre><code>import re

pattern = re.compile(<span class="string">"c"</span>);

result1 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">0</span>);
<span class="keyword">if</span>(result1):
    <span class="keyword">print</span>(<span class="string">"result1:"</span>+result1.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result1: nothing"</span>);

result2 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">1</span>);
<span class="keyword">if</span>(result2):
    <span class="keyword">print</span>(<span class="string">"result2:"</span>+result2.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result2: nothing"</span>);

result3 = pattern.<span class="keyword">match</span>(<span class="string">"abcde"</span>,<span class="number">2</span>);
<span class="keyword">if</span>(result3):
    <span class="keyword">print</span>(<span class="string">"result3:"</span>+result3.<span class="keyword">group</span>());
<span class="keyword">else</span>:
    <span class="keyword">print</span>(<span class="string">"result3: nothing"</span>);
</code></pre><p>输出：<br><br>result1: nothing<br><br>result2: nothing<br><br>result3:c</p>
<h4 id="split">split</h4>
<p><strong>re.split(pattern, string, maxsplit=0)</strong></p>
<p>通过正则表达式将字符串分离。如果用括号将正则表达式括起来，那么匹配的字符串也会被列入到list中返回。maxsplit是分离的次数，maxsplit=1分离一次，默认为0，不限制次数。</p>
<p>看一下例子：</p>
<pre><code>import re    
<span class="keyword">print</span> re.<span class="built_in">split</span>(<span class="string">'\W+'</span>, <span class="string">'Words, words, words.'</span>)
</code></pre><p>输出:<br><br>[‘Words’, ‘words’, ‘words’, ‘’]</p>
<p>思考一下为什么输出会是这个? 查看一下<code>\W</code>的作用，注意W是大写的。</p>
<h4 id="findall">findall</h4>
<p><strong>re.findall(pattern, string, flags=0)</strong></p>
<p>找到 RE 匹配的所有子串，并把它们作为一个列表返回。这个匹配是从左到右有序地返回。如果无匹配，返回空列表。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.<span class="keyword">findall</span>(<span class="string">"\d"</span>,<span class="string">"1a2b3c4d"</span>);
</code></pre><p>输出：<br><br>[‘1’, ‘2’, ‘3’, ‘4’]</p>
<h4 id="finditer">finditer</h4>
<p><strong>re.finditer(pattern, string, flags=0)</strong></p>
<p>找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。这个匹配是从左到右有序地返回。如果无匹配，返回空列表。</p>
<pre><code><span class="keyword">import</span> re

it = re.finditer(<span class="string">r"\d+"</span>,<span class="string">"123abc456efg789hij"</span>)
<span class="keyword">for</span> match <span class="keyword">in</span> it:
    <span class="keyword">print</span> match.group()
</code></pre><p>输出：<br><br>123<br>456<br>789</p>
<h4 id="sub">sub</h4>
<p><strong>sub(pattern, repl, string, count=0, flags=0)</strong></p>
<p>其用途是用来替换匹配成功的字串，被替换成repl。值得一提的时，这里的repl不仅仅可以是字符串，也可以是方法。</p>
<p>首先看下字符串的时候，被匹配的字符串就会被替换成为repl。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.sub(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)
</code></pre><p>输出：<br><br>Baked Beans &amp; Spam</p>
<p><code>可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组</code>.</p>
<p>当repl是方法的时候。这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 </p>
<pre><code><span class="keyword">import</span> re

<span class="function"><span class="keyword">def</span> <span class="title">dashrepl</span><span class="params">(matchobj)</span>:</span>
    <span class="keyword">if</span> matchobj.group(<span class="number">0</span>) == <span class="string">'-'</span>: <span class="keyword">return</span> <span class="string">' '</span>
    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">'-'</span>

<span class="keyword">print</span>  re.sub(<span class="string">'-{1,2}'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)
<span class="keyword">print</span>  re.sub(<span class="string">'-{1,2}'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)
</code></pre><p>输出：<br><br>pro—gram files    </p>
<h4 id="subn">subn</h4>
<p>subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]):<br>多返回 (sub(repl, string[, count]), 替换次数)。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">print</span> re.subn(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)
</code></pre><hr>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a>  <strong>(推荐)</strong></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx" target="_blank" rel="external">正则表达式语法</a></li>
<li><a href="http://www.cnblogs.com/PythonHome/archive/2011/11/19/2255459.html" target="_blank" rel="external">Python-re模块</a></li>
<li><a href="http://dragon.cnblogs.com/archive/2006/05/08/394078.html" target="_blank" rel="external">深入浅出之正则表达式</a> <strong>(推荐)</strong></li>
<li><a href="http://www.crifan.com/files/doc/docbook/python_topic_re/release/html/python_topic_re.html" target="_blank" rel="external">正则表达式re模块详解</a> <strong>(推荐)</strong></li>
<li><a href="http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97" target="_blank" rel="external">Python正则表达式操作指南</a> <strong>(推荐)</strong></li>
<li><a href="http://blog.csdn.net/pleasecallmewhy/article/details/8929576" target="_blank" rel="external">python正则表达式教程</a></li>
</ol>
]]></content>
    
    
      <category term="python" scheme="http://zhonghuan.info/tags/python/"/>
    
      <category term="webspider" scheme="http://zhonghuan.info/tags/webspider/"/>
    
      <category term="re" scheme="http://zhonghuan.info/tags/re/"/>
    
      <category term="正则表达式" scheme="http://zhonghuan.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="python网络爬虫" scheme="http://zhonghuan.info/categories/webspider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python网络爬虫学习笔记]]></title>
    <link href="http://zhonghuan.info/2014/09/04/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhonghuan.info/2014/09/04/python网络爬虫学习笔记/</id>
    <published>2014-09-03T20:38:11.000Z</published>
    <updated>2014-09-04T05:09:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍：">介绍：</h2>
<p>网络爬虫的名字很有意思，英文名称web spider。真得很形象，蜘蛛结网为了获取食物，而我们的爬虫程序，也是为了获取网络上的资源。这篇blog是本人学习过程中的记录。学习过程中，使用的语言是python2.7；python2.7有两个模块，urllib和urllib2，这两个模块提供了很好的网络访问的功能。下面会更好的体会。值得一提的时，在python3中，将urllib和urllib2这两个模块合为一个urllib。感兴趣的可以看<a href="https://docs.python.org/3.4/howto/urllib2.html" target="_blank" rel="external">这里</a></p>
<p>urllib和urllib2是python中功能强大得网络工作库，它们让你的网络访问像文件访问一样（例如，文件访问我们要先open()一个文件，它的操作也是类似的，后面就会看到例子）。之所以能够这么方便，因为这些模块的内部很好的使用不同的网络协议来完成这些功能，（学过网络应该了解，访问一个网页这个简单的过程，其实涉及到很多的网络协议，像http，dns等等，而urllib和urllib2封装了这些协议，让我们不用和它们打交道，只需要调用这些模块的方法来完成我们需要的功能）。同时，这些模块也提供一些稍微更复杂一点的借口来处理一些情形，例如用户认证，cookies和代理等等。下面让我们开始来学习它们吧。</p>
<hr>
<h2 id="从简单语句中开始:">从简单语句中开始:</h2>
<p>前面说过，使用两个模块，访问网页变得就会像访问文件一样方便。在一般情况下，urllib2访问会更好些（效率上更好，不过urllib还是需要使用，后面会介绍需要urllib做一些事情），所以下面我们来看看使用urllib2的最简单的例子。</p>
<pre><code><span class="title">import</span> urllib2;

<span class="title">response</span> = urllib2.urlopen(<span class="string">"http://www.zhonghuan.info"</span>);
<span class="title">html</span> = response.read();
<span class="title">print</span> html;
</code></pre><p>在终端下下输入命令行  python test.py &gt; zhonghuan.html ,<br>打开文件后显示的是我的个人blog首页的html代码：</p>
<p><img style="width:100%" alt="" src="http://zhonghuan.qiniudn.com/python%2Fwebspider%2Fwebspider2.png"> </p>
<p>这是最简单的一个利用urllib2访问网页的例子，urllib2是根据URL中:前面的部分来判断是用什么协议访问的，例如，上面的例子我们用的时http，这里也可以换成ftp:,file:,等。。。我们可以不用去了解它内部是如何封装这些网络协议的。</p>
<p>urllib2中可以用一个镜像对象（Request Object）来表示我们http访问，它标示你想要访问的URL地址，我们来看一下下面的例子。</p>
<pre><code><span class="built_in">import</span> urllib2

<span class="variable">req =</span> urllib2.Request('http://www.zhonghuan.info')
<span class="variable">response =</span> urllib2.urlopen(req)
<span class="variable">the_page =</span> response.read()
print(the_page)
</code></pre><p>req变量就是一个Request对象。它确切的标示了你要访问的URL地址。（这里是<a href="http://www.zhonghuan.info）；对于其它的形式的访问，例如ftp和file，形式也是类似的，具体可以看[这里][2" target="_blank" rel="external">http://www.zhonghuan.info）；对于其它的形式的访问，例如ftp和file，形式也是类似的，具体可以看[这里][2</a>];</p>
<p>其实，Request对象还能做两个额外的事情。</p>
<ol>
<li>你可以发送数据给服务器。</li>
<li>你可以发送一些额外的信息（又叫元数据，描述数据的数据。一些语言里面的元类是生成类的类，如python就在这些语言中；所以元数据，顾名思义，描述数据的数据，那么这些被描述的数据是什么呢？上面中，还有request对象的一些信息，而这些描述被放在http头部发送出去了。有关http header，可以看<a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">这里</a>）;</li>
</ol>
<hr>
<h2 id="传送数据给服务器">传送数据给服务器</h2>
<p>有时候，你需要发送数据给服务器，这个地址是URL表示的，通常呢，这个地址的指向是CGI（Common Gateway Interface）脚本或者是其它一些网络应用。（关于CGI脚本,可以看<a href="http://www.jdon.com/idea/cgi.htm" target="_blank" rel="external">这里</a>，简单的说就是处理上传数据的脚本程序）。在HTTP访问中，通常使用哪个POST方式将数据发送出去，就好像你填完了html中得表单，你需要把表单中得数据发送出去，通常这里使用post请求。当然，post使用还有其它的情况，不单单指的是表单这一种情况。</p>
<p>让我们先看下面的代码：</p>
<pre><code>import urllib
import urllib2

url = <span class="string">'http://www.someserver.com/cgi-bin/register.cgi'</span>
<span class="keyword">values</span> = {<span class="string">'name'</span> : <span class="string">'Michael Foord'</span>,
      <span class="string">'location'</span> : <span class="string">'Northampton'</span>,
      <span class="string">'language'</span> : <span class="string">'Python'</span> }
data = urllib.urlencode(<span class="keyword">values</span>)  <span class="comment">#数据需要重新编码成合适的格式，这里使用的时urllib中得方法，因为urllib2中没有编码的方法</span>
req = urllib2.Request(url, data)  <span class="comment"># #这里将需要上传的数据，传递给了equest对象，作为它的参数</span>
response = urllib2.urlopen(req)
the_page = response.<span class="keyword">read</span>()
</code></pre><p>关于其它类型的数据上传，可以看<a href="http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13" target="_blank" rel="external">这里</a></p>
<p>除了使用post方式上传数据外，还可以使用get方式上传数据，get上传和post上传明显的区别就是get上传的数据会在URL中得尾部显示出来。可以看下面的代码：</p>
<hr>
<pre><code><span class="import"><span class="keyword">import</span> urllib</span>
<span class="import"><span class="keyword">import</span> urllib2</span>

<span class="typedef"><span class="keyword">data</span> = <span class="container">{}</span></span>
<span class="typedef"><span class="keyword">data</span>['name'] = '<span class="type">Somebody</span> <span class="type">Here'</span></span>
<span class="typedef"><span class="keyword">data</span>['location'] = '<span class="type">Northampton'</span></span>
<span class="typedef"><span class="keyword">data</span>['language'] = '<span class="type">Python'</span></span>

<span class="title">url_values</span> = urllib.urlencode(<span class="typedef"><span class="keyword">data</span>)</span>
<span class="title">print</span> url_values  # 这里的顺序不一定

<span class="title">url</span> = 'http://www.example.com/example.cgi'
<span class="title">full_url</span> = url + '?' + url_values
<span class="typedef"><span class="keyword">data</span> = urllib2.urlopen<span class="container">(<span class="title">full_url</span>)</span></span>
</code></pre><p>可以悄悄打印出来url_value的形式。</p>
<hr>
<h2 id="HTTP头—描述数据的数据">HTTP头—描述数据的数据</h2>
<p>现在，我们来讨论一下HTTP头，来看看如何在你的HTTP的Request对象，增加一个HTTP头。</p>
<p>有一些网站，它比较智能，它不喜欢被程序访问（非人为的点击只会加重它服务器的负担）。或者有些网站更加智能点，对于不同的浏览器，会发送不同的网页数据。</p>
<p>可是呢，urllib2默认,会这样标示自己，<code>Python-urllib/x.y</code>(其中，x和y分别是大小版本号，例如我现在使用的时<code>Python-urllib/2.7</code>);而这些数据可能会让一些站点觉得迷惑，要是遇上了不喜欢被程序访问的网站，那么这样的访问可能会直接被忽视。所以，你可以构造一些身份，让站点不会拒绝你。看下面的例子。</p>
<pre><code><span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib2

url <span class="subst">=</span> <span class="string">'http://www.someserver.com/cgi-bin/register.cgi'</span>
user_agent <span class="subst">=</span> <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span> <span class="variable">#user_agent</span>用来标示你的浏览器的，向这里就是mozilla
values <span class="subst">=</span> {<span class="string">'name'</span> : <span class="string">'Michael Foord'</span>,
      <span class="string">'location'</span> : <span class="string">'Northampton'</span>,
      <span class="string">'language'</span> : <span class="string">'Python'</span> }

headers <span class="subst">=</span> { <span class="string">'User-Agent'</span> : user_agent }
<span class="built_in">data</span> <span class="subst">=</span> urllib<span class="built_in">.</span>urlencode(values)

req <span class="subst">=</span> urllib2<span class="built_in">.</span>Request(url, <span class="built_in">data</span>, headers)

response <span class="subst">=</span> urllib2<span class="built_in">.</span>urlopen(req)

the_page <span class="subst">=</span> response<span class="built_in">.</span>read()    
</code></pre><hr>
<h2 id="异常">异常</h2>
<p>异常时常有，要小心提防呐！想想一般文件操作的时候，会有什么异常呢？文件无法打开，什么权限不够啊，文件不存在啊等等异常。同样的，对于URL访问，也会遇到这些问题，（python一些内部异常，例如ValueError，TypeError等异常，也可能会发生）</p>
<p><br></p>
<h4 id="URLError">URLError</h4>
<p>先说说URLError，当没有网络连接，或者访问的服务器地址不存在的时候，在这种情况下，URLError会被抛出来，这个时候，URLError异常会有个“reason”属性，它是一个元组，包含error code（int型）和text error message（string型），看下面的代码</p>
<pre><code><span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib2


req = urllib2.Request(<span class="string">'http://www.pretend_server.org'</span>)
<span class="keyword">try</span>: urllib2.urlopen(req)
<span class="keyword">except</span> urllib2.URLError <span class="keyword">as</span> e:
    <span class="keyword">print</span> e.reason
</code></pre><p>输出<code>[Errno 8] nodename nor servname provided, or not known</code>;输出的内容就是reason，</p>
<p><br></p>
<h4 id="HTTPError">HTTPError</h4>
<p>每一个HTTP访问，会从服务器那儿获得一个“status code”（状态码），通常这些状态码告诉我们服务器无法满足一些访问（直白点说就是一些数据而已，只不过表示的是当前访问的状态，比如当前访问被拒绝了，status code可以告诉你，你哪些举动过分了，出格了，注意，咸猪手不可以有啊~~）。</p>
<p>不过呢，urllib2的默认处理器能够帮助你处理一些服务器的响应，比如说你当前访问的网址被服务器重定向了，就是说你的服务器给你一个新的URL访问了，处理器会帮你直接去访问新的URL。</p>
<p>但是默认的处理器毕竟功能有限，它不能帮助你解决所有问题，比如你访问的网站不存在了（对应404错误，我们有时候会看到这个错误），或者你的访问被禁止了（对应403错误，禁止的原因可能是因为你的权限不够啦等等），又或者是需要你验证啦（对应401）。具体的其它错误本文就不介绍啦，具体可以看<a href="http://baike.baidu.com/view/1399931.htm" target="_blank" rel="external">这里</a></p>
<p>让我们看下面的程序，看一下当HTTPError的404错误，也就是页面不存在时候，它会输出点什么。</p>
<pre><code><span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib2


req = urllib2.Request(<span class="string">'http://www.zhonghuan.info/no_way'</span>)
<span class="keyword">try</span>: urllib2.urlopen(req)
<span class="keyword">except</span> urllib2.HTTPError <span class="keyword">as</span> e:
       <span class="keyword">print</span> e.code;
     <span class="keyword">print</span> e.read();         
</code></pre><p>输出：<br>404</p>
<p><code>&lt;!DOCTYPE html&gt;</code></p>
<p>…</p>
<p><code>&lt;title&gt;Page not found &amp;middot; GitHub Pages&lt;/title&gt;</code></p>
<p>…</p>
<p><br></p>
<h4 id="处理异常">处理异常</h4>
<p>假设你想要捕捉HTTPError和URLError，有两种基本的方法，推荐第二种噢！</p>
<p><strong>第一种：</strong></p>
<pre><code><span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request, urlopen, URLError, HTTPError


req = Request(http://zhonghuan.info)
<span class="keyword">try</span>:
    response = urlopen(req)
<span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:
    <span class="keyword">print</span> <span class="string">'The server couldn\'t fulfill the request.'</span>
    <span class="keyword">print</span> <span class="string">'Error code: '</span>, e.code
<span class="keyword">except</span> URLError <span class="keyword">as</span> e:
    <span class="keyword">print</span> <span class="string">'We failed to reach a server.'</span>
    <span class="keyword">print</span> <span class="string">'Reason: '</span>, e.reason
<span class="keyword">else</span>:
    <span class="comment"># everything is fine</span>
</code></pre><p>第一种方法，HTTPError一定要放在URLError前面，原因呢，和很多语言的异常处理机制一样，HTTPError是URLError的子类，如果发生了HTTPError，它可以被当做是URLError被捕捉。   </p>
<p><strong>第二种：</strong></p>
<pre><code><span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request, urlopen, URLError


req = Request(someurl)
<span class="keyword">try</span>:
       response = urlopen(req)
<span class="keyword">except</span> URLError <span class="keyword">as</span> e:
    <span class="keyword">if</span> hasattr(e, <span class="string">'reason'</span>):
        <span class="keyword">print</span> <span class="string">'We failed to reach a server.'</span>
        <span class="keyword">print</span> <span class="string">'Reason: '</span>, e.reason
    <span class="keyword">elif</span> hasattr(e, <span class="string">'code'</span>):
        <span class="keyword">print</span> <span class="string">'The server couldn\'t fulfill the request.'</span>
        <span class="keyword">print</span> <span class="string">'Error code: '</span>, e.code
<span class="keyword">else</span>:
    <span class="comment"># everything is fine        </span>
</code></pre><p><br></p>
<h4 id="info和geturl">info和geturl</h4>
<p>这里介绍两个方法info()和geturl()；</p>
<p>geturl():该方法会返回访问的页面的真实的URL，它的价值在于我们访问的网页可能会被重定向，所以导致访问的URL和我们输入的可能不一样。看下面的例子：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> urllib</span>
<span class="preprocessor"><span class="keyword">import</span> urllib2</span>

url = <span class="comment">'http://weibo.com/u/2103243911';</span>
req = urllib2.Request(url);
response = urllib2.urlopen(req)

<span class="built_in">print</span> <span class="string">"URL:"</span>,url;
<span class="built_in">print</span> <span class="string">"After redirection:"</span>,response.geturl();
</code></pre><p>以我的微博个人主页为例，其实真实访问被重定向了，真实的网址，从输出中可以看出:</p>
<p><code>URL: http://weibo.com/u/2103243911</code><br><br><code>After redirection: http://passport.weibo.com/visitor/visitor?a=enter&amp;url=http%3A%2F%2Fweibo.com%2Fu%2F2103243911&amp;_rand=1409761358.1794</code></p>
<p><br><br>info():可以得到描述页面的信息，返回的是一个<code>httplib.HTTPMessage</code>实例，打印出来很像字典。看下面的代码：</p>
<pre><code><span class="title">import</span> urllib
import urllib2


url = <span class="string">'http://zhonghuan.info'</span>;
<span class="title">req</span> = urllib2.Request(url);
<span class="title">response</span> = urllib2.urlopen(req);
<span class="title">print</span> response.<span class="built_in">info</span>();
<span class="title">print</span> response.<span class="built_in">info</span>().__class__;
</code></pre><p>输出：</p>
<pre><code><span class="attribute">Server</span>: <span class="string">GitHub.com</span>
<span class="attribute">Content-Type</span>: <span class="string">text/html; charset=utf-8</span>
<span class="attribute">Last-Modified</span>: <span class="string">Tue, 02 Sep 2014 17:01:39 GMT</span>
<span class="attribute">Expires</span>: <span class="string">Wed, 03 Sep 2014 15:23:02 GMT</span>
<span class="attribute">Cache-Control</span>: <span class="string">max-age=600</span>
<span class="attribute">Content-Length</span>: <span class="string">4784</span>
<span class="attribute">Accept-Ranges</span>: <span class="string">bytes</span>
<span class="attribute">Date</span>: <span class="string">Wed, 03 Sep 2014 16:38:29 GMT</span>
<span class="attribute">Via</span>: <span class="string">1.1 varnish</span>
<span class="attribute">Age</span>: <span class="string">5127</span>
<span class="attribute">Connection</span>: <span class="string">close</span>
<span class="attribute">X-Served-By</span>: <span class="string">cache-lax1433-LAX</span>
<span class="attribute">X-Cache</span>: <span class="string">HIT</span>
<span class="attribute">X-Cache-Hits</span>: <span class="string">1</span>
<span class="attribute">X-Timer</span>: <span class="string">S1409762309.465760,VS0,VE0</span>
<span class="attribute">Vary</span>: <span class="string">Accept-Encoding</span>

<span class="http"><span class="attribute">Class</span>: <span class="string">httplib.HTTPMessage</span></span>
</code></pre><hr>
<p><br></p>
<h2 id="Opener和Handler">Opener和Handler</h2>
<p>这里介绍Opener和Handler。</p>
<p>什么是Opener呢？其实上面的例子我们一直在用Opener了，就是urlopen。这个是默认的opener，网络访问情况很多，你可以创建比较合适的opener，</p>
<p>什么是Handler呢？其实Opener会调用Handler来处理访问中得琐事，所以Handler很重要，对于特定的协议（例如FTP，HTTP），它知道如何如何处理访问，例如它会帮你处理重定向问题。</p>
<p>在访问的时候，你可能对于Opener有一些要求，例如，你希望得到的Opener能够处理cookie，或者你不希望Opener帮助你处理重定向。</p>
<p>我们如何生成需要得Opener呢？（这里插一下，个人觉得这里的Opener生成方式，和设计模式中得生成器欧式，又叫建造者模式，英文名称Builder Pattern；有些相似，不过不完全一样，但总觉得，在看下去之前，先了解一下这个模式会有好处，没有接触过的朋友可以看这篇<a href="http://blog.csdn.net/zhonghuan1992/article/details/38418139" target="_blank" rel="external">Builder pattern</a>）;</p>
<p>要创建一个 opener，可以实例化一个OpenerDirector，<br>然后调用.add_handler(some_handler_instance)。</p>
<p>不过，可以使用build_opener，这是一个更加方便的函数，用来创建opener对象，他只需要一次函数调用。build_opener默认添加几个处理器，但提供快捷的方法来添加或更新默认处理器。<br>其他的处理器handlers你或许会希望处理代理，验证，和其他常用但有点特殊的情况。</p>
<p>刚刚提到handler会帮我们处理重定向，但是，如果我们不想要重定向呢，该怎么办，自定义一个handler。看下面的代码：</p>
<pre><code>mport urllib
<span class="keyword">import</span> urllib2


<span class="class"><span class="keyword">class</span> <span class="title">RedirectHandler</span><span class="params">(urllib2.HTTPRedirectHandler)</span>:</span><span class="comment"># 这个RedirectHandler继承了HTTPRedirectHandler，不过，它覆盖了父类的方法，让它什么都不做，失去了重定向的功能。</span>
    <span class="function"><span class="keyword">def</span> <span class="title">http_error_301</span><span class="params">(self, req, fp, code, msg, headers)</span>:</span>
        <span class="keyword">pass</span>
    <span class="function"><span class="keyword">def</span> <span class="title">http_error_302</span><span class="params">(self, req, fp, code, msg, headers)</span>:</span>
        <span class="keyword">pass</span>


webo = <span class="string">"http://weibo.com/u/2103243911"</span>; <span class="comment">#访问的是我的微博页面，因为正常情况下，访问时会发生重定向</span>
opener = urllib2.build_opener(RedirectHandler) <span class="comment">#这里，我们自定义了一个opener，添加了一个重定向时处理的自定义handler</span>
response = opener.open(webo);<span class="comment"># response  = urllib2.urlopen(webo);</span>
<span class="keyword">print</span> response.geturl();
urllib2.install_opener(opener);  <span class="comment">#安装自定义的opener，以后调用urllib2的时候，返回的就是这个opener。</span>
</code></pre><p>输出结果是：<br><code>urllib2.HTTPError: HTTP Error 302: Moved Temporarily</code></p>
<p>之所以发生http error 302，是因为本来访问我的微博个人主页的时候，它应该发生重定向的，可是我们自己的重定向Handler什么都不做，结果就是发生异常了。</p>
<p>可以看看下面的urllib2关于创建自定义Opener的类图</p>
<p><br><br><img src="http://zhonghuan.qiniudn.com/python%2Fwebspider%2Fwebspider3.gif" alt=""></p>
<hr>
<p><br></p>
<h2 id="Basic_Authentication">Basic Authentication</h2>
<p>如果一个网站，他提供注册登入这些功能，那么一般它有用户名/密码,如果你访问的页面，系统要求你提供用户名/密码，这个过程叫做Authentication，实在服务器那端所做的操作。它给一些页面提供了安全保护。</p>
<p>一个基本的Authentication（验证）过程是这样的：</p>
<ol>
<li>客户端提出请求访问某些页面。</li>
<li>服务器返回一个错误，要求进行身份验证。</li>
<li>客户端把用户名/密码（一般这样）编码后发给服务器。</li>
<li>服务器检查这对用户名/密码是否正确，然后返回用户请求的页面或者是一些错误。</li>
</ol>
<p>上面的过程，还有可能是其它形式，这里只是举个比较普遍的。</p>
<p>通常服务器返回的是401错误，表明访问的网页未授权，同时，返回的response的header内有形如</p>
<p><code>WWW-Authenticate: SCHEME realm=&quot;REALM&quot;.</code></p>
<p>的内容，例如，你想要访问cPanel的管理应用程序，你会收到这样的header：<code>WWW-Authenticate: Basic realm=&quot;cPanel&quot;</code>（cPanel 是一套在网页寄存业中最享负盛名的商业软件，其基于 Linux 和 BSD 系统及以 PHP 开发且性质为闭源软件；cPanel 主要是面向客户权级的控制系统）</p>
<p>当我们访问页面的时候，opener会调用handler来处理各种情况，而处理Authentication的handler是urllib2.HTTPBasicAuthHandler，同时需要一个用户密码管理器urllib2.HTTPPasswordMgr。</p>
<p>不幸的时，HTTPPasswordMgr有一个小问题，就是在获取网页前，你需要知道它的realm。幸运的是，它有一个表兄弟HTTPPasswordMgrWithDefaultRealm，这个表兄弟可以事先不知道realm，在realm参数位置上，可以传一个None进去，它更友好的被使用。</p>
<p>下面参考下面的代码：</p>
<pre><code><span class="built_in">import</span> urllib2


<span class="variable">url =</span> 'http://www.weibo.com'<span class="comment">#分别对应域名，账号，密码</span>
<span class="variable">username =</span> 'zhonghuan'
<span class="variable">password =</span> 'forget_it'
<span class="variable">passman =</span> urllib2.HTTPPasswordMgrWithDefaultRealm() <span class="comment">#创建密码管理器</span>
passman.add_password(None, url, username, password)<span class="comment"># 参数形式（realm，URL，UserName，Password）</span>
<span class="variable">authhandler =</span> urllib2.HTTPBasicAuthHandler(passman)<span class="comment">#创建Authentication的handler</span>
<span class="variable">opener =</span> urllib2.build_opener(authhandler)
urllib2.install_opener(opener) <span class="comment">#和上面介绍的一样，install_opener后，每次调用urllib2的urlopen，返回的就是这个opener</span>
<span class="variable">pagehandle =</span> urllib2.urlopen(url)
</code></pre><hr>
<p><br></p>
<h2 id="代理">代理</h2>
<p>有时候，我们本机不能直接访问，需要代理服务器去访问。urllib2对这个设置代理支持的还不错，可以直接实例化ProxyHandler，它的参数是一个map，key值是代理的访问协议名称，value值是代理的地址。看下面的代码实现。</p>
<pre><code><span class="built_in">import</span> urllib2


<span class="variable">enable_proxy =</span> True
<span class="variable">proxy_handler =</span> urllib2.ProxyHandler({<span class="string">"http"</span> : 'http://some-proxy.com:<span class="number">8080</span>'})
<span class="variable">null_proxy_handler =</span> urllib2.ProxyHandler({})
<span class="keyword">if</span> enable_proxy:
    <span class="variable">opener =</span> urllib2.build_opener(proxy_handler)
<span class="keyword">else</span>:
    <span class="variable">opener =</span> urllib2.build_opener(null_proxy_handler)
urllib2.install_opener(opener)
</code></pre><hr>
<p><br></p>
<h2 id="Timeout_设置">Timeout 设置</h2>
<p>在老版 Python 中，urllib2 的 API 并没有暴露 Timeout 的设置，要设置 Timeout 值，只能更改 Socket 的全局 Timeout 值。</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> urllib2</span>
<span class="preprocessor"><span class="keyword">import</span> socket</span>


socket.setdefaulttimeout(<span class="number">10</span>)<span class="preprocessor"> # 10 秒钟后超时</span>
urllib2.socket.setdefaulttimeout(<span class="number">10</span>)<span class="preprocessor"> # 另一种方式</span>
</code></pre><p>在 Python 2.6 以后，超时可以通过 urllib2.urlopen() 的 timeout 参数直接设置。</p>
<pre><code><span class="built_in">import</span> urllib2

<span class="variable">response =</span> urllib2.urlopen('http://www.google.com', <span class="variable">timeout=</span><span class="number">10</span>)
</code></pre><hr>
<p><br></p>
<h2 id="Cookie">Cookie</h2>
<p>urllib2 对 Cookie 的处理也是自动的。如果需要得到某个 Cookie 项的值，可以这么做：</p>
<pre><code>import urllib2
import cookielib


cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))
response = opener.<span class="built_in">open</span>(<span class="string">'http://www.google.com'</span>)
<span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> cookie:
    <span class="keyword">if</span> <span class="keyword">item</span>.name == <span class="string">'some_cookie_item_name'</span>:
        print <span class="keyword">item</span>.<span class="built_in">value</span>
</code></pre><hr>
<p><br></p>
<h2 id="Debug_Log">Debug Log</h2>
<p>使用 urllib2 时，可以通过下面的方法把 debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试，有时可以省去抓包的工作</p>
<pre><code><span class="built_in">import</span> urllib2


<span class="variable">httpHandler =</span> urllib2.HTTPHandler(<span class="variable">debuglevel=</span><span class="number">1</span>)
<span class="variable">httpsHandler =</span> urllib2.HTTPSHandler(<span class="variable">debuglevel=</span><span class="number">1</span>)
<span class="variable">opener =</span> urllib2.build_opener(httpHandler, httpsHandler)
urllib2.install_opener(opener)
<span class="variable">response =</span> urllib2.urlopen('http://www.google.com')
</code></pre><hr>
<h2 id="参考资料：">参考资料：</h2>
<ol>
<li><p><a href="https://docs.python.org/2.7/howto/urllib2.html" target="_blank" rel="external">python urllib2的使用</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://blog.csdn.net/column/details/why-bug.html" target="_blank" rel="external">python网络爬虫入门教程</a> <strong>(推荐)</strong> </p>
</li>
<li><p><a href="http://www.jdon.com/idea/cgi.htm" target="_blank" rel="external">CGI脚本入门</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://daoluan.net/blog/urllib2-source-decode/" target="_blank" rel="external">urllib2 源码小剖</a> </p>
</li>
<li><p><a href="http://zhuoqiang.me/python-urllib2-usage.html" target="_blank" rel="external">Python 标准库 urllib2 的使用细节</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://www.voidspace.org.uk/python/articles/authentication.shtml" target="_blank" rel="external">Authentication with Python</a> <strong>(推荐)</strong></p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">http://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a></p>
</li>
</ol>
<hr>
]]></content>
    
    
      <category term="python" scheme="http://zhonghuan.info/tags/python/"/>
    
      <category term="webspider" scheme="http://zhonghuan.info/tags/webspider/"/>
    
      <category term="urllib" scheme="http://zhonghuan.info/tags/urllib/"/>
    
      <category term="urllib2" scheme="http://zhonghuan.info/tags/urllib2/"/>
    
      <category term="python网络爬虫" scheme="http://zhonghuan.info/categories/webspider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://zhonghuan.info/2014/09/01/hello-world/"/>
    <id>http://zhonghuan.info/2014/09/01/hello-world/</id>
    <published>2014-09-01T08:28:04.000Z</published>
    <updated>2014-09-01T08:28:04.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    
  </entry>
  
</feed>
